/* Generated code for Python source for module 'direct.task.Task'
 * created by Nuitka version 0.5.26
 *
 * This code is in part copyright 2017 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_direct$task$Task is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_direct$task$Task;
PyDictObject *moduledict_direct$task$Task;

/* The module constants used, if any. */
extern PyObject *const_str_plain_replaceMethod;
static PyObject *const_str_plain_mgr;
extern PyObject *const_str_plain_get;
extern PyObject *const_str_plain_GlobPattern;
extern PyObject *const_str_plain_taskOrName;
static PyObject *const_str_plain_monitorDoLaterExtraArgs;
static PyObject *const_tuple_str_plain_self_str_plain_chainName_tuple;
static PyObject *const_str_plain__TaskManager__tryReplaceTaskMethod;
extern PyObject *const_tuple_str_chr_42_tuple;
static PyObject *const_tuple_str_digest_071fbe783e195c14275508b31303991a_tuple;
static PyObject *const_str_plain___setupTask;
static PyObject *const_str_plain_poll;
static PyObject *const_str_plain__testTaskObj;
static PyObject *const_tuple_str_plain_testGetTasks1_tuple;
static PyObject *const_str_plain_running;
extern PyObject *const_str_plain_do_method_later;
static PyObject *const_str_plain_hasTaskChain;
static PyObject *const_str_plain_setFunction;
static PyObject *const_str_plain__DoLaterOwner;
static PyObject *const_str_plain_getrefcount;
extern PyObject *const_str_plain_sort;
extern PyObject *const_str_plain_oldMethod;
static PyObject *const_str_plain_arg1;
extern PyObject *const_str_digest_485ce81cec1a1f31081339bcf501b5fc;
static PyObject *const_str_plain_testExtraArgs;
static PyObject *const_str_plain_setFrameBudget;
static PyObject *const_str_plain__stopTrackingMemLeaks;
static PyObject *const_str_plain__getRandomTask;
static PyObject *const_str_digest_d9c88a80b6ea433ce132c4da5949f74d;
static PyObject *const_str_digest_49566355c2bc2c37328e332e8eb3cbca;
static PyObject *const_str_plain_keyboardInterruptHandler;
static PyObject *const_tuple_str_plain_StateVar_tuple;
static PyObject *const_str_plain_doYield;
extern PyObject *const_str_plain_setUponDeath;
extern PyObject *const_str_plain_again;
extern PyObject *const_float_1_0;
static PyObject *const_tuple_str_digest_692d590b076085f41291e6af4c948d56_int_0_tuple;
extern PyObject *const_str_plain_Task;
static PyObject *const_str_plain_taskArgs;
static PyObject *const_str_plain_monitorDoLaterPri;
extern PyObject *const_str_digest_c7934e5040220a373c561f5656379884;
extern PyObject *const_list_int_0_list;
extern PyObject *const_str_plain_addTask;
static PyObject *const_str_plain_DSAgain;
extern PyObject *const_str_plain__addTask;
static PyObject *const_str_plain__testTaskObjRemove;
static PyObject *const_str_plain_getTask;
static PyObject *const_str_digest_22dff21c3b984696a3f596fd6541e8e0;
static PyObject *const_str_plain_testRemoveTasksMatching1a;
static PyObject *const_str_plain__testDupNameDoLaters;
extern PyObject *const_int_neg_1;
static PyObject *const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef;
static PyObject *const_tuple_9164157e4224bb8628f920ece9896c02_tuple;
static PyObject *const_str_plain_getFunction;
static PyObject *const_str_plain__TaskManager__makeTaskList;
static PyObject *const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple;
extern PyObject *const_str_plain_set;
extern PyObject *const_tuple_str_plain_DirectObject_tuple;
static PyObject *const_str_digest_884d50a542657f8d9c97ec0b2197090f;
static PyObject *const_str_plain__testDoLaterPri1;
static PyObject *const_dict_f6fd31b757f98ae2cae04de91e28d807;
static PyObject *const_str_plain_testGetTasksNamed;
static PyObject *const_str_plain_valueStr;
extern PyObject *const_str_plain_getName;
extern PyObject *const_str_plain_extraArgs;
static PyObject *const_str_plain_testGetTasks2;
static PyObject *const_str_plain_testGetTasks3;
static PyObject *const_str_plain_testGetTasks1;
extern PyObject *const_str_plain_send;
static PyObject *const_str_plain_print_exc;
extern PyObject *const_str_plain_removeTask;
static PyObject *const_str_plain_testDupNameDoLater;
extern PyObject *const_str_plain_StateVar;
extern PyObject *const_str_digest_85bc21db0baeb246688676279324da7c;
static PyObject *const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple;
extern PyObject *const_str_plain_hasTaskNamed;
static PyObject *const_str_plain_getAllTasks;
static PyObject *const_tuple_4c2cf27dda632ec273727b84108dc762_tuple;
static PyObject *const_str_plain_DSPickup;
extern PyObject *const_str_plain___init__;
extern PyObject *const_str_plain_warning;
extern PyObject *const_tuple_str_plain_messenger_tuple;
extern PyObject *const_str_plain_doMethodLater;
static PyObject *const_str_digest_c547fa892b0cc5cd9e6d71e528dd8f39;
static PyObject *const_str_digest_f9fc41598bc46920591fd091b028aaf0;
static PyObject *const_tuple_str_plain_testGetTasks3_tuple;
extern PyObject *const_str_plain_items;
extern PyObject *const_str_plain_setRealTime;
static PyObject *const_str_digest_02cb46f2b0d2122337d6d7767f333fbf;
static PyObject *const_str_plain_findTasksMatching;
extern PyObject *const_str_plain_setPriority;
static PyObject *const_str_plain_getNumTasks;
static PyObject *const_str_plain_startRefCount;
static PyObject *const_tuple_str_plain_testHasTaskNamed_tuple;
extern PyObject *const_float_0_1;
extern PyObject *const_float_0_0;
static PyObject *const_str_plain_testDoLater2;
static PyObject *const_str_plain_testDoLater3;
static PyObject *const_str_plain_testDoLater1;
extern PyObject *const_str_plain_DtoolClassDict;
static PyObject *const_str_plain_pStatsTasks;
static PyObject *const_tuple_str_plain_testRemoveTasksMatching_tuple;
static PyObject *const_str_plain_AsyncTaskPause;
static PyObject *const_str_plain__testDoLaterOwner;
extern PyObject *const_str_plain_reverse;
static PyObject *const_str_plain_clockObject;
static PyObject *const_str_plain__testRemoveTasksMatching;
static PyObject *const_str_plain_f_back;
static PyObject *const_str_plain_testDoLaterPri2;
extern PyObject *const_str_plain_add;
static PyObject *const_str_plain__testPri2;
static PyObject *const_tuple_str_plain_HTTPChannel_extensions_tuple;
static PyObject *const_str_plain__testPri1;
static PyObject *const_str_plain_doLaterOwner;
static PyObject *const_tuple_0dc1ab1b00fc5f234fbb1603f680c525_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_clockObject_tuple;
static PyObject *const_str_plain_arg2;
extern PyObject *const_str_plain_ret;
static PyObject *const_str_plain_addedTaskName;
static PyObject *const_str_plain__getLastTaskProfileSession;
static PyObject *const_str_plain_setArgs;
static PyObject *const_str_plain_getProfileFrames;
extern PyObject *const_str_plain___func__;
extern PyObject *const_str_plain_stopThreads;
extern PyObject *const_str_plain_resumeFunc;
static PyObject *const_tuple_str_plain_testPri2_tuple;
extern PyObject *const_str_plain_delayTime;
static PyObject *const_str_plain__testGetTasksNamed;
static PyObject *const_str_digest_d7a179d50b60b4930c53f672c217befd;
static PyObject *const_tuple_str_plain_self_str_plain_TaskManagerPanel_tuple;
static PyObject *const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple;
static PyObject *const_str_plain_ProfileSession;
static PyObject *const_str_plain__monitorDoLaterUponDeath;
static PyObject *const_str_plain__testDupNameDoLatersRemove;
static PyObject *const_str_plain_clearedTaskName;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_plain_setFunc;
static PyObject *const_str_plain_getProfileFramesSV;
static PyObject *const_tuple_str_plain_numFrames_str_plain_self_tuple;
static PyObject *const_str_plain_AsyncTask;
extern PyObject *const_str_plain_sys;
static PyObject *const_str_plain_setRepeatCount;
static PyObject *const_str_plain__monitorDoLaterPri;
static PyObject *const_str_plain_checkLeak;
static PyObject *const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple;
static PyObject *const_str_digest_8955d2e335f253b150c2e20333ed3782;
static PyObject *const_str_plain_sequence;
static PyObject *const_str_digest_014f9be8fa5c5a865d39b0a74bef3a6e;
static PyObject *const_str_plain__testDone;
extern PyObject *const_float_0_02;
extern PyObject *const_float_0_03;
extern PyObject *const_float_0_01;
extern PyObject *const_str_plain_code;
extern PyObject *const_str_plain_taskChain;
static PyObject *const_str_plain__profileTask;
static PyObject *const_str_digest_32e1b3aeccfbfbe3d7709c786a996e40;
extern PyObject *const_str_plain__varDump__print;
static PyObject *const_str_digest_148d47d5c98a982616178302cd36806d;
static PyObject *const_tuple_str_digest_98168731f04cfeb6639ad5bd1477be10_int_0_tuple;
static PyObject *const_str_plain_nextScheduledTaskTime;
static PyObject *const_str_plain_AsyncTaskManager;
static PyObject *const_str_plain_TaskManagerPanel;
static PyObject *const_str_plain_getNextWakeTime;
static PyObject *const_str_plain__testDoLaterAppendTask;
extern PyObject *const_str_plain_Queue;
extern PyObject *const_tuple_str_plain_self_str_plain_task_tuple;
extern PyObject *const_str_plain_numFrames;
static PyObject *const_str_plain_print_exc_plus;
extern PyObject *const_str_plain_PandaSystem;
static PyObject *const_tuple_str_plain_testDupNameDoLater_tuple;
extern PyObject *const_str_plain_priority;
static PyObject *const_str_plain_getDoLaters;
static PyObject *const_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d;
static PyObject *const_str_plain_monitorDoLaterAppendTask;
static PyObject *const_str_plain_testRemoveTasksMatching2a;
static PyObject *const_tuple_str_plain_testGetTasksNamed_tuple;
static PyObject *const_str_plain_getTasks;
static PyObject *const_str_plain_testTaskObjRemove;
extern PyObject *const_str_plain_f_code;
static PyObject *const_float_0_03333333333333333;
static PyObject *const_tuple_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d_false_tuple;
extern PyObject *const_str_plain_stack;
extern PyObject *const_str_plain_getGlobalPtr;
static PyObject *const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple;
static PyObject *const_str_plain_testRemoveByName;
static PyObject *const_str_plain_tickClock;
extern PyObject *const_str_digest_2abb2b71e1c784ac5cdc21dd54796019;
extern PyObject *const_str_plain_cont;
static PyObject *const_str_plain_TestClass;
extern PyObject *const_str_plain_setSort;
static PyObject *const_str_plain__monitorDoLater;
static PyObject *const_str_plain__monitorDoLaterAppendTask;
extern PyObject *const_str_plain_DirectObject;
extern PyObject *const_str_plain_f_lineno;
static PyObject *const_str_plain_resetClock;
extern PyObject *const_str_plain_enable;
static PyObject *const_str_plain_testContDone;
extern PyObject *const_str_plain_destroy;
static PyObject *const_list_38455ee7e920419e997654e9f66bb83b_list;
extern PyObject *const_str_plain_directNotify;
extern PyObject *const_str_plain_getTasksNamed;
extern PyObject *const_str_plain_profiled;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_finalInit;
static PyObject *const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple;
static PyObject *const_str_digest_40c78e90f83f2d64d9fd828f457bffb6;
static PyObject *const_str_plain_nextTaskTime;
extern PyObject *const_str_plain_random;
static PyObject *const_str_digest_36412136f6a38534526ee3bd8be027b3;
static PyObject *const_str_plain_doLaterTests;
extern PyObject *const_str_plain___metaclass__;
static PyObject *const_str_digest_071fbe783e195c14275508b31303991a;
static PyObject *const_str_plain__profileFrames;
static PyObject *const_str_digest_293919c35bfb52b109247dc353594438;
extern PyObject *const_str_plain_push;
static PyObject *const_str_plain_testDoLaterUponDeath;
static PyObject *const_str_plain_setProfileFrames;
static PyObject *const_str_plain__testDoLater1;
extern PyObject *const_str_plain_ClockObject;
static PyObject *const_str_plain_avgFrameRate;
extern PyObject *const_str_plain_tb_frame;
static PyObject *const_str_plain__testExtraArgs;
extern PyObject *const_str_chr_42;
extern PyObject *const_str_plain_newMethod;
extern PyObject *const_str_plain_time;
extern PyObject *const_str_plain_owner;
static PyObject *const_str_digest_20b8e052796f453b6b98b57ee46dd337;
static PyObject *const_str_plain__testDoLater2;
extern PyObject *const_str_plain_exit;
extern PyObject *const_str_plain_setDelay;
static PyObject *const_str_plain_setThreadPriority;
extern PyObject *const_str_plain_name;
static PyObject *const_str_plain_logTaskProfiles;
static PyObject *const_tuple_str_plain_self_str_plain_StateVar_tuple;
static PyObject *const_tuple_str_plain_default_tuple;
static PyObject *const_str_plain_chainName;
static PyObject *const_str_plain_monitorDoLaterUponDeath;
static PyObject *const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list;
extern PyObject *const_str_plain_test;
extern PyObject *const_str_plain_default;
extern PyObject *const_str_plain_tb_next;
static PyObject *const_str_plain_findTaskChain;
static PyObject *const_str_plain_MaxEpochSpeed;
static PyObject *const_str_plain_FP;
static PyObject *const_str_plain_signalNumber;
static PyObject *const_tuple_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf_tuple;
extern PyObject *const_str_digest_1ec94dde2d7bfdc5166ada89a737ba93;
static PyObject *const_dict_20bf4839fda8a49cec676ef6853196ef;
static PyObject *const_str_plain_default_int_handler;
static PyObject *const_str_plain_taskMgrFrameProfile;
static PyObject *const_str_plain_testTaskObj;
static PyObject *const_str_plain_setClock;
extern PyObject *const_str_plain_now;
static PyObject *const_str_plain___tryReplaceTaskMethod;
static PyObject *const_str_plain_testDone;
static PyObject *const_dict_2c309b6a9a07f2a3a999dce9e263b6ff;
static PyObject *const_str_plain_testDoLaterExtraArgs;
static PyObject *const_dict_393ba663cb39d8e5662104836ff43bdd;
static PyObject *const_str_digest_339421c46c1eca739ff0b1eb64748494;
static PyObject *const_str_plain_SIGINT;
static PyObject *const_tuple_str_plain_self_str_plain_taskName_tuple;
static PyObject *const_dict_752c9f51c629c62cd37d9eb2a6272323;
static PyObject *const_tuple_str_plain_testRemoveTasksMatching1_tuple;
static PyObject *const_str_plain__unpackIOError;
extern PyObject *const_str_plain_taskMgr;
extern PyObject *const_str_plain_newCategory;
static PyObject *const_str_plain_getClock;
extern PyObject *const_str_plain_types;
extern PyObject *const_tuple_int_pos_1_tuple;
static PyObject *const_str_plain__checkMemLeaks;
static PyObject *const_tuple_str_digest_c3ccb889bb2a33c149f483685be0800b_tuple;
extern PyObject *const_str_plain_TaskManager;
extern PyObject *const_tuple_str_plain_l_tuple;
static PyObject *const_str_plain_avgFrameDur;
static PyObject *const_str_plain__testUponDeathFunc;
extern PyObject *const_tuple_none_none_none_tuple;
extern PyObject *const_str_plain_frame;
extern PyObject *const_tuple_str_plain_TaskManager_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple;
extern PyObject *const_str_angle_lambda;
static PyObject *const_str_plain__testGetTasks;
static PyObject *const_str_plain__startTrackingMemLeaks;
extern PyObject *const_str_plain_pop;
static PyObject *const_str_plain__testOwner;
static PyObject *const_str_plain_taskId;
static PyObject *const_str_plain_frameBudget;
static PyObject *const_tuple_str_plain_loop_tuple;
extern PyObject *const_tuple_int_pos_2_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple;
static PyObject *const_str_plain_profileSession;
extern PyObject *const_int_pos_10;
static PyObject *const_str_digest_4b971f3632718df8bdf7fc2cb7d90521;
static PyObject *const_str_plain_profileTasks;
static PyObject *const_tuple_str_plain_sequence_tuple;
static PyObject *const_str_plain_timeslicePriority;
extern PyObject *const_str_plain___call__;
static PyObject *const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple;
static PyObject *const_str_plain_tm;
static PyObject *const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple;
static PyObject *const_str_plain_extendedExceptions;
static PyObject *const_str_plain_taskPattern;
extern PyObject *const_str_plain_tb;
static PyObject *const_tuple_str_plain_testDoLater1_tuple;
static PyObject *const_str_plain__testRemoveByName;
static PyObject *const_str_plain_seq;
static PyObject *const_str_plain_taskList;
static PyObject *const_str_digest_feb617e995cb09fff64cd1ad38571b3f;
extern PyObject *const_str_plain_pickup;
static PyObject *const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple;
static PyObject *const_str_plain__taskProfiler;
static PyObject *const_str_plain_FrameProfiler;
static PyObject *const_str_plain___makeTaskList;
static PyObject *const_str_plain__testGetDoLaters;
extern PyObject *const_str_plain_message;
static PyObject *const_tuple_str_plain_testTaskObj_tuple;
extern PyObject *const_str_plain_ScratchPad;
extern PyObject *const_str_plain_key;
static PyObject *const_str_plain_monitorDoLater;
static PyObject *const_tuple_a0a3a13514ffb5caba494780f2ce74c2_tuple;
extern PyObject *const_str_plain_getValue;
static PyObject *const_str_plain__testDoLaterPri2;
static PyObject *const_tuple_str_digest_f9fc41598bc46920591fd091b028aaf0_false_tuple;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_appendTask;
static PyObject *const_str_plain_TP;
static PyObject *const_dict_11985c3a65ec78b97ae15d2d308b1395;
extern PyObject *const_str_plain_dumpOnExceptionInit;
static PyObject *const_str_plain_DSDone;
static PyObject *const_tuple_str_plain_testCont_tuple;
static PyObject *const_str_plain_fKeyboardInterrupt;
static PyObject *const_str_plain_setupTaskChain;
extern PyObject *const_str_plain_f_locals;
static PyObject *const_str_plain_setProfileTasks;
static PyObject *const_str_plain_chain;
extern PyObject *const_str_plain_value;
static PyObject *const_tuple_str_digest_36412136f6a38534526ee3bd8be027b3_tuple;
static PyObject *const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple;
extern PyObject *const_list_int_pos_4_list;
extern PyObject *const_str_plain__clearTask;
extern PyObject *const_float_1e_minus_05;
static PyObject *const_str_plain_hasName;
static PyObject *const_str_plain_testRemoveTasksMatching2;
static PyObject *const_str_plain_testRemoveTasksMatching1;
static PyObject *const_tuple_str_plain_testRemoveTasksMatching2a_tuple;
static PyObject *const_str_digest_dc372ef8fb63a2f7ba56dd37d0d490c8;
static PyObject *const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple;
static PyObject *const_str_plain__uponDeathFunc;
static PyObject *const_str_plain_uponDeath;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_testDupNameDoLaterRemove;
static PyObject *const_str_plain_getTasksMatching;
extern PyObject *const_list_int_pos_3_list;
static PyObject *const_str_plain_testUponDeath;
extern PyObject *const_str_plain_error;
static PyObject *const_str_plain_testDoLaterOwner;
static PyObject *const_tuple_str_plain_testRemoveByName_tuple;
static PyObject *const_str_plain_numThreads;
extern PyObject *const_int_pos_4;
extern PyObject *const_int_pos_5;
extern PyObject *const_int_pos_2;
extern PyObject *const_int_pos_3;
extern PyObject *const_int_pos_1;
static PyObject *const_str_plain_profileFrames;
static PyObject *const_str_digest_366c6ab541682202d2ba4e1cfb8a21d8;
extern PyObject *const_str_plain_ConfigVariableBool;
static PyObject *const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
static PyObject *const_str_plain_taskCollection;
static PyObject *const_str_plain_startFrameTime;
static PyObject *const_str_digest_e223ebbecbbe1fc3d462b76aa6de6906;
static PyObject *const_str_digest_b3e9cae2fecef7b6d609daf4a6baba31;
static PyObject *const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple;
static PyObject *const_str_plain__TaskOwner;
static PyObject *const_str_digest_14e7a80f5f7f1182fca3d8566b83d9d3;
static PyObject *const_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf;
static PyObject *const_str_plain_randrange;
static PyObject *const_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77;
extern PyObject *const_str_plain_task;
static PyObject *const_dict_e43c4b6e448be1e6a26efea5089b8672;
static PyObject *const_str_plain__testDoLaterExtraArgs;
extern PyObject *const_tuple_int_pos_10_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple;
extern PyObject *const_str_plain_run;
extern PyObject *const_str_plain_co_name;
static PyObject *const_str_plain_flushTaskProfiles;
static PyObject *const_str_digest_fdd30d29d49df04a06d4a80ef85c53fc;
static PyObject *const_str_plain__profileTasks;
extern PyObject *const_str_plain_setName;
extern PyObject *const_str_plain_info;
static PyObject *const_str_plain_getRefCount;
extern PyObject *const_str_plain_num;
static PyObject *const_str_digest_20c100e7e679deb5eb4415251fd9db0b;
static PyObject *const_str_plain_TaskProfiler;
static PyObject *const_list_str_plain_testUponDeath_list;
static PyObject *const_str_digest_79748cc9eb11364c994f6b8db15b4c23;
extern PyObject *const_str_plain_getRealTime;
extern PyObject *const_str_plain_result;
static PyObject *const_str_plain_setFrameSync;
extern PyObject *const_str_plain___self__;
static PyObject *const_tuple_str_plain_testDoLater3_tuple;
static PyObject *const_str_digest_7e047f0e10d78432228c9d9cbabb1012;
extern PyObject *const_str_plain_l;
static PyObject *const_tuple_str_plain_arg1_str_plain_l_tuple;
extern PyObject *const_str_plain_i;
static PyObject *const_str_plain_PS;
extern PyObject *const_str_plain_e;
extern PyObject *const_str_plain_f;
static PyObject *const_str_plain_timeDelta;
extern PyObject *const_str_plain_wantStackDumpLog;
static PyObject *const_str_plain_makeTaskChain;
static PyObject *const_str_digest_d4e4e0734a21d5b1e4b98d82d29d0f71;
extern PyObject *const_str_plain_t;
static PyObject *const_str_digest_162533328c73194d8dad01ad17ef1ee5;
static PyObject *const_str_digest_053c33621531947f586017f14d07df3d;
extern PyObject *const_str_plain_flush;
static PyObject *const_str_plain__TaskManager__setupTask;
static PyObject *const_str_plain_taskFunc;
static PyObject *const_str_plain__testDoLaterUponDeath;
extern PyObject *const_str_plain_clock;
extern PyObject *const_str_plain_function;
extern PyObject *const_str_plain_done;
static PyObject *const_str_plain_testCont;
static PyObject *const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple;
static PyObject *const_str_digest_98168731f04cfeb6639ad5bd1477be10;
extern PyObject *const_str_plain_MethodType;
extern PyObject *const_str_plain___all__;
extern PyObject *const_int_0;
static PyObject *const_str_plain_removeTasksMatching;
static PyObject *const_tuple_str_plain_task_str_plain_l_tuple;
extern PyObject *const_str_plain_messenger;
static PyObject *const_str_plain_getActiveTasks;
extern PyObject *const_str_plain_callback;
static PyObject *const_str_digest_6f6b30f043208ddc0fd34ee37c3374a2;
static PyObject *const_list_int_pos_4_int_pos_5_list;
static PyObject *const_str_plain_getSleepingTasks;
static PyObject *const_str_plain_frameStartTime;
extern PyObject *const_str_plain_append;
extern PyObject *const_str_plain_exc_info;
static PyObject *const_str_plain_getProfileTasks;
static PyObject *const_str_plain__hasProfiledDesignatedTask;
extern PyObject *const_str_plain_popupControls;
extern PyObject *const_str_plain_globalClock;
static PyObject *const_tuple_str_plain_testPri1_tuple;
extern PyObject *const_str_plain_import_module;
static PyObject *const_tuple_str_plain_testRemoveTasksMatching1a_tuple;
static PyObject *const_str_plain__testCont;
extern PyObject *const_str_digest_4314234708fbc134069947f7a4708b23;
static PyObject *const_str_plain__frameProfiler;
static PyObject *const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple;
static PyObject *const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple;
static PyObject *const_str_plain__testDupNamedTasks;
static PyObject *const_str_digest_86a25986da173b225b30ee3209499f63;
static PyObject *const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple;
extern PyObject *const_dict_empty;
static PyObject *const_tuple_bc208da109e99712fefec75b5337e250_tuple;
static PyObject *const_str_plain_threadPriority;
static PyObject *const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple;
extern PyObject *const_str_digest_3dd28ae5a4057083590ecdb59e504cf8;
extern PyObject *const_str_plain_property;
extern PyObject *const_tuple_empty;
extern PyObject *const_str_digest_11eb635c2afc52a8139249187777a73c;
extern PyObject *const_str_plain_tasks;
extern PyObject *const_str_plain_step;
static PyObject *const_tuple_a7664b39550c747f55be06e641fb33ad_tuple;
static PyObject *const_list_int_pos_1_int_pos_2_list;
static PyObject *const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple;
extern PyObject *const_str_plain_next;
static PyObject *const_str_plain_findTasks;
extern PyObject *const_str_plain___repr__;
static PyObject *const_tuple_str_digest_22dff21c3b984696a3f596fd6541e8e0_false_tuple;
static PyObject *const_tuple_str_digest_40c78e90f83f2d64d9fd828f457bffb6_tuple;
static PyObject *const_str_digest_c6e478a3e2e77af3f673a67ea513491a;
static PyObject *const_str_plain_interruptCount;
extern PyObject *const_str_plain_Thread;
static PyObject *const_str_plain_frameSync;
static PyObject *const_str_plain_testDupNamedTasks;
static PyObject *const_tuple_str_digest_4b971f3632718df8bdf7fc2cb7d90521_tuple;
extern PyObject *const_tuple_str_plain_ExceptionVarDump_tuple;
static PyObject *const_str_plain_setOwner;
static PyObject *const_str_plain__profileFunc;
static PyObject *const_str_plain_findTask;
static PyObject *const_str_plain_testRemoveTasksMatching;
static PyObject *const_str_plain__testAppendTask;
extern PyObject *const_str_plain_staticmethod;
static PyObject *const_str_digest_70e66c98789b7a7a51a96af6654254e5;
static PyObject *const_str_plain_signal;
extern PyObject *const_str_plain_taskTimerVerbose;
static PyObject *const_str_plain_logProfiles;
static PyObject *const_str_plain_testHasTaskNamed;
static PyObject *const_str_digest_f52007705b73a852251f306ade6b0b32;
static PyObject *const_str_plain__runTests;
static PyObject *const_str_plain_session;
static PyObject *const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple;
extern PyObject *const_str_plain_remove;
static PyObject *const_str_plain_setTickClock;
static PyObject *const_str_plain_getArgs;
static PyObject *const_tuple_str_plain_self_str_plain_taskPattern_tuple;
static PyObject *const_str_plain_stepping;
extern PyObject *const_str_plain_HTTPChannel_extensions;
static PyObject *const_str_plain_getProfileSession;
static PyObject *const_dict_1b3ca16c1519c7adb9906eff10d088a1;
static PyObject *const_str_plain__monitorDoLaterOwner;
static PyObject *const_tuple_str_plain_testGetTasks2_tuple;
static PyObject *const_str_plain_DSCont;
static PyObject *const_tuple_none_none_none_none_none_false_none_tuple;
static PyObject *const_str_plain_destroyed;
static PyObject *const_str_plain_numFound;
static PyObject *const_str_plain__taskProfileInfo;
static PyObject *const_str_plain_profileInfo;
static PyObject *const_str_digest_d533b57f698317f04ca0c379c0ad0a9a;
static PyObject *const_str_plain__testHasTaskNamed;
static PyObject *const_list_int_pos_10_list;
static PyObject *const_str_digest_692d590b076085f41291e6af4c948d56;
static PyObject *const_tuple_none_none_none_none_none_none_tuple;
static PyObject *const_str_plain_stackFrame;
static PyObject *const_str_plain_AsyncTaskSequence;
extern PyObject *const_str_plain_release;
static PyObject *const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple;
extern PyObject *const_str_plain_getCurrentTask;
extern PyObject *const_str_plain___module__;
extern PyObject *const_tuple_int_neg_1_tuple;
extern PyObject *const_str_plain_getCurrentThread;
static PyObject *const_str_plain_monitorDoLaterOwner;
extern PyObject *const_str_plain_cleanup;
static PyObject *const_str_plain_testOwner;
static PyObject *const_str_plain_getWakeTime;
extern PyObject *const_str_plain_list;
static PyObject *const_tuple_5f3efb215a8d38403650998c55156313_tuple;
static PyObject *const_tuple_str_plain_test_tuple;
static PyObject *const_str_plain_getPlatform;
static PyObject *const_str_digest_17d25158b9df61b35e5a5db332529ea5;
static PyObject *const_str_plain_invokeDefaultHandler;
extern PyObject *const_str_plain_ExceptionVarDump;
extern PyObject *const_str_digest_3d04e07393c6560e489a0567631d62c2;
static PyObject *const_str_plain_setNumThreads;
extern PyObject *const_str_plain_newFunction;
extern PyObject *const_str_plain_doTask;
static PyObject *const_tuple_str_digest_70e66c98789b7a7a51a96af6654254e5_tuple;
static PyObject *const_str_plain_DSExit;
extern PyObject *const_str_plain_pause;
static PyObject *const_str_plain_emscripten;
static PyObject *const_str_digest_835923a846bcd1d3fbfc6194aef55753;
static PyObject *const_tuple_str_plain_testDoLater2_tuple;
extern PyObject *const_str_plain_method;
extern PyObject *const_str_plain_notify;
extern PyObject *const_str_plain_co_filename;
static PyObject *const_str_plain__frameProfileQueue;
static PyObject *const_str_plain_funcOrTask;
extern PyObject *const_str_plain_obj;
static PyObject *const_str_plain_testDoLaterPri1;
static PyObject *const_str_plain_getAverageFrameRate;
static PyObject *const_str_plain_ioError;
static PyObject *const_str_plain_setTimeslicePriority;
extern PyObject *const_str_plain_traceback;
static PyObject *const_tuple_str_plain_testRemoveTasksMatching2_tuple;
extern PyObject *const_tuple_str_plain_self_str_plain_name_tuple;
static PyObject *const_tuple_str_plain_testContDone_tuple;
static PyObject *const_str_plain__monitorDoLaterExtraArgs;
extern PyObject *const_tuple_str_plain_task_tuple;
static PyObject *const_str_plain_testPri2;
static PyObject *const_str_plain_testPri1;
extern PyObject *const_str_plain_Functor;
static PyObject *const_str_plain_testDoLaterAppendTask;
static PyObject *const_str_plain_setTaskChain;
static PyObject *const_str_plain_getProfileTasksSV;
static PyObject *const_str_digest_c3ccb889bb2a33c149f483685be0800b;
extern PyObject *const_str_plain_taskName;
static PyObject *const_str_plain__setProfileTask;
extern PyObject *const_str_plain___doc__;
extern PyObject *const_str_plain_gc;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain__testContDone;
extern PyObject *const_str_empty;
static PyObject *const_str_plain__testUponDeath;
extern PyObject *const_str_plain_stop;
static PyObject *const_str_plain__doProfiledFrames;
static PyObject *const_tuple_none_none_none_none_none_false_none_none_tuple;
static PyObject *const_str_plain_PythonTask;
extern PyObject *const_tuple_false_tuple;
extern PyObject *const_str_plain_importlib;
static PyObject *const_tuple_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77_tuple;
extern PyObject *const_str_plain_loop;
extern PyObject *const_tuple_none_tuple;
extern PyObject *const_str_plain_getFrameTime;
extern PyObject *const_str_plain_acquire;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_plain_mgr = UNSTREAM_STRING( &constant_bin[ 184860 ], 3, 1 );
    const_str_plain_monitorDoLaterExtraArgs = UNSTREAM_STRING( &constant_bin[ 201124 ], 23, 1 );
    const_tuple_str_plain_self_str_plain_chainName_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_chainName_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_chainName = UNSTREAM_STRING( &constant_bin[ 201147 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_chainName_tuple, 1, const_str_plain_chainName ); Py_INCREF( const_str_plain_chainName );
    const_str_plain__TaskManager__tryReplaceTaskMethod = UNSTREAM_STRING( &constant_bin[ 201156 ], 34, 1 );
    const_tuple_str_digest_071fbe783e195c14275508b31303991a_tuple = PyTuple_New( 1 );
    const_str_digest_071fbe783e195c14275508b31303991a = UNSTREAM_STRING( &constant_bin[ 201190 ], 32, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_071fbe783e195c14275508b31303991a_tuple, 0, const_str_digest_071fbe783e195c14275508b31303991a ); Py_INCREF( const_str_digest_071fbe783e195c14275508b31303991a );
    const_str_plain___setupTask = UNSTREAM_STRING( &constant_bin[ 201222 ], 11, 1 );
    const_str_plain_poll = UNSTREAM_STRING( &constant_bin[ 201233 ], 4, 1 );
    const_str_plain__testTaskObj = UNSTREAM_STRING( &constant_bin[ 201237 ], 12, 1 );
    const_tuple_str_plain_testGetTasks1_tuple = PyTuple_New( 1 );
    const_str_plain_testGetTasks1 = UNSTREAM_STRING( &constant_bin[ 201249 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testGetTasks1_tuple, 0, const_str_plain_testGetTasks1 ); Py_INCREF( const_str_plain_testGetTasks1 );
    const_str_plain_running = UNSTREAM_STRING( &constant_bin[ 99572 ], 7, 1 );
    const_str_plain_hasTaskChain = UNSTREAM_STRING( &constant_bin[ 201262 ], 12, 1 );
    const_str_plain_setFunction = UNSTREAM_STRING( &constant_bin[ 201274 ], 11, 1 );
    const_str_plain__DoLaterOwner = UNSTREAM_STRING( &constant_bin[ 201285 ], 13, 1 );
    const_str_plain_getrefcount = UNSTREAM_STRING( &constant_bin[ 201298 ], 11, 1 );
    const_str_plain_arg1 = UNSTREAM_STRING( &constant_bin[ 201309 ], 4, 1 );
    const_str_plain_testExtraArgs = UNSTREAM_STRING( &constant_bin[ 201313 ], 13, 1 );
    const_str_plain_setFrameBudget = UNSTREAM_STRING( &constant_bin[ 201326 ], 14, 1 );
    const_str_plain__stopTrackingMemLeaks = UNSTREAM_STRING( &constant_bin[ 201340 ], 21, 1 );
    const_str_plain__getRandomTask = UNSTREAM_STRING( &constant_bin[ 201361 ], 14, 1 );
    const_str_digest_d9c88a80b6ea433ce132c4da5949f74d = UNSTREAM_STRING( &constant_bin[ 201375 ], 34, 0 );
    const_str_digest_49566355c2bc2c37328e332e8eb3cbca = UNSTREAM_STRING( &constant_bin[ 201409 ], 545, 0 );
    const_str_plain_keyboardInterruptHandler = UNSTREAM_STRING( &constant_bin[ 201954 ], 24, 1 );
    const_tuple_str_plain_StateVar_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_StateVar_tuple, 0, const_str_plain_StateVar ); Py_INCREF( const_str_plain_StateVar );
    const_str_plain_doYield = UNSTREAM_STRING( &constant_bin[ 201978 ], 7, 1 );
    const_tuple_str_digest_692d590b076085f41291e6af4c948d56_int_0_tuple = PyTuple_New( 2 );
    const_str_digest_692d590b076085f41291e6af4c948d56 = UNSTREAM_STRING( &constant_bin[ 201985 ], 14, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_692d590b076085f41291e6af4c948d56_int_0_tuple, 0, const_str_digest_692d590b076085f41291e6af4c948d56 ); Py_INCREF( const_str_digest_692d590b076085f41291e6af4c948d56 );
    PyTuple_SET_ITEM( const_tuple_str_digest_692d590b076085f41291e6af4c948d56_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_taskArgs = UNSTREAM_STRING( &constant_bin[ 201999 ], 8, 1 );
    const_str_plain_monitorDoLaterPri = UNSTREAM_STRING( &constant_bin[ 202007 ], 17, 1 );
    const_str_plain_DSAgain = UNSTREAM_STRING( &constant_bin[ 202024 ], 7, 1 );
    const_str_plain__testTaskObjRemove = UNSTREAM_STRING( &constant_bin[ 202031 ], 18, 1 );
    const_str_plain_getTask = UNSTREAM_STRING( &constant_bin[ 202049 ], 7, 1 );
    const_str_digest_22dff21c3b984696a3f596fd6541e8e0 = UNSTREAM_STRING( &constant_bin[ 202056 ], 18, 0 );
    const_str_plain_testRemoveTasksMatching1a = UNSTREAM_STRING( &constant_bin[ 202074 ], 25, 1 );
    const_str_plain__testDupNameDoLaters = UNSTREAM_STRING( &constant_bin[ 202099 ], 20, 1 );
    const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef, const_str_plain_extraArgs, const_list_int_pos_4_list );
    PyDict_SetItem( const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef, const_str_plain_appendTask, Py_True );
    assert( PyDict_Size( const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef ) == 2 );
    const_tuple_9164157e4224bb8628f920ece9896c02_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 0, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_str_plain_tm = UNSTREAM_STRING( &constant_bin[ 3250 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 1, const_str_plain_tm ); Py_INCREF( const_str_plain_tm );
    PyTuple_SET_ITEM( const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain_doLaterTests = UNSTREAM_STRING( &constant_bin[ 202119 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 3, const_str_plain_doLaterTests ); Py_INCREF( const_str_plain_doLaterTests );
    const_str_plain_getFunction = UNSTREAM_STRING( &constant_bin[ 202131 ], 11, 1 );
    const_str_plain__TaskManager__makeTaskList = UNSTREAM_STRING( &constant_bin[ 202142 ], 26, 1 );
    const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_startFrameTime = UNSTREAM_STRING( &constant_bin[ 202168 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple, 1, const_str_plain_startFrameTime ); Py_INCREF( const_str_plain_startFrameTime );
    const_str_plain_nextTaskTime = UNSTREAM_STRING( &constant_bin[ 202182 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple, 2, const_str_plain_nextTaskTime ); Py_INCREF( const_str_plain_nextTaskTime );
    const_str_digest_884d50a542657f8d9c97ec0b2197090f = UNSTREAM_STRING( &constant_bin[ 202194 ], 55, 0 );
    const_str_plain__testDoLaterPri1 = UNSTREAM_STRING( &constant_bin[ 202249 ], 16, 1 );
    const_dict_f6fd31b757f98ae2cae04de91e28d807 = _PyDict_NewPresized( 1 );
    const_list_int_pos_4_int_pos_5_list = PyList_New( 2 );
    PyList_SET_ITEM( const_list_int_pos_4_int_pos_5_list, 0, const_int_pos_4 ); Py_INCREF( const_int_pos_4 );
    PyList_SET_ITEM( const_list_int_pos_4_int_pos_5_list, 1, const_int_pos_5 ); Py_INCREF( const_int_pos_5 );
    PyDict_SetItem( const_dict_f6fd31b757f98ae2cae04de91e28d807, const_str_plain_extraArgs, const_list_int_pos_4_int_pos_5_list );
    assert( PyDict_Size( const_dict_f6fd31b757f98ae2cae04de91e28d807 ) == 1 );
    const_str_plain_testGetTasksNamed = UNSTREAM_STRING( &constant_bin[ 202265 ], 17, 1 );
    const_str_plain_valueStr = UNSTREAM_STRING( &constant_bin[ 202282 ], 8, 1 );
    const_str_plain_testGetTasks2 = UNSTREAM_STRING( &constant_bin[ 202290 ], 13, 1 );
    const_str_plain_testGetTasks3 = UNSTREAM_STRING( &constant_bin[ 202303 ], 13, 1 );
    const_str_plain_print_exc = UNSTREAM_STRING( &constant_bin[ 202316 ], 9, 1 );
    const_str_plain_testDupNameDoLater = UNSTREAM_STRING( &constant_bin[ 202100 ], 18, 1 );
    const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_taskCollection = UNSTREAM_STRING( &constant_bin[ 202325 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple, 1, const_str_plain_taskCollection ); Py_INCREF( const_str_plain_taskCollection );
    PyTuple_SET_ITEM( const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple, 3, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    const_str_plain_getAllTasks = UNSTREAM_STRING( &constant_bin[ 202339 ], 11, 1 );
    const_tuple_4c2cf27dda632ec273727b84108dc762_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_4c2cf27dda632ec273727b84108dc762_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_frameStartTime = UNSTREAM_STRING( &constant_bin[ 202350 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_4c2cf27dda632ec273727b84108dc762_tuple, 1, const_str_plain_frameStartTime ); Py_INCREF( const_str_plain_frameStartTime );
    const_str_plain_nextScheduledTaskTime = UNSTREAM_STRING( &constant_bin[ 202364 ], 21, 1 );
    PyTuple_SET_ITEM( const_tuple_4c2cf27dda632ec273727b84108dc762_tuple, 2, const_str_plain_nextScheduledTaskTime ); Py_INCREF( const_str_plain_nextScheduledTaskTime );
    const_str_plain_DSPickup = UNSTREAM_STRING( &constant_bin[ 202385 ], 8, 1 );
    const_str_digest_c547fa892b0cc5cd9e6d71e528dd8f39 = UNSTREAM_STRING( &constant_bin[ 202393 ], 13, 0 );
    const_str_digest_f9fc41598bc46920591fd091b028aaf0 = UNSTREAM_STRING( &constant_bin[ 202406 ], 12, 0 );
    const_tuple_str_plain_testGetTasks3_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testGetTasks3_tuple, 0, const_str_plain_testGetTasks3 ); Py_INCREF( const_str_plain_testGetTasks3 );
    const_str_digest_02cb46f2b0d2122337d6d7767f333fbf = UNSTREAM_STRING( &constant_bin[ 202418 ], 210, 0 );
    const_str_plain_findTasksMatching = UNSTREAM_STRING( &constant_bin[ 202628 ], 17, 1 );
    const_str_plain_getNumTasks = UNSTREAM_STRING( &constant_bin[ 202645 ], 11, 1 );
    const_str_plain_startRefCount = UNSTREAM_STRING( &constant_bin[ 202656 ], 13, 1 );
    const_tuple_str_plain_testHasTaskNamed_tuple = PyTuple_New( 1 );
    const_str_plain_testHasTaskNamed = UNSTREAM_STRING( &constant_bin[ 202669 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testHasTaskNamed_tuple, 0, const_str_plain_testHasTaskNamed ); Py_INCREF( const_str_plain_testHasTaskNamed );
    const_str_plain_testDoLater2 = UNSTREAM_STRING( &constant_bin[ 202685 ], 12, 1 );
    const_str_plain_testDoLater3 = UNSTREAM_STRING( &constant_bin[ 202697 ], 12, 1 );
    const_str_plain_testDoLater1 = UNSTREAM_STRING( &constant_bin[ 202709 ], 12, 1 );
    const_str_plain_pStatsTasks = UNSTREAM_STRING( &constant_bin[ 202721 ], 11, 1 );
    const_tuple_str_plain_testRemoveTasksMatching_tuple = PyTuple_New( 1 );
    const_str_plain_testRemoveTasksMatching = UNSTREAM_STRING( &constant_bin[ 202074 ], 23, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveTasksMatching_tuple, 0, const_str_plain_testRemoveTasksMatching ); Py_INCREF( const_str_plain_testRemoveTasksMatching );
    const_str_plain_AsyncTaskPause = UNSTREAM_STRING( &constant_bin[ 202732 ], 14, 1 );
    const_str_plain__testDoLaterOwner = UNSTREAM_STRING( &constant_bin[ 202746 ], 17, 1 );
    const_str_plain_clockObject = UNSTREAM_STRING( &constant_bin[ 202763 ], 11, 1 );
    const_str_plain__testRemoveTasksMatching = UNSTREAM_STRING( &constant_bin[ 202774 ], 24, 1 );
    const_str_plain_f_back = UNSTREAM_STRING( &constant_bin[ 202798 ], 6, 1 );
    const_str_plain_testDoLaterPri2 = UNSTREAM_STRING( &constant_bin[ 202804 ], 15, 1 );
    const_str_plain__testPri2 = UNSTREAM_STRING( &constant_bin[ 202819 ], 9, 1 );
    const_tuple_str_plain_HTTPChannel_extensions_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_HTTPChannel_extensions_tuple, 0, const_str_plain_HTTPChannel_extensions ); Py_INCREF( const_str_plain_HTTPChannel_extensions );
    const_str_plain__testPri1 = UNSTREAM_STRING( &constant_bin[ 202828 ], 9, 1 );
    const_str_plain_doLaterOwner = UNSTREAM_STRING( &constant_bin[ 202837 ], 12, 1 );
    const_tuple_0dc1ab1b00fc5f234fbb1603f680c525_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 202849 ], 1101 );
    const_tuple_str_plain_self_str_plain_clockObject_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_clockObject_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_clockObject_tuple, 1, const_str_plain_clockObject ); Py_INCREF( const_str_plain_clockObject );
    const_str_plain_arg2 = UNSTREAM_STRING( &constant_bin[ 203950 ], 4, 1 );
    const_str_plain_addedTaskName = UNSTREAM_STRING( &constant_bin[ 203954 ], 13, 1 );
    const_str_plain__getLastTaskProfileSession = UNSTREAM_STRING( &constant_bin[ 203794 ], 26, 1 );
    const_str_plain_setArgs = UNSTREAM_STRING( &constant_bin[ 203967 ], 7, 1 );
    const_str_plain_getProfileFrames = UNSTREAM_STRING( &constant_bin[ 203557 ], 16, 1 );
    const_tuple_str_plain_testPri2_tuple = PyTuple_New( 1 );
    const_str_plain_testPri2 = UNSTREAM_STRING( &constant_bin[ 202820 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testPri2_tuple, 0, const_str_plain_testPri2 ); Py_INCREF( const_str_plain_testPri2 );
    const_str_plain__testGetTasksNamed = UNSTREAM_STRING( &constant_bin[ 203974 ], 18, 1 );
    const_str_digest_d7a179d50b60b4930c53f672c217befd = UNSTREAM_STRING( &constant_bin[ 203992 ], 97, 0 );
    const_tuple_str_plain_self_str_plain_TaskManagerPanel_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_TaskManagerPanel_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_TaskManagerPanel = UNSTREAM_STRING( &constant_bin[ 201206 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_TaskManagerPanel_tuple, 1, const_str_plain_TaskManagerPanel ); Py_INCREF( const_str_plain_TaskManagerPanel );
    const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple, 1, const_str_plain_num ); Py_INCREF( const_str_plain_num );
    const_str_plain_session = UNSTREAM_STRING( &constant_bin[ 175381 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple, 2, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple, 3, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    const_str_plain_ProfileSession = UNSTREAM_STRING( &constant_bin[ 203498 ], 14, 1 );
    const_str_plain__monitorDoLaterUponDeath = UNSTREAM_STRING( &constant_bin[ 204089 ], 24, 1 );
    const_str_plain__testDupNameDoLatersRemove = UNSTREAM_STRING( &constant_bin[ 204113 ], 26, 1 );
    const_str_plain_clearedTaskName = UNSTREAM_STRING( &constant_bin[ 204139 ], 15, 1 );
    const_str_plain_setFunc = UNSTREAM_STRING( &constant_bin[ 201274 ], 7, 1 );
    const_str_plain_getProfileFramesSV = UNSTREAM_STRING( &constant_bin[ 203578 ], 18, 1 );
    const_tuple_str_plain_numFrames_str_plain_self_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_numFrames_str_plain_self_tuple, 0, const_str_plain_numFrames ); Py_INCREF( const_str_plain_numFrames );
    PyTuple_SET_ITEM( const_tuple_str_plain_numFrames_str_plain_self_tuple, 1, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_AsyncTask = UNSTREAM_STRING( &constant_bin[ 202732 ], 9, 1 );
    const_str_plain_setRepeatCount = UNSTREAM_STRING( &constant_bin[ 204154 ], 14, 1 );
    const_str_plain__monitorDoLaterPri = UNSTREAM_STRING( &constant_bin[ 204168 ], 18, 1 );
    const_str_plain_checkLeak = UNSTREAM_STRING( &constant_bin[ 204186 ], 9, 1 );
    const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_ioError = UNSTREAM_STRING( &constant_bin[ 204195 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple, 1, const_str_plain_ioError ); Py_INCREF( const_str_plain_ioError );
    PyTuple_SET_ITEM( const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple, 2, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    PyTuple_SET_ITEM( const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple, 3, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    const_str_digest_8955d2e335f253b150c2e20333ed3782 = UNSTREAM_STRING( &constant_bin[ 204202 ], 431, 0 );
    const_str_plain_sequence = UNSTREAM_STRING( &constant_bin[ 117252 ], 8, 1 );
    const_str_digest_014f9be8fa5c5a865d39b0a74bef3a6e = UNSTREAM_STRING( &constant_bin[ 204633 ], 16, 0 );
    const_str_plain__testDone = UNSTREAM_STRING( &constant_bin[ 204649 ], 9, 1 );
    const_str_plain__profileTask = UNSTREAM_STRING( &constant_bin[ 203746 ], 12, 1 );
    const_str_digest_32e1b3aeccfbfbe3d7709c786a996e40 = UNSTREAM_STRING( &constant_bin[ 204658 ], 22, 0 );
    const_str_digest_148d47d5c98a982616178302cd36806d = UNSTREAM_STRING( &constant_bin[ 204680 ], 10, 0 );
    const_tuple_str_digest_98168731f04cfeb6639ad5bd1477be10_int_0_tuple = PyTuple_New( 2 );
    const_str_digest_98168731f04cfeb6639ad5bd1477be10 = UNSTREAM_STRING( &constant_bin[ 204690 ], 19, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_98168731f04cfeb6639ad5bd1477be10_int_0_tuple, 0, const_str_digest_98168731f04cfeb6639ad5bd1477be10 ); Py_INCREF( const_str_digest_98168731f04cfeb6639ad5bd1477be10 );
    PyTuple_SET_ITEM( const_tuple_str_digest_98168731f04cfeb6639ad5bd1477be10_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_AsyncTaskManager = UNSTREAM_STRING( &constant_bin[ 204709 ], 16, 1 );
    const_str_plain_getNextWakeTime = UNSTREAM_STRING( &constant_bin[ 204725 ], 15, 1 );
    const_str_plain__testDoLaterAppendTask = UNSTREAM_STRING( &constant_bin[ 204740 ], 22, 1 );
    const_str_plain_print_exc_plus = UNSTREAM_STRING( &constant_bin[ 204762 ], 14, 1 );
    const_tuple_str_plain_testDupNameDoLater_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testDupNameDoLater_tuple, 0, const_str_plain_testDupNameDoLater ); Py_INCREF( const_str_plain_testDupNameDoLater );
    const_str_plain_getDoLaters = UNSTREAM_STRING( &constant_bin[ 203219 ], 11, 1 );
    const_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d = UNSTREAM_STRING( &constant_bin[ 204776 ], 19, 0 );
    const_str_plain_monitorDoLaterAppendTask = UNSTREAM_STRING( &constant_bin[ 204795 ], 24, 1 );
    const_str_plain_testRemoveTasksMatching2a = UNSTREAM_STRING( &constant_bin[ 204819 ], 25, 1 );
    const_tuple_str_plain_testGetTasksNamed_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0, const_str_plain_testGetTasksNamed ); Py_INCREF( const_str_plain_testGetTasksNamed );
    const_str_plain_getTasks = UNSTREAM_STRING( &constant_bin[ 203151 ], 8, 1 );
    const_str_plain_testTaskObjRemove = UNSTREAM_STRING( &constant_bin[ 202032 ], 17, 1 );
    const_float_0_03333333333333333 = UNSTREAM_FLOAT( &constant_bin[ 204844 ] );
    const_tuple_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d_false_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d_false_tuple, 0, const_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d ); Py_INCREF( const_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d );
    PyTuple_SET_ITEM( const_tuple_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d_false_tuple, 1, Py_False ); Py_INCREF( Py_False );
    const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 1, const_str_plain_oldMethod ); Py_INCREF( const_str_plain_oldMethod );
    PyTuple_SET_ITEM( const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 2, const_str_plain_newFunction ); Py_INCREF( const_str_plain_newFunction );
    const_str_plain_numFound = UNSTREAM_STRING( &constant_bin[ 204852 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 3, const_str_plain_numFound ); Py_INCREF( const_str_plain_numFound );
    PyTuple_SET_ITEM( const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 4, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_str_plain_testRemoveByName = UNSTREAM_STRING( &constant_bin[ 204860 ], 16, 1 );
    const_str_plain_tickClock = UNSTREAM_STRING( &constant_bin[ 204876 ], 9, 1 );
    const_str_plain_TestClass = UNSTREAM_STRING( &constant_bin[ 204885 ], 9, 1 );
    const_str_plain__monitorDoLater = UNSTREAM_STRING( &constant_bin[ 204089 ], 15, 1 );
    const_str_plain__monitorDoLaterAppendTask = UNSTREAM_STRING( &constant_bin[ 204894 ], 25, 1 );
    const_str_plain_resetClock = UNSTREAM_STRING( &constant_bin[ 204919 ], 10, 1 );
    const_str_plain_testContDone = UNSTREAM_STRING( &constant_bin[ 204929 ], 12, 1 );
    const_list_38455ee7e920419e997654e9f66bb83b_list = PyList_New( 10 );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 0, const_str_plain_Task ); Py_INCREF( const_str_plain_Task );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 1, const_str_plain_TaskManager ); Py_INCREF( const_str_plain_TaskManager );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 2, const_str_plain_cont ); Py_INCREF( const_str_plain_cont );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 3, const_str_plain_done ); Py_INCREF( const_str_plain_done );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 4, const_str_plain_again ); Py_INCREF( const_str_plain_again );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 5, const_str_plain_pickup ); Py_INCREF( const_str_plain_pickup );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 6, const_str_plain_exit ); Py_INCREF( const_str_plain_exit );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 7, const_str_plain_sequence ); Py_INCREF( const_str_plain_sequence );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 8, const_str_plain_loop ); Py_INCREF( const_str_plain_loop );
    PyList_SET_ITEM( const_list_38455ee7e920419e997654e9f66bb83b_list, 9, const_str_plain_pause ); Py_INCREF( const_str_plain_pause );
    const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_profileInfo = UNSTREAM_STRING( &constant_bin[ 204941 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 1, const_str_plain_profileInfo ); Py_INCREF( const_str_plain_profileInfo );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 2, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 3, const_str_plain_appendTask ); Py_INCREF( const_str_plain_appendTask );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 4, const_str_plain_taskArgs ); Py_INCREF( const_str_plain_taskArgs );
    const_str_plain_PS = UNSTREAM_STRING( &constant_bin[ 41797 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 5, const_str_plain_PS ); Py_INCREF( const_str_plain_PS );
    const_str_plain_profileSession = UNSTREAM_STRING( &constant_bin[ 204952 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 6, const_str_plain_profileSession ); Py_INCREF( const_str_plain_profileSession );
    PyTuple_SET_ITEM( const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 7, const_str_plain_ret ); Py_INCREF( const_str_plain_ret );
    const_str_digest_40c78e90f83f2d64d9fd828f457bffb6 = UNSTREAM_STRING( &constant_bin[ 204966 ], 30, 0 );
    const_str_digest_36412136f6a38534526ee3bd8be027b3 = UNSTREAM_STRING( &constant_bin[ 204996 ], 25, 0 );
    const_str_plain__profileFrames = UNSTREAM_STRING( &constant_bin[ 205021 ], 14, 1 );
    const_str_digest_293919c35bfb52b109247dc353594438 = UNSTREAM_STRING( &constant_bin[ 205035 ], 155, 0 );
    const_str_plain_testDoLaterUponDeath = UNSTREAM_STRING( &constant_bin[ 205190 ], 20, 1 );
    const_str_plain_setProfileFrames = UNSTREAM_STRING( &constant_bin[ 203601 ], 16, 1 );
    const_str_plain__testDoLater1 = UNSTREAM_STRING( &constant_bin[ 205210 ], 13, 1 );
    const_str_plain_avgFrameRate = UNSTREAM_STRING( &constant_bin[ 205223 ], 12, 1 );
    const_str_plain__testExtraArgs = UNSTREAM_STRING( &constant_bin[ 205235 ], 14, 1 );
    const_str_digest_20b8e052796f453b6b98b57ee46dd337 = UNSTREAM_STRING( &constant_bin[ 205249 ], 76, 0 );
    const_str_plain__testDoLater2 = UNSTREAM_STRING( &constant_bin[ 205325 ], 13, 1 );
    const_str_plain_setThreadPriority = UNSTREAM_STRING( &constant_bin[ 205338 ], 17, 1 );
    const_str_plain_logTaskProfiles = UNSTREAM_STRING( &constant_bin[ 203684 ], 15, 1 );
    const_tuple_str_plain_self_str_plain_StateVar_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_StateVar_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_StateVar_tuple, 1, const_str_plain_StateVar ); Py_INCREF( const_str_plain_StateVar );
    const_tuple_str_plain_default_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_default_tuple, 0, const_str_plain_default ); Py_INCREF( const_str_plain_default );
    const_str_plain_monitorDoLaterUponDeath = UNSTREAM_STRING( &constant_bin[ 204090 ], 23, 1 );
    const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list = PyList_New( 4 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list, 0, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list, 1, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list, 2, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list, 3, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    const_str_plain_findTaskChain = UNSTREAM_STRING( &constant_bin[ 205355 ], 13, 1 );
    const_str_plain_MaxEpochSpeed = UNSTREAM_STRING( &constant_bin[ 202945 ], 13, 1 );
    const_str_plain_FP = UNSTREAM_STRING( &constant_bin[ 205368 ], 2, 1 );
    const_str_plain_signalNumber = UNSTREAM_STRING( &constant_bin[ 205370 ], 12, 1 );
    const_tuple_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf_tuple = PyTuple_New( 1 );
    const_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf = UNSTREAM_STRING( &constant_bin[ 205382 ], 24, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf_tuple, 0, const_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf ); Py_INCREF( const_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf );
    const_dict_20bf4839fda8a49cec676ef6853196ef = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_20bf4839fda8a49cec676ef6853196ef, const_str_plain_sort, const_int_pos_1 );
    assert( PyDict_Size( const_dict_20bf4839fda8a49cec676ef6853196ef ) == 1 );
    const_str_plain_default_int_handler = UNSTREAM_STRING( &constant_bin[ 205406 ], 19, 1 );
    const_str_plain_taskMgrFrameProfile = UNSTREAM_STRING( &constant_bin[ 205425 ], 19, 1 );
    const_str_plain_testTaskObj = UNSTREAM_STRING( &constant_bin[ 201238 ], 11, 1 );
    const_str_plain_setClock = UNSTREAM_STRING( &constant_bin[ 203002 ], 8, 1 );
    const_str_plain___tryReplaceTaskMethod = UNSTREAM_STRING( &constant_bin[ 201168 ], 22, 1 );
    const_str_plain_testDone = UNSTREAM_STRING( &constant_bin[ 204650 ], 8, 1 );
    const_dict_2c309b6a9a07f2a3a999dce9e263b6ff = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff, const_str_plain_sort, const_int_pos_10 );
    assert( PyDict_Size( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff ) == 1 );
    const_str_plain_testDoLaterExtraArgs = UNSTREAM_STRING( &constant_bin[ 205444 ], 20, 1 );
    const_dict_393ba663cb39d8e5662104836ff43bdd = _PyDict_NewPresized( 2 );
    PyDict_SetItem( const_dict_393ba663cb39d8e5662104836ff43bdd, const_str_plain_extraArgs, const_list_int_pos_4_int_pos_5_list );
    PyDict_SetItem( const_dict_393ba663cb39d8e5662104836ff43bdd, const_str_plain_appendTask, Py_True );
    assert( PyDict_Size( const_dict_393ba663cb39d8e5662104836ff43bdd ) == 2 );
    const_str_digest_339421c46c1eca739ff0b1eb64748494 = UNSTREAM_STRING( &constant_bin[ 205464 ], 2587, 0 );
    const_str_plain_SIGINT = UNSTREAM_STRING( &constant_bin[ 208051 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_taskName_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskName_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskName_tuple, 1, const_str_plain_taskName ); Py_INCREF( const_str_plain_taskName );
    const_dict_752c9f51c629c62cd37d9eb2a6272323 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_752c9f51c629c62cd37d9eb2a6272323, const_str_plain_extraArgs, const_list_int_pos_3_list );
    assert( PyDict_Size( const_dict_752c9f51c629c62cd37d9eb2a6272323 ) == 1 );
    const_tuple_str_plain_testRemoveTasksMatching1_tuple = PyTuple_New( 1 );
    const_str_plain_testRemoveTasksMatching1 = UNSTREAM_STRING( &constant_bin[ 202074 ], 24, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1_tuple, 0, const_str_plain_testRemoveTasksMatching1 ); Py_INCREF( const_str_plain_testRemoveTasksMatching1 );
    const_str_plain__unpackIOError = UNSTREAM_STRING( &constant_bin[ 203392 ], 14, 1 );
    const_str_plain_getClock = UNSTREAM_STRING( &constant_bin[ 208057 ], 8, 1 );
    const_str_plain__checkMemLeaks = UNSTREAM_STRING( &constant_bin[ 203922 ], 14, 1 );
    const_tuple_str_digest_c3ccb889bb2a33c149f483685be0800b_tuple = PyTuple_New( 1 );
    const_str_digest_c3ccb889bb2a33c149f483685be0800b = UNSTREAM_STRING( &constant_bin[ 208065 ], 24, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_c3ccb889bb2a33c149f483685be0800b_tuple, 0, const_str_digest_c3ccb889bb2a33c149f483685be0800b ); Py_INCREF( const_str_digest_c3ccb889bb2a33c149f483685be0800b );
    const_str_plain_avgFrameDur = UNSTREAM_STRING( &constant_bin[ 208089 ], 11, 1 );
    const_str_plain__testUponDeathFunc = UNSTREAM_STRING( &constant_bin[ 208100 ], 18, 1 );
    const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_taskPattern = UNSTREAM_STRING( &constant_bin[ 208118 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple, 1, const_str_plain_taskPattern ); Py_INCREF( const_str_plain_taskPattern );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple, 2, const_str_plain_tasks ); Py_INCREF( const_str_plain_tasks );
    const_str_plain__testGetTasks = UNSTREAM_STRING( &constant_bin[ 203974 ], 13, 1 );
    const_str_plain__startTrackingMemLeaks = UNSTREAM_STRING( &constant_bin[ 203869 ], 22, 1 );
    const_str_plain__testOwner = UNSTREAM_STRING( &constant_bin[ 208129 ], 10, 1 );
    const_str_plain_taskId = UNSTREAM_STRING( &constant_bin[ 208139 ], 6, 1 );
    const_str_plain_frameBudget = UNSTREAM_STRING( &constant_bin[ 206864 ], 11, 1 );
    const_tuple_str_plain_loop_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_loop_tuple, 0, const_str_plain_loop ); Py_INCREF( const_str_plain_loop );
    const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_profileFrames = UNSTREAM_STRING( &constant_bin[ 203517 ], 13, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple, 1, const_str_plain_profileFrames ); Py_INCREF( const_str_plain_profileFrames );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple, 2, const_str_plain_FP ); Py_INCREF( const_str_plain_FP );
    const_str_digest_4b971f3632718df8bdf7fc2cb7d90521 = UNSTREAM_STRING( &constant_bin[ 208145 ], 54, 0 );
    const_str_plain_profileTasks = UNSTREAM_STRING( &constant_bin[ 208199 ], 12, 1 );
    const_tuple_str_plain_sequence_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_sequence_tuple, 0, const_str_plain_sequence ); Py_INCREF( const_str_plain_sequence );
    const_str_plain_timeslicePriority = UNSTREAM_STRING( &constant_bin[ 207646 ], 17, 1 );
    const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple, 1, const_str_plain_taskOrName ); Py_INCREF( const_str_plain_taskOrName );
    PyTuple_SET_ITEM( const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple, 2, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple, 3, const_str_plain_tasks ); Py_INCREF( const_str_plain_tasks );
    const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple, 1, const_str_plain_profileTasks ); Py_INCREF( const_str_plain_profileTasks );
    const_str_plain_TP = UNSTREAM_STRING( &constant_bin[ 44283 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple, 2, const_str_plain_TP ); Py_INCREF( const_str_plain_TP );
    const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 1, const_str_plain_now ); Py_INCREF( const_str_plain_now );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 2, const_str_plain_avgFrameRate ); Py_INCREF( const_str_plain_avgFrameRate );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 3, const_str_plain_avgFrameDur ); Py_INCREF( const_str_plain_avgFrameDur );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 4, const_str_plain_next ); Py_INCREF( const_str_plain_next );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 5, const_str_plain_tasks ); Py_INCREF( const_str_plain_tasks );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 6, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 7, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_str_plain_extendedExceptions = UNSTREAM_STRING( &constant_bin[ 202906 ], 18, 1 );
    const_tuple_str_plain_testDoLater1_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testDoLater1_tuple, 0, const_str_plain_testDoLater1 ); Py_INCREF( const_str_plain_testDoLater1 );
    const_str_plain__testRemoveByName = UNSTREAM_STRING( &constant_bin[ 208211 ], 17, 1 );
    const_str_plain_seq = UNSTREAM_STRING( &constant_bin[ 25090 ], 3, 1 );
    const_str_plain_taskList = UNSTREAM_STRING( &constant_bin[ 109997 ], 8, 1 );
    const_str_digest_feb617e995cb09fff64cd1ad38571b3f = UNSTREAM_STRING( &constant_bin[ 208228 ], 50, 0 );
    const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple, 1, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain__taskProfiler = UNSTREAM_STRING( &constant_bin[ 208278 ], 13, 1 );
    const_str_plain_FrameProfiler = UNSTREAM_STRING( &constant_bin[ 205008 ], 13, 1 );
    const_str_plain___makeTaskList = UNSTREAM_STRING( &constant_bin[ 202154 ], 14, 1 );
    const_str_plain__testGetDoLaters = UNSTREAM_STRING( &constant_bin[ 208291 ], 16, 1 );
    const_tuple_str_plain_testTaskObj_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testTaskObj_tuple, 0, const_str_plain_testTaskObj ); Py_INCREF( const_str_plain_testTaskObj );
    const_str_plain_monitorDoLater = UNSTREAM_STRING( &constant_bin[ 201124 ], 14, 1 );
    const_tuple_a0a3a13514ffb5caba494780f2ce74c2_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 208307 ], 901 );
    const_str_plain__testDoLaterPri2 = UNSTREAM_STRING( &constant_bin[ 208688 ], 16, 1 );
    const_tuple_str_digest_f9fc41598bc46920591fd091b028aaf0_false_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f9fc41598bc46920591fd091b028aaf0_false_tuple, 0, const_str_digest_f9fc41598bc46920591fd091b028aaf0 ); Py_INCREF( const_str_digest_f9fc41598bc46920591fd091b028aaf0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_f9fc41598bc46920591fd091b028aaf0_false_tuple, 1, Py_False ); Py_INCREF( Py_False );
    const_dict_11985c3a65ec78b97ae15d2d308b1395 = _PyDict_NewPresized( 3 );
    PyDict_SetItem( const_dict_11985c3a65ec78b97ae15d2d308b1395, const_str_plain_profiled, Py_False );
    PyDict_SetItem( const_dict_11985c3a65ec78b97ae15d2d308b1395, const_str_plain_session, Py_None );
    PyDict_SetItem( const_dict_11985c3a65ec78b97ae15d2d308b1395, const_str_plain_taskId, Py_None );
    assert( PyDict_Size( const_dict_11985c3a65ec78b97ae15d2d308b1395 ) == 3 );
    const_str_plain_DSDone = UNSTREAM_STRING( &constant_bin[ 209208 ], 6, 1 );
    const_tuple_str_plain_testCont_tuple = PyTuple_New( 1 );
    const_str_plain_testCont = UNSTREAM_STRING( &constant_bin[ 204929 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testCont_tuple, 0, const_str_plain_testCont ); Py_INCREF( const_str_plain_testCont );
    const_str_plain_fKeyboardInterrupt = UNSTREAM_STRING( &constant_bin[ 209214 ], 18, 1 );
    const_str_plain_setupTaskChain = UNSTREAM_STRING( &constant_bin[ 203115 ], 14, 1 );
    const_str_plain_setProfileTasks = UNSTREAM_STRING( &constant_bin[ 203664 ], 15, 1 );
    const_str_plain_chain = UNSTREAM_STRING( &constant_bin[ 138919 ], 5, 1 );
    const_tuple_str_digest_36412136f6a38534526ee3bd8be027b3_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_36412136f6a38534526ee3bd8be027b3_tuple, 0, const_str_digest_36412136f6a38534526ee3bd8be027b3 ); Py_INCREF( const_str_digest_36412136f6a38534526ee3bd8be027b3 );
    const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 0, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 1, const_str_plain_tm ); Py_INCREF( const_str_plain_tm );
    PyTuple_SET_ITEM( const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    PyTuple_SET_ITEM( const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 3, const_str_plain_doLaterOwner ); Py_INCREF( const_str_plain_doLaterOwner );
    PyTuple_SET_ITEM( const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 4, const_str_plain_doLaterTests ); Py_INCREF( const_str_plain_doLaterTests );
    const_str_plain_hasName = UNSTREAM_STRING( &constant_bin[ 209232 ], 7, 1 );
    const_str_plain_testRemoveTasksMatching2 = UNSTREAM_STRING( &constant_bin[ 204819 ], 24, 1 );
    const_tuple_str_plain_testRemoveTasksMatching2a_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2a_tuple, 0, const_str_plain_testRemoveTasksMatching2a ); Py_INCREF( const_str_plain_testRemoveTasksMatching2a );
    const_str_digest_dc372ef8fb63a2f7ba56dd37d0d490c8 = UNSTREAM_STRING( &constant_bin[ 209239 ], 82, 0 );
    const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple, 1, const_str_plain_arg2 ); Py_INCREF( const_str_plain_arg2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple, 2, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple, 3, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain__uponDeathFunc = UNSTREAM_STRING( &constant_bin[ 208519 ], 14, 1 );
    const_str_plain_uponDeath = UNSTREAM_STRING( &constant_bin[ 208520 ], 9, 1 );
    const_str_plain_testDupNameDoLaterRemove = UNSTREAM_STRING( &constant_bin[ 209321 ], 24, 1 );
    const_str_plain_getTasksMatching = UNSTREAM_STRING( &constant_bin[ 203169 ], 16, 1 );
    const_str_plain_testUponDeath = UNSTREAM_STRING( &constant_bin[ 208101 ], 13, 1 );
    const_str_plain_testDoLaterOwner = UNSTREAM_STRING( &constant_bin[ 202747 ], 16, 1 );
    const_tuple_str_plain_testRemoveByName_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveByName_tuple, 0, const_str_plain_testRemoveByName ); Py_INCREF( const_str_plain_testRemoveByName );
    const_str_plain_numThreads = UNSTREAM_STRING( &constant_bin[ 205600 ], 10, 1 );
    const_str_digest_366c6ab541682202d2ba4e1cfb8a21d8 = UNSTREAM_STRING( &constant_bin[ 209345 ], 53, 0 );
    const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5 = UNSTREAM_STRING( &constant_bin[ 209398 ], 24, 0 );
    const_str_digest_e223ebbecbbe1fc3d462b76aa6de6906 = UNSTREAM_STRING( &constant_bin[ 209422 ], 239, 0 );
    const_str_digest_b3e9cae2fecef7b6d609daf4a6baba31 = UNSTREAM_STRING( &constant_bin[ 209661 ], 23, 0 );
    const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple, 1, const_str_plain_arg2 ); Py_INCREF( const_str_plain_arg2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple, 2, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain__TaskOwner = UNSTREAM_STRING( &constant_bin[ 208557 ], 10, 1 );
    const_str_digest_14e7a80f5f7f1182fca3d8566b83d9d3 = UNSTREAM_STRING( &constant_bin[ 209684 ], 28, 0 );
    const_str_plain_randrange = UNSTREAM_STRING( &constant_bin[ 209712 ], 9, 1 );
    const_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77 = UNSTREAM_STRING( &constant_bin[ 209721 ], 25, 0 );
    const_dict_e43c4b6e448be1e6a26efea5089b8672 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_e43c4b6e448be1e6a26efea5089b8672, const_str_plain_tickClock, Py_True );
    assert( PyDict_Size( const_dict_e43c4b6e448be1e6a26efea5089b8672 ) == 1 );
    const_str_plain__testDoLaterExtraArgs = UNSTREAM_STRING( &constant_bin[ 208732 ], 21, 1 );
    const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple, 2, const_str_plain_PS ); Py_INCREF( const_str_plain_PS );
    const_str_plain_flushTaskProfiles = UNSTREAM_STRING( &constant_bin[ 203704 ], 17, 1 );
    const_str_digest_fdd30d29d49df04a06d4a80ef85c53fc = UNSTREAM_STRING( &constant_bin[ 209746 ], 116, 0 );
    const_str_plain__profileTasks = UNSTREAM_STRING( &constant_bin[ 209862 ], 13, 1 );
    const_str_plain_getRefCount = UNSTREAM_STRING( &constant_bin[ 204663 ], 11, 1 );
    const_str_digest_20c100e7e679deb5eb4415251fd9db0b = UNSTREAM_STRING( &constant_bin[ 209875 ], 15, 0 );
    const_str_plain_TaskProfiler = UNSTREAM_STRING( &constant_bin[ 208077 ], 12, 1 );
    const_list_str_plain_testUponDeath_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_str_plain_testUponDeath_list, 0, const_str_plain_testUponDeath ); Py_INCREF( const_str_plain_testUponDeath );
    const_str_digest_79748cc9eb11364c994f6b8db15b4c23 = UNSTREAM_STRING( &constant_bin[ 209890 ], 42, 0 );
    const_str_plain_setFrameSync = UNSTREAM_STRING( &constant_bin[ 209932 ], 12, 1 );
    const_tuple_str_plain_testDoLater3_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testDoLater3_tuple, 0, const_str_plain_testDoLater3 ); Py_INCREF( const_str_plain_testDoLater3 );
    const_str_digest_7e047f0e10d78432228c9d9cbabb1012 = UNSTREAM_STRING( &constant_bin[ 209944 ], 123, 0 );
    const_tuple_str_plain_arg1_str_plain_l_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_l_tuple, 0, const_str_plain_arg1 ); Py_INCREF( const_str_plain_arg1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_arg1_str_plain_l_tuple, 1, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain_timeDelta = UNSTREAM_STRING( &constant_bin[ 210067 ], 9, 1 );
    const_str_plain_makeTaskChain = UNSTREAM_STRING( &constant_bin[ 210076 ], 13, 1 );
    const_str_digest_d4e4e0734a21d5b1e4b98d82d29d0f71 = UNSTREAM_STRING( &constant_bin[ 210089 ], 19, 0 );
    const_str_digest_162533328c73194d8dad01ad17ef1ee5 = UNSTREAM_STRING( &constant_bin[ 210108 ], 123, 0 );
    const_str_digest_053c33621531947f586017f14d07df3d = UNSTREAM_STRING( &constant_bin[ 210231 ], 53, 0 );
    const_str_plain__TaskManager__setupTask = UNSTREAM_STRING( &constant_bin[ 203312 ], 23, 1 );
    const_str_plain_taskFunc = UNSTREAM_STRING( &constant_bin[ 210284 ], 8, 1 );
    const_str_plain__testDoLaterUponDeath = UNSTREAM_STRING( &constant_bin[ 208867 ], 21, 1 );
    const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 1, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 2, const_str_plain_oldMethod ); Py_INCREF( const_str_plain_oldMethod );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 3, const_str_plain_newFunction ); Py_INCREF( const_str_plain_newFunction );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 4, const_str_plain_method ); Py_INCREF( const_str_plain_method );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 5, const_str_plain_function ); Py_INCREF( const_str_plain_function );
    PyTuple_SET_ITEM( const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 6, const_str_plain_newMethod ); Py_INCREF( const_str_plain_newMethod );
    const_str_plain_removeTasksMatching = UNSTREAM_STRING( &constant_bin[ 203351 ], 19, 1 );
    const_tuple_str_plain_task_str_plain_l_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_task_str_plain_l_tuple, 0, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    PyTuple_SET_ITEM( const_tuple_str_plain_task_str_plain_l_tuple, 1, const_str_plain_l ); Py_INCREF( const_str_plain_l );
    const_str_plain_getActiveTasks = UNSTREAM_STRING( &constant_bin[ 210292 ], 14, 1 );
    const_str_digest_6f6b30f043208ddc0fd34ee37c3374a2 = UNSTREAM_STRING( &constant_bin[ 210306 ], 10, 0 );
    const_str_plain_getSleepingTasks = UNSTREAM_STRING( &constant_bin[ 210316 ], 16, 1 );
    const_str_plain_getProfileTasks = UNSTREAM_STRING( &constant_bin[ 203622 ], 15, 1 );
    const_str_plain__hasProfiledDesignatedTask = UNSTREAM_STRING( &constant_bin[ 203763 ], 26, 1 );
    const_tuple_str_plain_testPri1_tuple = PyTuple_New( 1 );
    const_str_plain_testPri1 = UNSTREAM_STRING( &constant_bin[ 202829 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testPri1_tuple, 0, const_str_plain_testPri1 ); Py_INCREF( const_str_plain_testPri1 );
    const_tuple_str_plain_testRemoveTasksMatching1a_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1a_tuple, 0, const_str_plain_testRemoveTasksMatching1a ); Py_INCREF( const_str_plain_testRemoveTasksMatching1a );
    const_str_plain__testCont = UNSTREAM_STRING( &constant_bin[ 208398 ], 9, 1 );
    const_str_plain__frameProfiler = UNSTREAM_STRING( &constant_bin[ 210332 ], 14, 1 );
    const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 1, const_str_plain_chainName ); Py_INCREF( const_str_plain_chainName );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 2, const_str_plain_numThreads ); Py_INCREF( const_str_plain_numThreads );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 3, const_str_plain_tickClock ); Py_INCREF( const_str_plain_tickClock );
    const_str_plain_threadPriority = UNSTREAM_STRING( &constant_bin[ 206593 ], 14, 1 );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 4, const_str_plain_threadPriority ); Py_INCREF( const_str_plain_threadPriority );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 5, const_str_plain_frameBudget ); Py_INCREF( const_str_plain_frameBudget );
    const_str_plain_frameSync = UNSTREAM_STRING( &constant_bin[ 207087 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 6, const_str_plain_frameSync ); Py_INCREF( const_str_plain_frameSync );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 7, const_str_plain_timeslicePriority ); Py_INCREF( const_str_plain_timeslicePriority );
    PyTuple_SET_ITEM( const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 8, const_str_plain_chain ); Py_INCREF( const_str_plain_chain );
    const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_funcOrTask = UNSTREAM_STRING( &constant_bin[ 210346 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 1, const_str_plain_funcOrTask ); Py_INCREF( const_str_plain_funcOrTask );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 3, const_str_plain_priority ); Py_INCREF( const_str_plain_priority );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 4, const_str_plain_sort ); Py_INCREF( const_str_plain_sort );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 5, const_str_plain_extraArgs ); Py_INCREF( const_str_plain_extraArgs );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 6, const_str_plain_taskChain ); Py_INCREF( const_str_plain_taskChain );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 7, const_str_plain_appendTask ); Py_INCREF( const_str_plain_appendTask );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 8, const_str_plain_owner ); Py_INCREF( const_str_plain_owner );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 9, const_str_plain_uponDeath ); Py_INCREF( const_str_plain_uponDeath );
    PyTuple_SET_ITEM( const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 10, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_str_plain__testDupNamedTasks = UNSTREAM_STRING( &constant_bin[ 208375 ], 18, 1 );
    const_str_digest_86a25986da173b225b30ee3209499f63 = UNSTREAM_STRING( &constant_bin[ 210356 ], 7, 0 );
    const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple, 0, const_str_plain_taskList ); Py_INCREF( const_str_plain_taskList );
    PyTuple_SET_ITEM( const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple, 1, const_str_plain_seq ); Py_INCREF( const_str_plain_seq );
    PyTuple_SET_ITEM( const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple, 2, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_tuple_bc208da109e99712fefec75b5337e250_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 0, const_str_plain_sys ); Py_INCREF( const_str_plain_sys );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 1, const_str_plain_traceback ); Py_INCREF( const_str_plain_traceback );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 2, const_str_plain_tb ); Py_INCREF( const_str_plain_tb );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 3, const_str_plain_stack ); Py_INCREF( const_str_plain_stack );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 4, const_str_plain_f ); Py_INCREF( const_str_plain_f );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 5, const_str_plain_frame ); Py_INCREF( const_str_plain_frame );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 6, const_str_plain_key ); Py_INCREF( const_str_plain_key );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 7, const_str_plain_value ); Py_INCREF( const_str_plain_value );
    PyTuple_SET_ITEM( const_tuple_bc208da109e99712fefec75b5337e250_tuple, 8, const_str_plain_valueStr ); Py_INCREF( const_str_plain_valueStr );
    const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple, 1, const_str_plain_signalNumber ); Py_INCREF( const_str_plain_signalNumber );
    const_str_plain_stackFrame = UNSTREAM_STRING( &constant_bin[ 210363 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple, 2, const_str_plain_stackFrame ); Py_INCREF( const_str_plain_stackFrame );
    const_tuple_a7664b39550c747f55be06e641fb33ad_tuple = PyTuple_New( 12 );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 1, const_str_plain_delayTime ); Py_INCREF( const_str_plain_delayTime );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 2, const_str_plain_funcOrTask ); Py_INCREF( const_str_plain_funcOrTask );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 3, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 4, const_str_plain_extraArgs ); Py_INCREF( const_str_plain_extraArgs );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 5, const_str_plain_sort ); Py_INCREF( const_str_plain_sort );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 6, const_str_plain_priority ); Py_INCREF( const_str_plain_priority );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 7, const_str_plain_taskChain ); Py_INCREF( const_str_plain_taskChain );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 8, const_str_plain_uponDeath ); Py_INCREF( const_str_plain_uponDeath );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 9, const_str_plain_appendTask ); Py_INCREF( const_str_plain_appendTask );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 10, const_str_plain_owner ); Py_INCREF( const_str_plain_owner );
    PyTuple_SET_ITEM( const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 11, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_list_int_pos_1_int_pos_2_list = PyList_New( 2 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_list, 0, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyList_SET_ITEM( const_list_int_pos_1_int_pos_2_list, 1, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 1, const_str_plain_funcOrTask ); Py_INCREF( const_str_plain_funcOrTask );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 3, const_str_plain_sort ); Py_INCREF( const_str_plain_sort );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 4, const_str_plain_extraArgs ); Py_INCREF( const_str_plain_extraArgs );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 5, const_str_plain_priority ); Py_INCREF( const_str_plain_priority );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 6, const_str_plain_uponDeath ); Py_INCREF( const_str_plain_uponDeath );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 7, const_str_plain_appendTask ); Py_INCREF( const_str_plain_appendTask );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 8, const_str_plain_taskChain ); Py_INCREF( const_str_plain_taskChain );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 9, const_str_plain_owner ); Py_INCREF( const_str_plain_owner );
    PyTuple_SET_ITEM( const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 10, const_str_plain_task ); Py_INCREF( const_str_plain_task );
    const_str_plain_findTasks = UNSTREAM_STRING( &constant_bin[ 202628 ], 9, 1 );
    const_tuple_str_digest_22dff21c3b984696a3f596fd6541e8e0_false_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_digest_22dff21c3b984696a3f596fd6541e8e0_false_tuple, 0, const_str_digest_22dff21c3b984696a3f596fd6541e8e0 ); Py_INCREF( const_str_digest_22dff21c3b984696a3f596fd6541e8e0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_22dff21c3b984696a3f596fd6541e8e0_false_tuple, 1, Py_False ); Py_INCREF( Py_False );
    const_tuple_str_digest_40c78e90f83f2d64d9fd828f457bffb6_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_40c78e90f83f2d64d9fd828f457bffb6_tuple, 0, const_str_digest_40c78e90f83f2d64d9fd828f457bffb6 ); Py_INCREF( const_str_digest_40c78e90f83f2d64d9fd828f457bffb6 );
    const_str_digest_c6e478a3e2e77af3f673a67ea513491a = UNSTREAM_STRING( &constant_bin[ 210373 ], 2284, 0 );
    const_str_plain_interruptCount = UNSTREAM_STRING( &constant_bin[ 212657 ], 14, 1 );
    const_str_plain_testDupNamedTasks = UNSTREAM_STRING( &constant_bin[ 208376 ], 17, 1 );
    const_tuple_str_digest_4b971f3632718df8bdf7fc2cb7d90521_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_4b971f3632718df8bdf7fc2cb7d90521_tuple, 0, const_str_digest_4b971f3632718df8bdf7fc2cb7d90521 ); Py_INCREF( const_str_digest_4b971f3632718df8bdf7fc2cb7d90521 );
    const_str_plain_setOwner = UNSTREAM_STRING( &constant_bin[ 212671 ], 8, 1 );
    const_str_plain__profileFunc = UNSTREAM_STRING( &constant_bin[ 212679 ], 12, 1 );
    const_str_plain_findTask = UNSTREAM_STRING( &constant_bin[ 202628 ], 8, 1 );
    const_str_plain__testAppendTask = UNSTREAM_STRING( &constant_bin[ 208499 ], 15, 1 );
    const_str_digest_70e66c98789b7a7a51a96af6654254e5 = UNSTREAM_STRING( &constant_bin[ 212691 ], 21, 0 );
    const_str_plain_signal = UNSTREAM_STRING( &constant_bin[ 199904 ], 6, 1 );
    const_str_plain_logProfiles = UNSTREAM_STRING( &constant_bin[ 212712 ], 11, 1 );
    const_str_digest_f52007705b73a852251f306ade6b0b32 = UNSTREAM_STRING( &constant_bin[ 212723 ], 25, 0 );
    const_str_plain__runTests = UNSTREAM_STRING( &constant_bin[ 203941 ], 9, 1 );
    const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 0, const_str_plain_sys ); Py_INCREF( const_str_plain_sys );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 1, const_str_plain_gc ); Py_INCREF( const_str_plain_gc );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 2, const_str_plain_DirectObject ); Py_INCREF( const_str_plain_DirectObject );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 3, const_str_plain_TestClass ); Py_INCREF( const_str_plain_TestClass );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 4, const_str_plain_obj ); Py_INCREF( const_str_plain_obj );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 5, const_str_plain_startRefCount ); Py_INCREF( const_str_plain_startRefCount );
    PyTuple_SET_ITEM( const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 6, const_str_plain_t ); Py_INCREF( const_str_plain_t );
    const_str_plain_setTickClock = UNSTREAM_STRING( &constant_bin[ 212748 ], 12, 1 );
    const_str_plain_getArgs = UNSTREAM_STRING( &constant_bin[ 78291 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_taskPattern_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskPattern_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_taskPattern_tuple, 1, const_str_plain_taskPattern ); Py_INCREF( const_str_plain_taskPattern );
    const_str_plain_stepping = UNSTREAM_STRING( &constant_bin[ 212760 ], 8, 1 );
    const_str_plain_getProfileSession = UNSTREAM_STRING( &constant_bin[ 203495 ], 17, 1 );
    const_dict_1b3ca16c1519c7adb9906eff10d088a1 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_1b3ca16c1519c7adb9906eff10d088a1, const_str_plain_sort, const_int_pos_2 );
    assert( PyDict_Size( const_dict_1b3ca16c1519c7adb9906eff10d088a1 ) == 1 );
    const_str_plain__monitorDoLaterOwner = UNSTREAM_STRING( &constant_bin[ 208979 ], 20, 1 );
    const_tuple_str_plain_testGetTasks2_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testGetTasks2_tuple, 0, const_str_plain_testGetTasks2 ); Py_INCREF( const_str_plain_testGetTasks2 );
    const_str_plain_DSCont = UNSTREAM_STRING( &constant_bin[ 212768 ], 6, 1 );
    const_tuple_none_none_none_none_none_false_none_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 5, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_tuple, 6, Py_None ); Py_INCREF( Py_None );
    const_str_plain_destroyed = UNSTREAM_STRING( &constant_bin[ 109813 ], 9, 1 );
    const_str_plain__taskProfileInfo = UNSTREAM_STRING( &constant_bin[ 212774 ], 16, 1 );
    const_str_digest_d533b57f698317f04ca0c379c0ad0a9a = UNSTREAM_STRING( &constant_bin[ 212790 ], 31, 0 );
    const_str_plain__testHasTaskNamed = UNSTREAM_STRING( &constant_bin[ 208430 ], 17, 1 );
    const_list_int_pos_10_list = PyList_New( 1 );
    PyList_SET_ITEM( const_list_int_pos_10_list, 0, const_int_pos_10 ); Py_INCREF( const_int_pos_10 );
    const_tuple_none_none_none_none_none_none_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_none_tuple, 5, Py_None ); Py_INCREF( Py_None );
    const_str_plain_AsyncTaskSequence = UNSTREAM_STRING( &constant_bin[ 212821 ], 17, 1 );
    const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple = PyTuple_New( 11 );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 1, const_str_plain_t ); Py_INCREF( const_str_plain_t );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 2, const_str_plain_timeDelta ); Py_INCREF( const_str_plain_timeDelta );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 3, const_str_plain_numFrames ); Py_INCREF( const_str_plain_numFrames );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 4, const_str_plain_session ); Py_INCREF( const_str_plain_session );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 5, const_str_plain_callback ); Py_INCREF( const_str_plain_callback );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 6, const_str_plain__profileFunc ); Py_INCREF( const_str_plain__profileFunc );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 7, const_str_plain_ioError ); Py_INCREF( const_str_plain_ioError );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 8, const_str_plain_code ); Py_INCREF( const_str_plain_code );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 9, const_str_plain_message ); Py_INCREF( const_str_plain_message );
    PyTuple_SET_ITEM( const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 10, const_str_plain_e ); Py_INCREF( const_str_plain_e );
    const_str_plain_monitorDoLaterOwner = UNSTREAM_STRING( &constant_bin[ 208980 ], 19, 1 );
    const_str_plain_testOwner = UNSTREAM_STRING( &constant_bin[ 208130 ], 9, 1 );
    const_str_plain_getWakeTime = UNSTREAM_STRING( &constant_bin[ 212838 ], 11, 1 );
    const_tuple_5f3efb215a8d38403650998c55156313_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_5f3efb215a8d38403650998c55156313_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_5f3efb215a8d38403650998c55156313_tuple, 1, const_str_plain_numFrames ); Py_INCREF( const_str_plain_numFrames );
    PyTuple_SET_ITEM( const_tuple_5f3efb215a8d38403650998c55156313_tuple, 2, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_5f3efb215a8d38403650998c55156313_tuple, 3, const_str_plain_result ); Py_INCREF( const_str_plain_result );
    const_tuple_str_plain_test_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_test_tuple, 0, const_str_plain_test ); Py_INCREF( const_str_plain_test );
    const_str_plain_getPlatform = UNSTREAM_STRING( &constant_bin[ 212849 ], 11, 1 );
    const_str_digest_17d25158b9df61b35e5a5db332529ea5 = UNSTREAM_STRING( &constant_bin[ 212860 ], 175, 0 );
    const_str_plain_invokeDefaultHandler = UNSTREAM_STRING( &constant_bin[ 203025 ], 20, 1 );
    const_str_plain_setNumThreads = UNSTREAM_STRING( &constant_bin[ 213035 ], 13, 1 );
    const_tuple_str_digest_70e66c98789b7a7a51a96af6654254e5_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_70e66c98789b7a7a51a96af6654254e5_tuple, 0, const_str_digest_70e66c98789b7a7a51a96af6654254e5 ); Py_INCREF( const_str_digest_70e66c98789b7a7a51a96af6654254e5 );
    const_str_plain_DSExit = UNSTREAM_STRING( &constant_bin[ 213048 ], 6, 1 );
    const_str_plain_emscripten = UNSTREAM_STRING( &constant_bin[ 213054 ], 10, 1 );
    const_str_digest_835923a846bcd1d3fbfc6194aef55753 = UNSTREAM_STRING( &constant_bin[ 213064 ], 339, 0 );
    const_tuple_str_plain_testDoLater2_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testDoLater2_tuple, 0, const_str_plain_testDoLater2 ); Py_INCREF( const_str_plain_testDoLater2 );
    const_str_plain__frameProfileQueue = UNSTREAM_STRING( &constant_bin[ 213403 ], 18, 1 );
    const_str_plain_testDoLaterPri1 = UNSTREAM_STRING( &constant_bin[ 202250 ], 15, 1 );
    const_str_plain_getAverageFrameRate = UNSTREAM_STRING( &constant_bin[ 213421 ], 19, 1 );
    const_str_plain_setTimeslicePriority = UNSTREAM_STRING( &constant_bin[ 208010 ], 20, 1 );
    const_tuple_str_plain_testRemoveTasksMatching2_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2_tuple, 0, const_str_plain_testRemoveTasksMatching2 ); Py_INCREF( const_str_plain_testRemoveTasksMatching2 );
    const_tuple_str_plain_testContDone_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_testContDone_tuple, 0, const_str_plain_testContDone ); Py_INCREF( const_str_plain_testContDone );
    const_str_plain__monitorDoLaterExtraArgs = UNSTREAM_STRING( &constant_bin[ 208758 ], 24, 1 );
    const_str_plain_testDoLaterAppendTask = UNSTREAM_STRING( &constant_bin[ 204741 ], 21, 1 );
    const_str_plain_setTaskChain = UNSTREAM_STRING( &constant_bin[ 205798 ], 12, 1 );
    const_str_plain_getProfileTasksSV = UNSTREAM_STRING( &constant_bin[ 203642 ], 17, 1 );
    const_str_plain__setProfileTask = UNSTREAM_STRING( &constant_bin[ 203726 ], 15, 1 );
    const_str_plain__testContDone = UNSTREAM_STRING( &constant_bin[ 208412 ], 13, 1 );
    const_str_plain__testUponDeath = UNSTREAM_STRING( &constant_bin[ 208100 ], 14, 1 );
    const_str_plain__doProfiledFrames = UNSTREAM_STRING( &constant_bin[ 203535 ], 17, 1 );
    const_tuple_none_none_none_none_none_false_none_none_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 2, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 3, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 5, Py_False ); Py_INCREF( Py_False );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 6, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_none_none_none_false_none_none_tuple, 7, Py_None ); Py_INCREF( Py_None );
    const_str_plain_PythonTask = UNSTREAM_STRING( &constant_bin[ 213440 ], 10, 1 );
    const_tuple_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77_tuple, 0, const_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77 ); Py_INCREF( const_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_direct$task$Task( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_8c34676ca982b726e4c254dfc7ce4764;
static PyCodeObject *codeobj_5887760a6bdb8b06dae2fa16a7f0c572;
static PyCodeObject *codeobj_e6d163f7ce084dfa4db808fa4e122773;
static PyCodeObject *codeobj_40a5f03b51982b2c81249b0ebbb114e8;
static PyCodeObject *codeobj_783b5de3b90c55d3d1dec390be52f8c3;
static PyCodeObject *codeobj_95ee551f0efc18daaf624e3b714b82c1;
static PyCodeObject *codeobj_189ada8fa1f5a86a1eee23463063c5a4;
static PyCodeObject *codeobj_15701462c26ef8d6ea9ee9534de654cd;
static PyCodeObject *codeobj_7ab2c37fdb059bac0f852c71d5c13938;
static PyCodeObject *codeobj_4aee6f72bccb9d5d2abd2a1ab86f3856;
static PyCodeObject *codeobj_49f6beb29b76ae66b646db967d65099b;
static PyCodeObject *codeobj_8b092dd14ac9b4a35adb11385b6a62aa;
static PyCodeObject *codeobj_cee04e6a5e29a5435e6448a27a6c66f4;
static PyCodeObject *codeobj_9be619cf3323295ce5c2d4d8e9c31008;
static PyCodeObject *codeobj_ad19eab5874f533bb4eb6b9c6695ecee;
static PyCodeObject *codeobj_d89537e80c1f8aecb4da5c734ce0930b;
static PyCodeObject *codeobj_55412ff8103be46f9405ae1c765f63e0;
static PyCodeObject *codeobj_aab3cda59294e744f97b45d1bcd1e9fb;
static PyCodeObject *codeobj_6fcd83d5f03e1a39b59b835c61383bc9;
static PyCodeObject *codeobj_230a109e65a6d2e464a74c64fc9f1a4c;
static PyCodeObject *codeobj_d1888f560c6d4ffd7ce4ab5a0331dd2a;
static PyCodeObject *codeobj_4c7ea89a803f23bfaa8c7f3830cfe0de;
static PyCodeObject *codeobj_b2248f0954b89bf165de459ebd31caa7;
static PyCodeObject *codeobj_35ffccfa398837ded2bd5733c8d924d6;
static PyCodeObject *codeobj_0fc3126900c7a9fcc9df582b4f7915e1;
static PyCodeObject *codeobj_bc19b89aaa8ec43cf5aebdc7db613c7d;
static PyCodeObject *codeobj_d9d7300b276c32d2aec3e898ec71f6a8;
static PyCodeObject *codeobj_3ae9f244b506bb49e08c0f1d5ccebab7;
static PyCodeObject *codeobj_32f1d0deba85ca3786afaeedb484ac28;
static PyCodeObject *codeobj_892ec132c5506551417f702766d58fe6;
static PyCodeObject *codeobj_fbc82397480933af0120c9ef986ded6f;
static PyCodeObject *codeobj_76f5520c3df4326fd3f341d21a27c157;
static PyCodeObject *codeobj_a72779e213e20817d7aabe3d88118889;
static PyCodeObject *codeobj_3d220405f6fe0242418c371480db0f4c;
static PyCodeObject *codeobj_bb572334680fd07cd8affd7546c61848;
static PyCodeObject *codeobj_b4c717e1db160798c92c590350bfd5f4;
static PyCodeObject *codeobj_aaa813e18a939b7e39a24b6807b60fbe;
static PyCodeObject *codeobj_6dd5ead85f2dceefcd3c0ad036f415b5;
static PyCodeObject *codeobj_2f61258a47b5ec321de015af81d5c414;
static PyCodeObject *codeobj_41cc36c7ef3623473e92ac27130c8e1a;
static PyCodeObject *codeobj_1ea7d4fc2654fedb2b66cb57aa54709c;
static PyCodeObject *codeobj_be4acd18b3e5013ee6352e8ca2cf5dcc;
static PyCodeObject *codeobj_2605fcb73ceb206da13b1a960eb162fb;
static PyCodeObject *codeobj_b46508c12aab209175d0d732fde371d4;
static PyCodeObject *codeobj_e9004900ae0eb8708327b2ab1e90670b;
static PyCodeObject *codeobj_04264c5692dbff7b77dfac19dc287f42;
static PyCodeObject *codeobj_eaf5b156be7cffba63794344440c3daf;
static PyCodeObject *codeobj_465c20828fb245d1da49cbac215c5a05;
static PyCodeObject *codeobj_137d6f860c2949f6d61c047f69bd47e2;
static PyCodeObject *codeobj_60fcb9ff8444cc51b39ea5424bd7a9e5;
static PyCodeObject *codeobj_e51415919b7d50e46577b8622cf2ec9b;
static PyCodeObject *codeobj_1d2f967c96ad8076cc0ec9af2d5bb030;
static PyCodeObject *codeobj_67d72ea4a918b2129d3f98435dcb65cd;
static PyCodeObject *codeobj_7e5a4b05410fd288aa4d09eb027f088e;
static PyCodeObject *codeobj_ed58f74a2f8d002a5e08521a7ef83afd;
static PyCodeObject *codeobj_5a51d4d6a7824a4da72cbd4babb35c6e;
static PyCodeObject *codeobj_d679788b81855c7ebc4e9894c8aaa1cd;
static PyCodeObject *codeobj_e48d719b4002d925a003fb3b662eb651;
static PyCodeObject *codeobj_7cac45d21cdc2606c699c8d89e878305;
static PyCodeObject *codeobj_7963539a5bd3966c06a5221f19ea23ad;
static PyCodeObject *codeobj_26ff3b2c3e3551d25329e13e5138e1cb;
static PyCodeObject *codeobj_76f669d460a509794777b874913fc224;
static PyCodeObject *codeobj_57a043910180f24d10c601e798c7cb9d;
static PyCodeObject *codeobj_20362686021c7e20ed2fb06d919d0022;
static PyCodeObject *codeobj_861daf0b7437317856d7e310c7f2eda7;
static PyCodeObject *codeobj_0ad31bf2742231db2b8a89ff59d1b076;
static PyCodeObject *codeobj_100b97301f56e3452f5e62ef4be52d02;
static PyCodeObject *codeobj_37970f8793037a4ddab592f241f4401c;
static PyCodeObject *codeobj_95ca09c6dabb993508688977ed1f28f8;
static PyCodeObject *codeobj_f80fe5d8c84d87c6fbd950532e6b3f57;
static PyCodeObject *codeobj_160465e968dea0bb99ee34e50350b838;
static PyCodeObject *codeobj_c3612d9631208f6153f2c2d841b34ccf;
static PyCodeObject *codeobj_2bc704666bbeaa4896b3f93bd0374366;
static PyCodeObject *codeobj_03b873bf40115ff2336d78b244fb9290;
static PyCodeObject *codeobj_948d539c21e35b6bfc38f19eca691423;
static PyCodeObject *codeobj_d36ce0e5dd46338a23c8346264516bfd;
static PyCodeObject *codeobj_f012b734e998e4843f1c83a41b919e26;
static PyCodeObject *codeobj_088bf2142fffa6737970b898cd57c2ef;
static PyCodeObject *codeobj_52b4ef6bb6cf369ffc641db2e5bed903;
static PyCodeObject *codeobj_02957f44bd44983c583328d986a2cd95;
static PyCodeObject *codeobj_860dbd981425fc7d6911219b7968a371;
static PyCodeObject *codeobj_c2379bdea82fc3b87246bcfc906c98bf;
static PyCodeObject *codeobj_65bae77f21e88e99debd37895a7b8890;
static PyCodeObject *codeobj_e6ca53e3331ac817da7097ab320f1107;
static PyCodeObject *codeobj_a8ee911f00c862b982565e929f2a6c58;
static PyCodeObject *codeobj_437f87a7b8a2bfcc26a548c69f7a50ba;
static PyCodeObject *codeobj_56381d496ef85badf723bb2a79ef166d;
static PyCodeObject *codeobj_26392af6f6494f1c3c610fcf382e43f2;
static PyCodeObject *codeobj_34fde79ef14e6d7b87a91b80e98450eb;
static PyCodeObject *codeobj_259c61b4f9811ad8ccc96af43b96bd59;
static PyCodeObject *codeobj_e702ecd4827fa652e6590e8682d95714;
static PyCodeObject *codeobj_893e0b32b6121f59fe207ad6d789310b;
static PyCodeObject *codeobj_7ae96314f7fe1f82a8f9a5e87073157e;
static PyCodeObject *codeobj_792970ddc7a8d0bdaa6eddaf7d3146a8;
static PyCodeObject *codeobj_9e313032971706852e78187240f68f33;
static PyCodeObject *codeobj_4f491396b898906b362b2120438c8d24;
static PyCodeObject *codeobj_b0511af086dd0631243d38f48437a299;
static PyCodeObject *codeobj_12aa142535b85eafe922a23f44924443;
static PyCodeObject *codeobj_bfc43a007ad8797741d50f7fe2c022f5;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_d4e4e0734a21d5b1e4b98d82d29d0f71 );
    codeobj_8c34676ca982b726e4c254dfc7ce4764 = MAKE_CODEOBJ( module_filename_obj, const_str_angle_lambda, 156, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5887760a6bdb8b06dae2fa16a7f0c572 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_Task, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_e6d163f7ce084dfa4db808fa4e122773 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_TaskManager, 102, const_tuple_0dc1ab1b00fc5f234fbb1603f680c525_tuple, 0, CO_NEWLOCALS | CO_NOFREE );
    codeobj_40a5f03b51982b2c81249b0ebbb114e8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___init__, 111, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_783b5de3b90c55d3d1dec390be52f8c3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___makeTaskList, 290, const_tuple_c639fdd50894218b9bd4e6cb1cd53c8b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95ee551f0efc18daaf624e3b714b82c1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___repr__, 732, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_189ada8fa1f5a86a1eee23463063c5a4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain___setupTask, 383, const_tuple_a1e5c8f3b683306352af06ecdfee99b2_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_15701462c26ef8d6ea9ee9534de654cd = MAKE_CODEOBJ( module_filename_obj, const_str_plain___tryReplaceTaskMethod, 568, const_tuple_c598c90efbeb22ce49a5f5c30a0dafbe_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ab2c37fdb059bac0f852c71d5c13938 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__addTask, 910, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4aee6f72bccb9d5d2abd2a1ab86f3856 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__addTask, 1042, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_49f6beb29b76ae66b646db967d65099b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__checkMemLeaks, 761, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b092dd14ac9b4a35adb11385b6a62aa = MAKE_CODEOBJ( module_filename_obj, const_str_plain__clearTask, 912, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cee04e6a5e29a5435e6448a27a6c66f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__clearTask, 1044, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9be619cf3323295ce5c2d4d8e9c31008 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__doProfiledFrames, 617, const_tuple_5f3efb215a8d38403650998c55156313_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ad19eab5874f533bb4eb6b9c6695ecee = MAKE_CODEOBJ( module_filename_obj, const_str_plain__getLastTaskProfileSession, 707, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d89537e80c1f8aecb4da5c734ce0930b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__getRandomTask, 710, const_tuple_c38b39b1407e12ab4cdd8a94ffd834e6_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_55412ff8103be46f9405ae1c765f63e0 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__hasProfiledDesignatedTask, 703, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aab3cda59294e744f97b45d1bcd1e9fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLater, 936, const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6fcd83d5f03e1a39b59b835c61383bc9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLaterAppendTask, 1000, const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_230a109e65a6d2e464a74c64fc9f1a4c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLaterExtraArgs, 980, const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d1888f560c6d4ffd7ce4ab5a0331dd2a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLaterOwner, 1050, const_tuple_c1336aacdc7d6262db6d83086d8ed9d6_tuple, 5, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4c7ea89a803f23bfaa8c7f3830cfe0de = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLaterPri, 959, const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b2248f0954b89bf165de459ebd31caa7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__monitorDoLaterUponDeath, 1023, const_tuple_9164157e4224bb8628f920ece9896c02_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_35ffccfa398837ded2bd5733c8d924d6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__profileFunc, 508, const_tuple_str_plain_numFrames_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS );
    codeobj_0fc3126900c7a9fcc9df582b4f7915e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__profileTask, 673, const_tuple_2d49954d94f7a161e45a6f937b8ac199_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bc19b89aaa8ec43cf5aebdc7db613c7d = MAKE_CODEOBJ( module_filename_obj, const_str_plain__runTests, 764, const_tuple_a0a3a13514ffb5caba494780f2ce74c2_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d9d7300b276c32d2aec3e898ec71f6a8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__setProfileTask, 656, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3ae9f244b506bb49e08c0f1d5ccebab7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__startTrackingMemLeaks, 755, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_32f1d0deba85ca3786afaeedb484ac28 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__stopTrackingMemLeaks, 758, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_892ec132c5506551417f702766d58fe6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testAppendTask, 884, const_tuple_str_plain_arg1_str_plain_arg2_str_plain_task_str_plain_l_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fbc82397480933af0120c9ef986ded6f = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testCont, 807, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_76f5520c3df4326fd3f341d21a27c157 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testContDone, 821, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a72779e213e20817d7aabe3d88118889 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLater1, 932, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3d220405f6fe0242418c371480db0f4c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLater2, 934, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bb572334680fd07cd8affd7546c61848 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterAppendTask, 997, const_tuple_str_plain_arg1_str_plain_task_str_plain_l_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b4c717e1db160798c92c590350bfd5f4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterExtraArgs, 978, const_tuple_str_plain_arg1_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_aaa813e18a939b7e39a24b6807b60fbe = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterOwner, 1048, const_tuple_str_plain_l_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6dd5ead85f2dceefcd3c0ad036f415b5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterPri1, 955, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2f61258a47b5ec321de015af81d5c414 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterPri2, 957, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_41cc36c7ef3623473e92ac27130c8e1a = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDoLaterUponDeath, 1021, const_tuple_str_plain_arg1_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1ea7d4fc2654fedb2b66cb57aa54709c = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDone, 776, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_be4acd18b3e5013ee6352e8ca2cf5dcc = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDupNameDoLaters, 1115, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2605fcb73ceb206da13b1a960eb162fb = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDupNameDoLatersRemove, 1127, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b46508c12aab209175d0d732fde371d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testDupNamedTasks, 797, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e9004900ae0eb8708327b2ab1e90670b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testExtraArgs, 872, const_tuple_str_plain_arg1_str_plain_arg2_str_plain_l_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_04264c5692dbff7b77dfac19dc287f42 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testGetDoLaters, 1097, const_tuple_empty, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_eaf5b156be7cffba63794344440c3daf = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testGetTasks, 1077, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_465c20828fb245d1da49cbac215c5a05 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testGetTasksNamed, 1142, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_137d6f860c2949f6d61c047f69bd47e2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testHasTaskNamed, 839, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_60fcb9ff8444cc51b39ea5424bd7a9e5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testOwner, 916, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e51415919b7d50e46577b8622cf2ec9b = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testPri1, 850, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1d2f967c96ad8076cc0ec9af2d5bb030 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testPri2, 853, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_67d72ea4a918b2129d3f98435dcb65cd = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testRemoveByName, 788, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7e5a4b05410fd288aa4d09eb027f088e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testRemoveTasksMatching, 1157, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ed58f74a2f8d002a5e08521a7ef83afd = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testTaskObj, 1182, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5a51d4d6a7824a4da72cbd4babb35c6e = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testTaskObjRemove, 1199, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d679788b81855c7ebc4e9894c8aaa1cd = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testUponDeath, 898, const_tuple_str_plain_task_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e48d719b4002d925a003fb3b662eb651 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__testUponDeathFunc, 1018, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7cac45d21cdc2606c699c8d89e878305 = MAKE_CODEOBJ( module_filename_obj, const_str_plain__unpackIOError, 553, const_tuple_af70a7a93a6e596d4cbb09772cd65dde_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7963539a5bd3966c06a5221f19ea23ad = MAKE_CODEOBJ( module_filename_obj, const_str_plain__uponDeathFunc, 896, const_tuple_str_plain_task_str_plain_l_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_26ff3b2c3e3551d25329e13e5138e1cb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_add, 322, const_tuple_3036fab7d3b98fcbb7dd4e57181e61bb_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_76f669d460a509794777b874913fc224 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_checkLeak, 1254, const_tuple_a4e79e67276ce7e082ec1e83b3be1895_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_57a043910180f24d10c601e798c7cb9d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_destroy, 144, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_20362686021c7e20ed2fb06d919d0022 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_doMethodLater, 296, const_tuple_a7664b39550c747f55be06e641fb33ad_tuple, 11, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_861daf0b7437317856d7e310c7f2eda7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_doTask, 1260, const_tuple_str_plain_self_str_plain_task_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0ad31bf2742231db2b8a89ff59d1b076 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_doYield, 737, const_tuple_4c2cf27dda632ec273727b84108dc762_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_100b97301f56e3452f5e62ef4be52d02 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_finalInit, 135, const_tuple_str_plain_self_str_plain_StateVar_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_37970f8793037a4ddab592f241f4401c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_flushTaskProfiles, 652, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_95ca09c6dabb993508688977ed1f28f8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getAllTasks, 277, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f80fe5d8c84d87c6fbd950532e6b3f57 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getCurrentTask, 177, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_160465e968dea0bb99ee34e50350b838 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getDoLaters, 286, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c3612d9631208f6153f2c2d841b34ccf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getProfileFrames, 622, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_2bc704666bbeaa4896b3f93bd0374366 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getProfileFramesSV, 625, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_03b873bf40115ff2336d78b244fb9290 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getProfileSession, 598, const_tuple_str_plain_self_str_plain_name_str_plain_PS_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_948d539c21e35b6bfc38f19eca691423 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getProfileTasks, 635, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_d36ce0e5dd46338a23c8346264516bfd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getProfileTasksSV, 638, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f012b734e998e4843f1c83a41b919e26 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTasks, 282, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_088bf2142fffa6737970b898cd57c2ef = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTasksMatching, 270, const_tuple_str_plain_self_str_plain_taskPattern_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_52b4ef6bb6cf369ffc641db2e5bed903 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getTasksNamed, 265, const_tuple_str_plain_self_str_plain_taskName_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_02957f44bd44983c583328d986a2cd95 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasTaskChain, 183, const_tuple_str_plain_self_str_plain_chainName_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_860dbd981425fc7d6911219b7968a371 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hasTaskNamed, 259, const_tuple_str_plain_self_str_plain_taskName_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_c2379bdea82fc3b87246bcfc906c98bf = MAKE_CODEOBJ( module_filename_obj, const_str_plain_invokeDefaultHandler, 158, const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_65bae77f21e88e99debd37895a7b8890 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_keyboardInterruptHandler, 166, const_tuple_str_plain_self_str_plain_signalNumber_str_plain_stackFrame_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e6ca53e3331ac817da7097ab320f1107 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_logTaskProfiles, 648, const_tuple_str_plain_self_str_plain_name_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a8ee911f00c862b982565e929f2a6c58 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_loop, 94, const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_437f87a7b8a2bfcc26a548c69f7a50ba = MAKE_CODEOBJ( module_filename_obj, const_str_plain_popupControls, 592, const_tuple_str_plain_self_str_plain_TaskManagerPanel_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_56381d496ef85badf723bb2a79ef166d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_print_exc_plus, 25, const_tuple_bc208da109e99712fefec75b5337e250_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_26392af6f6494f1c3c610fcf382e43f2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_profileFrames, 608, const_tuple_18987c36cfe03d62b3a115bdd6ea4acd_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_34fde79ef14e6d7b87a91b80e98450eb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_remove, 427, const_tuple_749940d1b0bf3ec0043459e4eb8fade0_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_259c61b4f9811ad8ccc96af43b96bd59 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeTasksMatching, 445, const_tuple_str_plain_self_str_plain_taskPattern_str_plain_tasks_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_e702ecd4827fa652e6590e8682d95714 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_replaceMethod, 586, const_tuple_cf65ac7678fad121040ed3764a8d5a70_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_893e0b32b6121f59fe207ad6d789310b = MAKE_CODEOBJ( module_filename_obj, const_str_plain_run, 483, const_tuple_fb3de886515d4391e4aa4a43b2432272_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7ae96314f7fe1f82a8f9a5e87073157e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_sequence, 87, const_tuple_str_plain_taskList_str_plain_seq_str_plain_task_tuple, 0, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_NOFREE );
    codeobj_792970ddc7a8d0bdaa6eddaf7d3146a8 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setClock, 152, const_tuple_str_plain_self_str_plain_clockObject_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9e313032971706852e78187240f68f33 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setProfileFrames, 628, const_tuple_str_plain_self_str_plain_profileFrames_str_plain_FP_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_4f491396b898906b362b2120438c8d24 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setProfileTasks, 641, const_tuple_str_plain_self_str_plain_profileTasks_str_plain_TP_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b0511af086dd0631243d38f48437a299 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_setupTaskChain, 193, const_tuple_d9faa50e4b8d9667240e8391b04744ae_tuple, 8, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_12aa142535b85eafe922a23f44924443 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_step, 455, const_tuple_cb3db5560e2f3ed1e400aba65af718a2_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bfc43a007ad8797741d50f7fe2c022f5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_stop, 564, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner( PyObject **python_pars );


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass( PyObject **python_pars );


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_5_complex_call_helper_pos_star_list( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_19_add( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_1___init__(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_21_remove(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_23_step(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc( PyObject *defaults, struct Nuitka_CellObject *closure_self );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_26_stop(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_3_destroy(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_46___repr__(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_47_doYield(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_4_setClock(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_5_lambda(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_1_print_exc_plus(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_2_sequence(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_3_loop(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak(  );


static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask(  );


// The module function definitions.
static PyObject *impl_direct$task$Task$$$function_1_print_exc_plus( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_sys = NULL;
    PyObject *var_traceback = NULL;
    PyObject *var_tb = NULL;
    PyObject *var_stack = NULL;
    PyObject *var_f = NULL;
    PyObject *var_frame = NULL;
    PyObject *var_key = NULL;
    PyObject *var_value = NULL;
    PyObject *var_valueStr = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iter_arg_3;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_str_arg_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_name_name_1 = const_str_plain_sys;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    assert( tmp_assign_source_1 != NULL );
    assert( var_sys == NULL );
    var_sys = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_56381d496ef85badf723bb2a79ef166d, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_2 = const_str_plain_traceback;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    frame_function->m_frame.f_lineno = 31;
    tmp_assign_source_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 31;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_traceback == NULL );
    var_traceback = tmp_assign_source_2;

    tmp_called_instance_1 = var_sys;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 33;
    tmp_subscribed_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_exc_info );
    if ( tmp_subscribed_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 33;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_1 = const_int_pos_2;
    tmp_assign_source_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    Py_DECREF( tmp_subscribed_name_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 33;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_tb == NULL );
    var_tb = tmp_assign_source_3;

    loop_start_1:;
    tmp_source_name_1 = var_tb;

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "tb" );
        exception_tb = NULL;

        exception_lineno = 35;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_tb_next );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 35;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_source_name_2 = var_tb;

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "tb" );
        exception_tb = NULL;

        exception_lineno = 37;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_tb_next );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 37;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_tb;
        var_tb = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_assign_source_5 = PyList_New( 0 );
    assert( var_stack == NULL );
    var_stack = tmp_assign_source_5;

    tmp_source_name_3 = var_tb;

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "tb" );
        exception_tb = NULL;

        exception_lineno = 39;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_6 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_tb_frame );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 39;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_f == NULL );
    var_f = tmp_assign_source_6;

    loop_start_2:;
    tmp_cond_value_2 = var_f;

    if ( tmp_cond_value_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "f" );
        exception_tb = NULL;

        exception_lineno = 40;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 40;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    goto loop_end_2;
    branch_no_2:;
    tmp_source_name_4 = var_stack;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 41;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_f;

    if ( tmp_args_element_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "f" );
        exception_tb = NULL;

        exception_lineno = 41;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 41;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 41;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = var_f;

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "f" );
        exception_tb = NULL;

        exception_lineno = 42;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_f_back );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 42;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_f;
        var_f = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 40;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_2;
    loop_end_2:;
    tmp_called_instance_2 = var_stack;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 43;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_reverse );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 43;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_traceback;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 44;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_print_exc );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 44;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_print_value = const_str_digest_d533b57f698317f04ca0c379c0ad0a9a;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 45;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 45;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = var_stack;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 46;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_8;

    // Tried code:
    loop_start_3:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_9 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_3;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooooo";
            frame_function->m_frame.f_lineno = 46;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_assign_source_10 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_10 );
    {
        PyObject *old = var_frame;
        var_frame = tmp_assign_source_10;
        Py_INCREF( var_frame );
        Py_XDECREF( old );
    }

    tmp_print_value = const_str_empty;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 47;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 47;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_1 = const_str_digest_f52007705b73a852251f306ade6b0b32;
    tmp_right_name_1 = PyTuple_New( 3 );
    tmp_source_name_7 = var_frame;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_source_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_f_code );
    if ( tmp_source_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 48;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_co_name );
    Py_DECREF( tmp_source_name_6 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 48;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_source_name_9 = var_frame;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_source_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_f_code );
    if ( tmp_source_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 49;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_co_filename );
    Py_DECREF( tmp_source_name_8 );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 49;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_source_name_10 = var_frame;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_f_lineno );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 50;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 2, tmp_tuple_element_1 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 48;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 48;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 48;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_source_name_11 = var_frame;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_f_locals );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 51;
    tmp_list_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_items );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_list_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_iter_arg_2 = PySequence_List( tmp_list_arg_1 );
    Py_DECREF( tmp_list_arg_1 );
    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_11 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_4:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_12 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_12 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_4;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooooo";
            frame_function->m_frame.f_lineno = 51;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_iter_arg_3 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_iter_arg_3 );
    tmp_assign_source_13 = MAKE_ITERATOR( tmp_iter_arg_3 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_14 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_14 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "ooooooooo";
        exception_lineno = 51;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_15 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_15 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "ooooooooo";
        exception_lineno = 51;
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_15;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description = "ooooooooo";
                goto try_except_handler_5;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description = "ooooooooo";
        goto try_except_handler_5;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_4;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_3;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_16 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_16 );
    {
        PyObject *old = var_key;
        var_key = tmp_assign_source_16;
        Py_INCREF( var_key );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_17 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_17 );
    {
        PyObject *old = var_value;
        var_value = tmp_assign_source_17;
        Py_INCREF( var_value );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Tried code:
    tmp_str_arg_1 = var_value;

    CHECK_OBJECT( tmp_str_arg_1 );
    tmp_assign_source_18 = PyObject_Str( tmp_str_arg_1 );
    if ( tmp_assign_source_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 56;
        type_description = "ooooooooo";
        goto try_except_handler_6;
    }
    {
        PyObject *old = var_valueStr;
        var_valueStr = tmp_assign_source_18;
        Py_XDECREF( old );
    }

    goto try_end_3;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != -1 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_function, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_assign_source_19 = const_str_digest_14e7a80f5f7f1182fca3d8566b83d9d3;
    {
        PyObject *old = var_valueStr;
        var_valueStr = tmp_assign_source_19;
        Py_INCREF( var_valueStr );
        Py_XDECREF( old );
    }

    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_1_print_exc_plus );
    return NULL;
    // End of try:
    try_end_3:;
    tmp_left_name_2 = const_str_digest_6f6b30f043208ddc0fd34ee37c3374a2;
    tmp_right_name_2 = PyTuple_New( 2 );
    tmp_tuple_element_2 = var_key;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_2 );
    tmp_tuple_element_2 = var_valueStr;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_2 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 59;
        type_description = "ooooooooo";
        goto try_except_handler_3;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 59;
        type_description = "ooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 59;
        type_description = "ooooooooo";
        goto try_except_handler_3;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "ooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_4;
    loop_end_4:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_2;
    // End of try:
    try_end_4:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 46;
        type_description = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_3;
    loop_end_3:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,var_sys, var_traceback, var_tb, var_stack, var_f, var_frame, var_key, var_value, var_valueStr );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_1_print_exc_plus );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_sys );
    Py_DECREF( var_sys );
    var_sys = NULL;

    CHECK_OBJECT( (PyObject *)var_traceback );
    Py_DECREF( var_traceback );
    var_traceback = NULL;

    Py_XDECREF( var_tb );
    var_tb = NULL;

    CHECK_OBJECT( (PyObject *)var_stack );
    Py_DECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_frame );
    var_frame = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_valueStr );
    var_valueStr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)var_sys );
    Py_DECREF( var_sys );
    var_sys = NULL;

    Py_XDECREF( var_traceback );
    var_traceback = NULL;

    Py_XDECREF( var_tb );
    var_tb = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_f );
    var_f = NULL;

    Py_XDECREF( var_frame );
    var_frame = NULL;

    Py_XDECREF( var_key );
    var_key = NULL;

    Py_XDECREF( var_value );
    var_value = NULL;

    Py_XDECREF( var_valueStr );
    var_valueStr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_1_print_exc_plus );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$function_2_sequence( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_taskList = python_pars[ 0 ];
    PyObject *var_seq = NULL;
    PyObject *var_task = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7ae96314f7fe1f82a8f9a5e87073157e, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTaskSequence );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTaskSequence );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AsyncTaskSequence" );
        exception_tb = NULL;

        exception_lineno = 88;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 88;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_plain_sequence_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 88;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_seq == NULL );
    var_seq = tmp_assign_source_1;

    tmp_iter_arg_1 = par_taskList;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 89;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            frame_function->m_frame.f_lineno = 89;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_task;
        var_task = tmp_assign_source_4;
        Py_INCREF( var_task );
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = var_seq;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = var_task;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 90;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_addTask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 90;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 89;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_taskList, var_seq, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_seq;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_2_sequence );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_taskList );
    Py_DECREF( par_taskList );
    par_taskList = NULL;

    CHECK_OBJECT( (PyObject *)var_seq );
    Py_DECREF( var_seq );
    var_seq = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_taskList );
    Py_DECREF( par_taskList );
    par_taskList = NULL;

    Py_XDECREF( var_seq );
    var_seq = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_2_sequence );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$function_3_loop( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_taskList = python_pars[ 0 ];
    PyObject *var_seq = NULL;
    PyObject *var_task = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a8ee911f00c862b982565e929f2a6c58, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTaskSequence );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTaskSequence );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AsyncTaskSequence" );
        exception_tb = NULL;

        exception_lineno = 95;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 95;
    tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_plain_loop_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 95;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_seq == NULL );
    var_seq = tmp_assign_source_1;

    tmp_iter_arg_1 = par_taskList;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooo";
            frame_function->m_frame.f_lineno = 96;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_task;
        var_task = tmp_assign_source_4;
        Py_INCREF( var_task );
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = var_seq;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = var_task;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 97;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_addTask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 97;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_called_instance_2 = var_seq;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 98;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setRepeatCount, &PyTuple_GET_ITEM( const_tuple_int_neg_1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_taskList, var_seq, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_seq;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_3_loop );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_taskList );
    Py_DECREF( par_taskList );
    par_taskList = NULL;

    CHECK_OBJECT( (PyObject *)var_seq );
    Py_DECREF( var_seq );
    var_seq = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_taskList );
    Py_DECREF( par_taskList );
    par_taskList = NULL;

    Py_XDECREF( var_seq );
    var_seq = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_3_loop );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var_notify = NULL;
    PyObject *var_taskTimerVerbose = NULL;
    PyObject *var_extendedExceptions = NULL;
    PyObject *var_pStatsTasks = NULL;
    PyObject *var_MaxEpochSpeed = NULL;
    PyObject *var___init__ = NULL;
    PyObject *var_finalInit = NULL;
    PyObject *var_destroy = NULL;
    PyObject *var_setClock = NULL;
    PyObject *var_clock = NULL;
    PyObject *var_invokeDefaultHandler = NULL;
    PyObject *var_keyboardInterruptHandler = NULL;
    PyObject *var_getCurrentTask = NULL;
    PyObject *var_hasTaskChain = NULL;
    PyObject *var_setupTaskChain = NULL;
    PyObject *var_hasTaskNamed = NULL;
    PyObject *var_getTasksNamed = NULL;
    PyObject *var_getTasksMatching = NULL;
    PyObject *var_getAllTasks = NULL;
    PyObject *var_getTasks = NULL;
    PyObject *var_getDoLaters = NULL;
    PyObject *var__TaskManager__makeTaskList = NULL;
    PyObject *var_doMethodLater = NULL;
    PyObject *var_do_method_later = NULL;
    PyObject *var_add = NULL;
    PyObject *var__TaskManager__setupTask = NULL;
    PyObject *var_remove = NULL;
    PyObject *var_removeTasksMatching = NULL;
    PyObject *var_step = NULL;
    PyObject *var_run = NULL;
    PyObject *var__unpackIOError = NULL;
    PyObject *var_stop = NULL;
    PyObject *var__TaskManager__tryReplaceTaskMethod = NULL;
    PyObject *var_replaceMethod = NULL;
    PyObject *var_popupControls = NULL;
    PyObject *var_getProfileSession = NULL;
    PyObject *var_profileFrames = NULL;
    PyObject *var__doProfiledFrames = NULL;
    PyObject *var_getProfileFrames = NULL;
    PyObject *var_getProfileFramesSV = NULL;
    PyObject *var_setProfileFrames = NULL;
    PyObject *var_getProfileTasks = NULL;
    PyObject *var_getProfileTasksSV = NULL;
    PyObject *var_setProfileTasks = NULL;
    PyObject *var_logTaskProfiles = NULL;
    PyObject *var_flushTaskProfiles = NULL;
    PyObject *var__setProfileTask = NULL;
    PyObject *var__profileTask = NULL;
    PyObject *var__hasProfiledDesignatedTask = NULL;
    PyObject *var__getLastTaskProfileSession = NULL;
    PyObject *var__getRandomTask = NULL;
    PyObject *var___repr__ = NULL;
    PyObject *var_doYield = NULL;
    PyObject *var__startTrackingMemLeaks = NULL;
    PyObject *var__stopTrackingMemLeaks = NULL;
    PyObject *var__checkMemLeaks = NULL;
    PyObject *var__runTests = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_11eb635c2afc52a8139249187777a73c;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e6d163f7ce084dfa4db808fa4e122773, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_directNotify );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_directNotify );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "directNotify" );
        exception_tb = NULL;

        exception_lineno = 103;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 103;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_newCategory, &PyTuple_GET_ITEM( const_tuple_str_plain_TaskManager_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 103;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_notify == NULL );
    var_notify = tmp_assign_source_2;

    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ConfigVariableBool" );
        exception_tb = NULL;

        exception_lineno = 105;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 105;
    tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_str_digest_22dff21c3b984696a3f596fd6541e8e0_false_tuple, 0 ) );

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 105;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_taskTimerVerbose == NULL );
    var_taskTimerVerbose = tmp_assign_source_3;

    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ConfigVariableBool" );
        exception_tb = NULL;

        exception_lineno = 106;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 106;
    tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_str_digest_ef6839ab4f74ed95c1a43e3e892cb51d_false_tuple, 0 ) );

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 106;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_extendedExceptions == NULL );
    var_extendedExceptions = tmp_assign_source_4;

    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "ConfigVariableBool" );
        exception_tb = NULL;

        exception_lineno = 107;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 107;
    tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_digest_f9fc41598bc46920591fd091b028aaf0_false_tuple, 0 ) );

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 107;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pStatsTasks == NULL );
    var_pStatsTasks = tmp_assign_source_5;

    tmp_assign_source_6 = const_float_0_03333333333333333;
    assert( var_MaxEpochSpeed == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_MaxEpochSpeed = tmp_assign_source_6;

    tmp_assign_source_7 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_1___init__(  );
    assert( var___init__ == NULL );
    var___init__ = tmp_assign_source_7;

    tmp_assign_source_8 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit(  );
    assert( var_finalInit == NULL );
    var_finalInit = tmp_assign_source_8;

    tmp_assign_source_9 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_3_destroy(  );
    assert( var_destroy == NULL );
    var_destroy = tmp_assign_source_9;

    tmp_assign_source_10 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_4_setClock(  );
    assert( var_setClock == NULL );
    var_setClock = tmp_assign_source_10;

    tmp_called_name_4 = LOOKUP_BUILTIN( const_str_plain_property );
    assert( tmp_called_name_4 != NULL );
    tmp_args_element_name_1 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_5_lambda(  );
    tmp_args_element_name_2 = var_setClock;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 156;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;
        type_description = "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_clock == NULL );
    var_clock = tmp_assign_source_11;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,var___module__, var_notify, var_taskTimerVerbose, var_extendedExceptions, var_pStatsTasks, var_MaxEpochSpeed, var___init__, var_finalInit, var_destroy, var_setClock, var_clock, var_invokeDefaultHandler, var_keyboardInterruptHandler, var_getCurrentTask, var_hasTaskChain, var_setupTaskChain, var_hasTaskNamed, var_getTasksNamed, var_getTasksMatching, var_getAllTasks, var_getTasks, var_getDoLaters, var__TaskManager__makeTaskList, var_doMethodLater, var_do_method_later, var_add, var__TaskManager__setupTask, var_remove, var_removeTasksMatching, var_step, var_run, var__unpackIOError, var_stop, var__TaskManager__tryReplaceTaskMethod, var_replaceMethod, var_popupControls, var_getProfileSession, var_profileFrames, var__doProfiledFrames, var_getProfileFrames, var_getProfileFramesSV, var_setProfileFrames, var_getProfileTasks, var_getProfileTasksSV, var_setProfileTasks, var_logTaskProfiles, var_flushTaskProfiles, var__setProfileTask, var__profileTask, var__hasProfiledDesignatedTask, var__getLastTaskProfileSession, var__getRandomTask, var___repr__, var_doYield, var__startTrackingMemLeaks, var__stopTrackingMemLeaks, var__checkMemLeaks, var__runTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_assign_source_12 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler(  );
    assert( var_invokeDefaultHandler == NULL );
    var_invokeDefaultHandler = tmp_assign_source_12;

    tmp_assign_source_13 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler(  );
    assert( var_keyboardInterruptHandler == NULL );
    var_keyboardInterruptHandler = tmp_assign_source_13;

    tmp_assign_source_14 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask(  );
    assert( var_getCurrentTask == NULL );
    var_getCurrentTask = tmp_assign_source_14;

    tmp_assign_source_15 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain(  );
    assert( var_hasTaskChain == NULL );
    var_hasTaskChain = tmp_assign_source_15;

    tmp_defaults_1 = const_tuple_none_none_none_none_none_none_tuple;
    Py_INCREF( tmp_defaults_1 );
    tmp_assign_source_16 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain( tmp_defaults_1 );
    assert( var_setupTaskChain == NULL );
    var_setupTaskChain = tmp_assign_source_16;

    tmp_assign_source_17 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed(  );
    assert( var_hasTaskNamed == NULL );
    var_hasTaskNamed = tmp_assign_source_17;

    tmp_assign_source_18 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed(  );
    assert( var_getTasksNamed == NULL );
    var_getTasksNamed = tmp_assign_source_18;

    tmp_assign_source_19 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching(  );
    assert( var_getTasksMatching == NULL );
    var_getTasksMatching = tmp_assign_source_19;

    tmp_assign_source_20 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks(  );
    assert( var_getAllTasks == NULL );
    var_getAllTasks = tmp_assign_source_20;

    tmp_assign_source_21 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks(  );
    assert( var_getTasks == NULL );
    var_getTasks = tmp_assign_source_21;

    tmp_assign_source_22 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters(  );
    assert( var_getDoLaters == NULL );
    var_getDoLaters = tmp_assign_source_22;

    tmp_assign_source_23 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList(  );
    assert( var__TaskManager__makeTaskList == NULL );
    var__TaskManager__makeTaskList = tmp_assign_source_23;

    tmp_defaults_2 = const_tuple_none_none_none_none_none_false_none_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_assign_source_24 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater( tmp_defaults_2 );
    assert( var_doMethodLater == NULL );
    var_doMethodLater = tmp_assign_source_24;

    tmp_assign_source_25 = var_doMethodLater;

    CHECK_OBJECT( tmp_assign_source_25 );
    assert( var_do_method_later == NULL );
    Py_INCREF( tmp_assign_source_25 );
    var_do_method_later = tmp_assign_source_25;

    tmp_defaults_3 = const_tuple_none_none_none_none_none_false_none_none_tuple;
    Py_INCREF( tmp_defaults_3 );
    tmp_assign_source_26 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_19_add( tmp_defaults_3 );
    assert( var_add == NULL );
    var_add = tmp_assign_source_26;

    tmp_assign_source_27 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask(  );
    assert( var__TaskManager__setupTask == NULL );
    var__TaskManager__setupTask = tmp_assign_source_27;

    tmp_assign_source_28 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_21_remove(  );
    assert( var_remove == NULL );
    var_remove = tmp_assign_source_28;

    tmp_assign_source_29 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching(  );
    assert( var_removeTasksMatching == NULL );
    var_removeTasksMatching = tmp_assign_source_29;

    tmp_assign_source_30 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_23_step(  );
    assert( var_step == NULL );
    var_step = tmp_assign_source_30;

    tmp_assign_source_31 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run(  );
    assert( var_run == NULL );
    var_run = tmp_assign_source_31;

    tmp_assign_source_32 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError(  );
    assert( var__unpackIOError == NULL );
    var__unpackIOError = tmp_assign_source_32;

    tmp_assign_source_33 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_26_stop(  );
    assert( var_stop == NULL );
    var_stop = tmp_assign_source_33;

    tmp_assign_source_34 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod(  );
    assert( var__TaskManager__tryReplaceTaskMethod == NULL );
    var__TaskManager__tryReplaceTaskMethod = tmp_assign_source_34;

    tmp_assign_source_35 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod(  );
    assert( var_replaceMethod == NULL );
    var_replaceMethod = tmp_assign_source_35;

    tmp_assign_source_36 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls(  );
    assert( var_popupControls == NULL );
    var_popupControls = tmp_assign_source_36;

    tmp_defaults_4 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_4 );
    tmp_assign_source_37 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession( tmp_defaults_4 );
    assert( var_getProfileSession == NULL );
    var_getProfileSession = tmp_assign_source_37;

    tmp_defaults_5 = const_tuple_none_none_none_tuple;
    Py_INCREF( tmp_defaults_5 );
    tmp_assign_source_38 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames( tmp_defaults_5 );
    assert( var_profileFrames == NULL );
    var_profileFrames = tmp_assign_source_38;

    tmp_assign_source_39 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames(  );
    assert( var__doProfiledFrames == NULL );
    var__doProfiledFrames = tmp_assign_source_39;

    tmp_assign_source_40 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames(  );
    assert( var_getProfileFrames == NULL );
    var_getProfileFrames = tmp_assign_source_40;

    tmp_assign_source_41 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV(  );
    assert( var_getProfileFramesSV == NULL );
    var_getProfileFramesSV = tmp_assign_source_41;

    tmp_assign_source_42 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames(  );
    assert( var_setProfileFrames == NULL );
    var_setProfileFrames = tmp_assign_source_42;

    tmp_assign_source_43 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks(  );
    assert( var_getProfileTasks == NULL );
    var_getProfileTasks = tmp_assign_source_43;

    tmp_assign_source_44 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV(  );
    assert( var_getProfileTasksSV == NULL );
    var_getProfileTasksSV = tmp_assign_source_44;

    tmp_assign_source_45 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks(  );
    assert( var_setProfileTasks == NULL );
    var_setProfileTasks = tmp_assign_source_45;

    tmp_defaults_6 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_6 );
    tmp_assign_source_46 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles( tmp_defaults_6 );
    assert( var_logTaskProfiles == NULL );
    var_logTaskProfiles = tmp_assign_source_46;

    tmp_defaults_7 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_7 );
    tmp_assign_source_47 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles( tmp_defaults_7 );
    assert( var_flushTaskProfiles == NULL );
    var_flushTaskProfiles = tmp_assign_source_47;

    tmp_assign_source_48 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask(  );
    assert( var__setProfileTask == NULL );
    var__setProfileTask = tmp_assign_source_48;

    tmp_assign_source_49 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask(  );
    assert( var__profileTask == NULL );
    var__profileTask = tmp_assign_source_49;

    tmp_assign_source_50 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask(  );
    assert( var__hasProfiledDesignatedTask == NULL );
    var__hasProfiledDesignatedTask = tmp_assign_source_50;

    tmp_assign_source_51 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession(  );
    assert( var__getLastTaskProfileSession == NULL );
    var__getLastTaskProfileSession = tmp_assign_source_51;

    tmp_assign_source_52 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask(  );
    assert( var__getRandomTask == NULL );
    var__getRandomTask = tmp_assign_source_52;

    tmp_assign_source_53 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_46___repr__(  );
    assert( var___repr__ == NULL );
    var___repr__ = tmp_assign_source_53;

    tmp_assign_source_54 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_47_doYield(  );
    assert( var_doYield == NULL );
    var_doYield = tmp_assign_source_54;

    tmp_assign_source_55 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks(  );
    assert( var__startTrackingMemLeaks == NULL );
    var__startTrackingMemLeaks = tmp_assign_source_55;

    tmp_assign_source_56 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks(  );
    assert( var__stopTrackingMemLeaks == NULL );
    var__stopTrackingMemLeaks = tmp_assign_source_56;

    tmp_assign_source_57 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks(  );
    assert( var__checkMemLeaks == NULL );
    var__checkMemLeaks = tmp_assign_source_57;

    tmp_assign_source_58 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests(  );
    assert( var__runTests == NULL );
    var__runTests = tmp_assign_source_58;

    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var_notify )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_notify,
            var_notify
        );

        assert( res == 0 );
    }

    if ( var_taskTimerVerbose )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_taskTimerVerbose,
            var_taskTimerVerbose
        );

        assert( res == 0 );
    }

    if ( var_extendedExceptions )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_extendedExceptions,
            var_extendedExceptions
        );

        assert( res == 0 );
    }

    if ( var_pStatsTasks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_pStatsTasks,
            var_pStatsTasks
        );

        assert( res == 0 );
    }

    if ( var_MaxEpochSpeed )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_MaxEpochSpeed,
            var_MaxEpochSpeed
        );

        assert( res == 0 );
    }

    if ( var___init__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___init__,
            var___init__
        );

        assert( res == 0 );
    }

    if ( var_finalInit )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_finalInit,
            var_finalInit
        );

        assert( res == 0 );
    }

    if ( var_destroy )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_destroy,
            var_destroy
        );

        assert( res == 0 );
    }

    if ( var_setClock )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_setClock,
            var_setClock
        );

        assert( res == 0 );
    }

    if ( var_clock )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_clock,
            var_clock
        );

        assert( res == 0 );
    }

    if ( var_invokeDefaultHandler )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_invokeDefaultHandler,
            var_invokeDefaultHandler
        );

        assert( res == 0 );
    }

    if ( var_keyboardInterruptHandler )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_keyboardInterruptHandler,
            var_keyboardInterruptHandler
        );

        assert( res == 0 );
    }

    if ( var_getCurrentTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getCurrentTask,
            var_getCurrentTask
        );

        assert( res == 0 );
    }

    if ( var_hasTaskChain )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_hasTaskChain,
            var_hasTaskChain
        );

        assert( res == 0 );
    }

    if ( var_setupTaskChain )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_setupTaskChain,
            var_setupTaskChain
        );

        assert( res == 0 );
    }

    if ( var_hasTaskNamed )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_hasTaskNamed,
            var_hasTaskNamed
        );

        assert( res == 0 );
    }

    if ( var_getTasksNamed )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getTasksNamed,
            var_getTasksNamed
        );

        assert( res == 0 );
    }

    if ( var_getTasksMatching )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getTasksMatching,
            var_getTasksMatching
        );

        assert( res == 0 );
    }

    if ( var_getAllTasks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getAllTasks,
            var_getAllTasks
        );

        assert( res == 0 );
    }

    if ( var_getTasks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getTasks,
            var_getTasks
        );

        assert( res == 0 );
    }

    if ( var_getDoLaters )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getDoLaters,
            var_getDoLaters
        );

        assert( res == 0 );
    }

    if ( var__TaskManager__makeTaskList )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__TaskManager__makeTaskList,
            var__TaskManager__makeTaskList
        );

        assert( res == 0 );
    }

    if ( var_doMethodLater )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_doMethodLater,
            var_doMethodLater
        );

        assert( res == 0 );
    }

    if ( var_do_method_later )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_do_method_later,
            var_do_method_later
        );

        assert( res == 0 );
    }

    if ( var_add )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_add,
            var_add
        );

        assert( res == 0 );
    }

    if ( var__TaskManager__setupTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__TaskManager__setupTask,
            var__TaskManager__setupTask
        );

        assert( res == 0 );
    }

    if ( var_remove )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_remove,
            var_remove
        );

        assert( res == 0 );
    }

    if ( var_removeTasksMatching )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_removeTasksMatching,
            var_removeTasksMatching
        );

        assert( res == 0 );
    }

    if ( var_step )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_step,
            var_step
        );

        assert( res == 0 );
    }

    if ( var_run )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_run,
            var_run
        );

        assert( res == 0 );
    }

    if ( var__unpackIOError )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__unpackIOError,
            var__unpackIOError
        );

        assert( res == 0 );
    }

    if ( var_stop )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_stop,
            var_stop
        );

        assert( res == 0 );
    }

    if ( var__TaskManager__tryReplaceTaskMethod )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__TaskManager__tryReplaceTaskMethod,
            var__TaskManager__tryReplaceTaskMethod
        );

        assert( res == 0 );
    }

    if ( var_replaceMethod )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_replaceMethod,
            var_replaceMethod
        );

        assert( res == 0 );
    }

    if ( var_popupControls )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_popupControls,
            var_popupControls
        );

        assert( res == 0 );
    }

    if ( var_getProfileSession )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getProfileSession,
            var_getProfileSession
        );

        assert( res == 0 );
    }

    if ( var_profileFrames )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_profileFrames,
            var_profileFrames
        );

        assert( res == 0 );
    }

    if ( var__doProfiledFrames )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__doProfiledFrames,
            var__doProfiledFrames
        );

        assert( res == 0 );
    }

    if ( var_getProfileFrames )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getProfileFrames,
            var_getProfileFrames
        );

        assert( res == 0 );
    }

    if ( var_getProfileFramesSV )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getProfileFramesSV,
            var_getProfileFramesSV
        );

        assert( res == 0 );
    }

    if ( var_setProfileFrames )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_setProfileFrames,
            var_setProfileFrames
        );

        assert( res == 0 );
    }

    if ( var_getProfileTasks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getProfileTasks,
            var_getProfileTasks
        );

        assert( res == 0 );
    }

    if ( var_getProfileTasksSV )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_getProfileTasksSV,
            var_getProfileTasksSV
        );

        assert( res == 0 );
    }

    if ( var_setProfileTasks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_setProfileTasks,
            var_setProfileTasks
        );

        assert( res == 0 );
    }

    if ( var_logTaskProfiles )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_logTaskProfiles,
            var_logTaskProfiles
        );

        assert( res == 0 );
    }

    if ( var_flushTaskProfiles )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_flushTaskProfiles,
            var_flushTaskProfiles
        );

        assert( res == 0 );
    }

    if ( var__setProfileTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__setProfileTask,
            var__setProfileTask
        );

        assert( res == 0 );
    }

    if ( var__profileTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__profileTask,
            var__profileTask
        );

        assert( res == 0 );
    }

    if ( var__hasProfiledDesignatedTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__hasProfiledDesignatedTask,
            var__hasProfiledDesignatedTask
        );

        assert( res == 0 );
    }

    if ( var__getLastTaskProfileSession )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__getLastTaskProfileSession,
            var__getLastTaskProfileSession
        );

        assert( res == 0 );
    }

    if ( var__getRandomTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__getRandomTask,
            var__getRandomTask
        );

        assert( res == 0 );
    }

    if ( var___repr__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___repr__,
            var___repr__
        );

        assert( res == 0 );
    }

    if ( var_doYield )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_doYield,
            var_doYield
        );

        assert( res == 0 );
    }

    if ( var__startTrackingMemLeaks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__startTrackingMemLeaks,
            var__startTrackingMemLeaks
        );

        assert( res == 0 );
    }

    if ( var__stopTrackingMemLeaks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__stopTrackingMemLeaks,
            var__stopTrackingMemLeaks
        );

        assert( res == 0 );
    }

    if ( var__checkMemLeaks )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__checkMemLeaks,
            var__checkMemLeaks
        );

        assert( res == 0 );
    }

    if ( var__runTests )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__runTests,
            var__runTests
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var_notify );
    Py_DECREF( var_notify );
    var_notify = NULL;

    CHECK_OBJECT( (PyObject *)var_taskTimerVerbose );
    Py_DECREF( var_taskTimerVerbose );
    var_taskTimerVerbose = NULL;

    CHECK_OBJECT( (PyObject *)var_extendedExceptions );
    Py_DECREF( var_extendedExceptions );
    var_extendedExceptions = NULL;

    CHECK_OBJECT( (PyObject *)var_pStatsTasks );
    Py_DECREF( var_pStatsTasks );
    var_pStatsTasks = NULL;

    CHECK_OBJECT( (PyObject *)var_MaxEpochSpeed );
    Py_DECREF( var_MaxEpochSpeed );
    var_MaxEpochSpeed = NULL;

    CHECK_OBJECT( (PyObject *)var___init__ );
    Py_DECREF( var___init__ );
    var___init__ = NULL;

    CHECK_OBJECT( (PyObject *)var_finalInit );
    Py_DECREF( var_finalInit );
    var_finalInit = NULL;

    CHECK_OBJECT( (PyObject *)var_destroy );
    Py_DECREF( var_destroy );
    var_destroy = NULL;

    CHECK_OBJECT( (PyObject *)var_setClock );
    Py_DECREF( var_setClock );
    var_setClock = NULL;

    CHECK_OBJECT( (PyObject *)var_clock );
    Py_DECREF( var_clock );
    var_clock = NULL;

    CHECK_OBJECT( (PyObject *)var_invokeDefaultHandler );
    Py_DECREF( var_invokeDefaultHandler );
    var_invokeDefaultHandler = NULL;

    CHECK_OBJECT( (PyObject *)var_keyboardInterruptHandler );
    Py_DECREF( var_keyboardInterruptHandler );
    var_keyboardInterruptHandler = NULL;

    CHECK_OBJECT( (PyObject *)var_getCurrentTask );
    Py_DECREF( var_getCurrentTask );
    var_getCurrentTask = NULL;

    CHECK_OBJECT( (PyObject *)var_hasTaskChain );
    Py_DECREF( var_hasTaskChain );
    var_hasTaskChain = NULL;

    CHECK_OBJECT( (PyObject *)var_setupTaskChain );
    Py_DECREF( var_setupTaskChain );
    var_setupTaskChain = NULL;

    CHECK_OBJECT( (PyObject *)var_hasTaskNamed );
    Py_DECREF( var_hasTaskNamed );
    var_hasTaskNamed = NULL;

    CHECK_OBJECT( (PyObject *)var_getTasksNamed );
    Py_DECREF( var_getTasksNamed );
    var_getTasksNamed = NULL;

    CHECK_OBJECT( (PyObject *)var_getTasksMatching );
    Py_DECREF( var_getTasksMatching );
    var_getTasksMatching = NULL;

    CHECK_OBJECT( (PyObject *)var_getAllTasks );
    Py_DECREF( var_getAllTasks );
    var_getAllTasks = NULL;

    CHECK_OBJECT( (PyObject *)var_getTasks );
    Py_DECREF( var_getTasks );
    var_getTasks = NULL;

    CHECK_OBJECT( (PyObject *)var_getDoLaters );
    Py_DECREF( var_getDoLaters );
    var_getDoLaters = NULL;

    CHECK_OBJECT( (PyObject *)var__TaskManager__makeTaskList );
    Py_DECREF( var__TaskManager__makeTaskList );
    var__TaskManager__makeTaskList = NULL;

    CHECK_OBJECT( (PyObject *)var_doMethodLater );
    Py_DECREF( var_doMethodLater );
    var_doMethodLater = NULL;

    CHECK_OBJECT( (PyObject *)var_do_method_later );
    Py_DECREF( var_do_method_later );
    var_do_method_later = NULL;

    CHECK_OBJECT( (PyObject *)var_add );
    Py_DECREF( var_add );
    var_add = NULL;

    CHECK_OBJECT( (PyObject *)var__TaskManager__setupTask );
    Py_DECREF( var__TaskManager__setupTask );
    var__TaskManager__setupTask = NULL;

    CHECK_OBJECT( (PyObject *)var_remove );
    Py_DECREF( var_remove );
    var_remove = NULL;

    CHECK_OBJECT( (PyObject *)var_removeTasksMatching );
    Py_DECREF( var_removeTasksMatching );
    var_removeTasksMatching = NULL;

    CHECK_OBJECT( (PyObject *)var_step );
    Py_DECREF( var_step );
    var_step = NULL;

    CHECK_OBJECT( (PyObject *)var_run );
    Py_DECREF( var_run );
    var_run = NULL;

    CHECK_OBJECT( (PyObject *)var__unpackIOError );
    Py_DECREF( var__unpackIOError );
    var__unpackIOError = NULL;

    CHECK_OBJECT( (PyObject *)var_stop );
    Py_DECREF( var_stop );
    var_stop = NULL;

    CHECK_OBJECT( (PyObject *)var__TaskManager__tryReplaceTaskMethod );
    Py_DECREF( var__TaskManager__tryReplaceTaskMethod );
    var__TaskManager__tryReplaceTaskMethod = NULL;

    CHECK_OBJECT( (PyObject *)var_replaceMethod );
    Py_DECREF( var_replaceMethod );
    var_replaceMethod = NULL;

    CHECK_OBJECT( (PyObject *)var_popupControls );
    Py_DECREF( var_popupControls );
    var_popupControls = NULL;

    CHECK_OBJECT( (PyObject *)var_getProfileSession );
    Py_DECREF( var_getProfileSession );
    var_getProfileSession = NULL;

    CHECK_OBJECT( (PyObject *)var_profileFrames );
    Py_DECREF( var_profileFrames );
    var_profileFrames = NULL;

    CHECK_OBJECT( (PyObject *)var__doProfiledFrames );
    Py_DECREF( var__doProfiledFrames );
    var__doProfiledFrames = NULL;

    CHECK_OBJECT( (PyObject *)var_getProfileFrames );
    Py_DECREF( var_getProfileFrames );
    var_getProfileFrames = NULL;

    CHECK_OBJECT( (PyObject *)var_getProfileFramesSV );
    Py_DECREF( var_getProfileFramesSV );
    var_getProfileFramesSV = NULL;

    CHECK_OBJECT( (PyObject *)var_setProfileFrames );
    Py_DECREF( var_setProfileFrames );
    var_setProfileFrames = NULL;

    CHECK_OBJECT( (PyObject *)var_getProfileTasks );
    Py_DECREF( var_getProfileTasks );
    var_getProfileTasks = NULL;

    CHECK_OBJECT( (PyObject *)var_getProfileTasksSV );
    Py_DECREF( var_getProfileTasksSV );
    var_getProfileTasksSV = NULL;

    CHECK_OBJECT( (PyObject *)var_setProfileTasks );
    Py_DECREF( var_setProfileTasks );
    var_setProfileTasks = NULL;

    CHECK_OBJECT( (PyObject *)var_logTaskProfiles );
    Py_DECREF( var_logTaskProfiles );
    var_logTaskProfiles = NULL;

    CHECK_OBJECT( (PyObject *)var_flushTaskProfiles );
    Py_DECREF( var_flushTaskProfiles );
    var_flushTaskProfiles = NULL;

    CHECK_OBJECT( (PyObject *)var__setProfileTask );
    Py_DECREF( var__setProfileTask );
    var__setProfileTask = NULL;

    CHECK_OBJECT( (PyObject *)var__profileTask );
    Py_DECREF( var__profileTask );
    var__profileTask = NULL;

    CHECK_OBJECT( (PyObject *)var__hasProfiledDesignatedTask );
    Py_DECREF( var__hasProfiledDesignatedTask );
    var__hasProfiledDesignatedTask = NULL;

    CHECK_OBJECT( (PyObject *)var__getLastTaskProfileSession );
    Py_DECREF( var__getLastTaskProfileSession );
    var__getLastTaskProfileSession = NULL;

    CHECK_OBJECT( (PyObject *)var__getRandomTask );
    Py_DECREF( var__getRandomTask );
    var__getRandomTask = NULL;

    CHECK_OBJECT( (PyObject *)var___repr__ );
    Py_DECREF( var___repr__ );
    var___repr__ = NULL;

    CHECK_OBJECT( (PyObject *)var_doYield );
    Py_DECREF( var_doYield );
    var_doYield = NULL;

    CHECK_OBJECT( (PyObject *)var__startTrackingMemLeaks );
    Py_DECREF( var__startTrackingMemLeaks );
    var__startTrackingMemLeaks = NULL;

    CHECK_OBJECT( (PyObject *)var__stopTrackingMemLeaks );
    Py_DECREF( var__stopTrackingMemLeaks );
    var__stopTrackingMemLeaks = NULL;

    CHECK_OBJECT( (PyObject *)var__checkMemLeaks );
    Py_DECREF( var__checkMemLeaks );
    var__checkMemLeaks = NULL;

    CHECK_OBJECT( (PyObject *)var__runTests );
    Py_DECREF( var__runTests );
    var__runTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    Py_XDECREF( var_notify );
    var_notify = NULL;

    Py_XDECREF( var_taskTimerVerbose );
    var_taskTimerVerbose = NULL;

    Py_XDECREF( var_extendedExceptions );
    var_extendedExceptions = NULL;

    Py_XDECREF( var_pStatsTasks );
    var_pStatsTasks = NULL;

    Py_XDECREF( var_MaxEpochSpeed );
    var_MaxEpochSpeed = NULL;

    Py_XDECREF( var___init__ );
    var___init__ = NULL;

    Py_XDECREF( var_finalInit );
    var_finalInit = NULL;

    Py_XDECREF( var_destroy );
    var_destroy = NULL;

    Py_XDECREF( var_setClock );
    var_setClock = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_1___init__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_name_3;
    PyObject *tmp_assattr_name_4;
    PyObject *tmp_assattr_name_5;
    PyObject *tmp_assattr_name_6;
    PyObject *tmp_assattr_name_7;
    PyObject *tmp_assattr_name_8;
    PyObject *tmp_assattr_name_9;
    PyObject *tmp_assattr_name_10;
    PyObject *tmp_assattr_name_11;
    PyObject *tmp_assattr_name_12;
    PyObject *tmp_assattr_name_13;
    PyObject *tmp_assattr_name_14;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assattr_target_3;
    PyObject *tmp_assattr_target_4;
    PyObject *tmp_assattr_target_5;
    PyObject *tmp_assattr_target_6;
    PyObject *tmp_assattr_target_7;
    PyObject *tmp_assattr_target_8;
    PyObject *tmp_assattr_target_9;
    PyObject *tmp_assattr_target_10;
    PyObject *tmp_assattr_target_11;
    PyObject *tmp_assattr_target_12;
    PyObject *tmp_assattr_target_13;
    PyObject *tmp_assattr_target_14;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_kw_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_40a5f03b51982b2c81249b0ebbb114e8, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTaskManager );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTaskManager );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AsyncTaskManager" );
        exception_tb = NULL;

        exception_lineno = 112;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 112;
    tmp_assattr_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getGlobalPtr );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 112;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_mgr, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 112;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_assattr_name_2 = Py_None;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_resumeFunc, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 114;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 115;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 115;
    tmp_assattr_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getClock );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assattr_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 115;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_3 = par_self;

    CHECK_OBJECT( tmp_assattr_target_3 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_3, const_str_plain_globalClock, tmp_assattr_name_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_3 );

        exception_lineno = 115;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_3 );
    tmp_assattr_name_4 = Py_False;
    tmp_assattr_target_4 = par_self;

    CHECK_OBJECT( tmp_assattr_target_4 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_4, const_str_plain_stepping, tmp_assattr_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 116;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_5 = Py_False;
    tmp_assattr_target_5 = par_self;

    CHECK_OBJECT( tmp_assattr_target_5 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_5, const_str_plain_running, tmp_assattr_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_6 = Py_False;
    tmp_assattr_target_6 = par_self;

    CHECK_OBJECT( tmp_assattr_target_6 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_6, const_str_plain_destroyed, tmp_assattr_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_7 = Py_False;
    tmp_assattr_target_7 = par_self;

    CHECK_OBJECT( tmp_assattr_target_7 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_7, const_str_plain_fKeyboardInterrupt, tmp_assattr_name_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 119;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_8 = const_int_0;
    tmp_assattr_target_8 = par_self;

    CHECK_OBJECT( tmp_assattr_target_8 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_8, const_str_plain_interruptCount, tmp_assattr_name_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 120;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Queue );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Queue );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Queue" );
        exception_tb = NULL;

        exception_lineno = 122;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 122;
    tmp_assattr_name_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assattr_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 122;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_9 = par_self;

    CHECK_OBJECT( tmp_assattr_target_9 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_9, const_str_plain__frameProfileQueue, tmp_assattr_name_9 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_9 );

        exception_lineno = 122;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_9 );
    tmp_assattr_name_10 = Py_None;
    tmp_assattr_target_10 = par_self;

    CHECK_OBJECT( tmp_assattr_target_10 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_10, const_str_plain__profileFrames, tmp_assattr_name_10 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 125;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_11 = Py_None;
    tmp_assattr_target_11 = par_self;

    CHECK_OBJECT( tmp_assattr_target_11 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_11, const_str_plain__frameProfiler, tmp_assattr_name_11 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_12 = Py_None;
    tmp_assattr_target_12 = par_self;

    CHECK_OBJECT( tmp_assattr_target_12 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_12, const_str_plain__profileTasks, tmp_assattr_name_12 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 127;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_13 = Py_None;
    tmp_assattr_target_13 = par_self;

    CHECK_OBJECT( tmp_assattr_target_13 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_13, const_str_plain__taskProfiler, tmp_assattr_name_13 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 128;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ScratchPad );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ScratchPad );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ScratchPad" );
        exception_tb = NULL;

        exception_lineno = 129;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = PyDict_Copy( const_dict_11985c3a65ec78b97ae15d2d308b1395 );
    frame_function->m_frame.f_lineno = 129;
    tmp_assattr_name_14 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_2, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assattr_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 129;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_14 = par_self;

    CHECK_OBJECT( tmp_assattr_target_14 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_14, const_str_plain__taskProfileInfo, tmp_assattr_name_14 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_14 );

        exception_lineno = 129;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_14 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_1___init__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_1___init__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_StateVar = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_100b97301f56e3452f5e62ef4be52d02, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_85bc21db0baeb246688676279324da7c;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_StateVar_tuple;
    frame_function->m_frame.f_lineno = 138;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_StateVar );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_StateVar == NULL );
    var_StateVar = tmp_assign_source_1;

    tmp_called_name_1 = var_StateVar;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_function->m_frame.f_lineno = 139;
    tmp_assattr_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, &PyTuple_GET_ITEM( const_tuple_false_tuple, 0 ) );

    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 139;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__profileTasks, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 139;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setProfileTasks );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 140;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ConfigVariableBool" );
        exception_tb = NULL;

        exception_lineno = 140;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 140;
    tmp_called_instance_1 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, &PyTuple_GET_ITEM( const_tuple_str_digest_98168731f04cfeb6639ad5bd1477be10_int_0_tuple, 0 ) );

    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 140;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 140;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getValue );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 140;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 140;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 140;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_4 = var_StateVar;

    CHECK_OBJECT( tmp_called_name_4 );
    frame_function->m_frame.f_lineno = 141;
    tmp_assattr_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_false_tuple, 0 ) );

    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 141;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__profileFrames, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 141;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_setProfileFrames );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ConfigVariableBool );
    }

    if ( tmp_called_name_6 == NULL )
    {
        Py_DECREF( tmp_called_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ConfigVariableBool" );
        exception_tb = NULL;

        exception_lineno = 142;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 142;
    tmp_called_instance_2 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_str_digest_692d590b076085f41291e6af4c948d56_int_0_tuple, 0 ) );

    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 142;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 142;
    tmp_args_element_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getValue );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 142;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 142;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 142;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_StateVar );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_StateVar );
    Py_DECREF( var_StateVar );
    var_StateVar = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_StateVar );
    var_StateVar = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_3_destroy( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_57a043910180f24d10c601e798c7cb9d, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_False;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_running, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 146;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_notify );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 147;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_info, &PyTuple_GET_ITEM( const_tuple_str_digest_70e66c98789b7a7a51a96af6654254e5_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_2 = Py_True;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_destroyed, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__frameProfileQueue );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 149;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_clear );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_mgr );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 150;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_cleanup );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_3_destroy );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_3_destroy );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_4_setClock( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_clockObject = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_called_instance_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_792970ddc7a8d0bdaa6eddaf7d3146a8, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_clockObject;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 153;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_setClock, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = par_clockObject;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_globalClock, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 154;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_clockObject );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_4_setClock );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_clockObject );
    Py_DECREF( par_clockObject );
    par_clockObject = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_clockObject );
    Py_DECREF( par_clockObject );
    par_clockObject = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_4_setClock );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_5_lambda( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8c34676ca982b726e4c254dfc7ce4764, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 156;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getClock );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 156;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_5_lambda );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_5_lambda );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_signalNumber = python_pars[ 1 ];
    PyObject *par_stackFrame = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_c2379bdea82fc3b87246bcfc906c98bf, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_79748cc9eb11364c994f6b8db15b4c23;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 161;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 161;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_signal );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SIGINT );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_default_int_handler );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 162;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 162;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_raise_type_1 = PyExc_KeyboardInterrupt;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 164;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooo";
    goto frame_exception_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_signalNumber, par_stackFrame );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler );
    return NULL;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_signalNumber );
    Py_DECREF( par_signalNumber );
    par_signalNumber = NULL;

    CHECK_OBJECT( (PyObject *)par_stackFrame );
    Py_DECREF( par_stackFrame );
    par_stackFrame = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_signalNumber = python_pars[ 1 ];
    PyObject *par_stackFrame = python_pars[ 2 ];
    PyObject *tmp_inplace_assign_attr_1__start = NULL;
    PyObject *tmp_inplace_assign_attr_1__end = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    bool tmp_isnot_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_print_value;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_65bae77f21e88e99debd37895a7b8890, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = const_int_pos_1;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_fKeyboardInterrupt, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 167;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assign_source_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_interruptCount );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 168;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_inplace_assign_attr_1__start == NULL );
    tmp_inplace_assign_attr_1__start = tmp_assign_source_1;

    // Tried code:
    tmp_left_name_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_left_name_1 );
    tmp_right_name_1 = const_int_pos_1;
    tmp_assign_source_2 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 168;
        type_description = "ooo";
        goto try_except_handler_2;
    }
    assert( tmp_inplace_assign_attr_1__end == NULL );
    tmp_inplace_assign_attr_1__end = tmp_assign_source_2;

    // Tried code:
    tmp_compare_left_1 = tmp_inplace_assign_attr_1__start;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assattr_name_2 = tmp_inplace_assign_attr_1__end;

    CHECK_OBJECT( tmp_assattr_name_2 );
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_interruptCount, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 168;
        type_description = "ooo";
        goto try_except_handler_3;
    }
    branch_no_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__end );
    Py_DECREF( tmp_inplace_assign_attr_1__end );
    tmp_inplace_assign_attr_1__end = NULL;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_attr_1__start );
    Py_DECREF( tmp_inplace_assign_attr_1__start );
    tmp_inplace_assign_attr_1__start = NULL;

    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_interruptCount );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 169;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 169;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_print_value = const_str_digest_b3e9cae2fecef7b6d609daf4a6baba31;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 170;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_compare_left_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_interruptCount );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_int_pos_2;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 171;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_print_value = const_str_digest_feb617e995cb09fff64cd1ad38571b3f;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 172;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_signal );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_5 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_SIGINT );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_invokeDefaultHandler );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 175;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 175;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_signalNumber, par_stackFrame );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_signalNumber );
    Py_DECREF( par_signalNumber );
    par_signalNumber = NULL;

    CHECK_OBJECT( (PyObject *)par_stackFrame );
    Py_DECREF( par_stackFrame );
    par_stackFrame = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_signalNumber );
    Py_DECREF( par_signalNumber );
    par_signalNumber = NULL;

    CHECK_OBJECT( (PyObject *)par_stackFrame );
    Py_DECREF( par_stackFrame );
    par_stackFrame = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f80fe5d8c84d87c6fbd950532e6b3f57, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Thread );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Thread );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Thread" );
        exception_tb = NULL;

        exception_lineno = 181;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 181;
    tmp_called_instance_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getCurrentThread );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 181;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 181;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getCurrentTask );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 181;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_chainName = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_02957f44bd44983c583328d986a2cd95, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 191;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_chainName;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 191;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_compexpr_left_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findTaskChain, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 191;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = Py_None;
    tmp_return_value = RICH_COMPARE_NE( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 191;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_chainName );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chainName );
    Py_DECREF( par_chainName );
    par_chainName = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chainName );
    Py_DECREF( par_chainName );
    par_chainName = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_chainName = python_pars[ 1 ];
    PyObject *par_numThreads = python_pars[ 2 ];
    PyObject *par_tickClock = python_pars[ 3 ];
    PyObject *par_threadPriority = python_pars[ 4 ];
    PyObject *par_frameBudget = python_pars[ 5 ];
    PyObject *par_frameSync = python_pars[ 6 ];
    PyObject *par_timeslicePriority = python_pars[ 7 ];
    PyObject *var_chain = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    bool tmp_isnot_3;
    bool tmp_isnot_4;
    bool tmp_isnot_5;
    bool tmp_isnot_6;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b0511af086dd0631243d38f48437a299, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 245;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_chainName;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 245;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_makeTaskChain, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 245;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_chain == NULL );
    var_chain = tmp_assign_source_1;

    tmp_compare_left_1 = par_numThreads;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_1 != tmp_compare_right_1 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = var_chain;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = par_numThreads;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 247;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setNumThreads, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 247;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_compare_left_2 = par_tickClock;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_3 = var_chain;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_3 = par_tickClock;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 249;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setTickClock, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_compare_left_3 = par_threadPriority;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_None;
    tmp_isnot_3 = ( tmp_compare_left_3 != tmp_compare_right_3 );
    if ( tmp_isnot_3 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_instance_4 = var_chain;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_4 = par_threadPriority;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 251;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_setThreadPriority, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_3:;
    tmp_compare_left_4 = par_frameBudget;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = Py_None;
    tmp_isnot_4 = ( tmp_compare_left_4 != tmp_compare_right_4 );
    if ( tmp_isnot_4 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_instance_5 = var_chain;

    CHECK_OBJECT( tmp_called_instance_5 );
    tmp_args_element_name_5 = par_frameBudget;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 253;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_setFrameBudget, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 253;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_4:;
    tmp_compare_left_5 = par_frameSync;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = Py_None;
    tmp_isnot_5 = ( tmp_compare_left_5 != tmp_compare_right_5 );
    if ( tmp_isnot_5 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_called_instance_6 = var_chain;

    CHECK_OBJECT( tmp_called_instance_6 );
    tmp_args_element_name_6 = par_frameSync;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 255;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_setFrameSync, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 255;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    tmp_compare_left_6 = par_timeslicePriority;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = Py_None;
    tmp_isnot_6 = ( tmp_compare_left_6 != tmp_compare_right_6 );
    if ( tmp_isnot_6 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_instance_7 = var_chain;

    CHECK_OBJECT( tmp_called_instance_7 );
    tmp_args_element_name_7 = par_timeslicePriority;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 257;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_setTimeslicePriority, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 257;
        type_description = "ooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_chainName, par_numThreads, par_tickClock, par_threadPriority, par_frameBudget, par_frameSync, par_timeslicePriority, var_chain );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chainName );
    Py_DECREF( par_chainName );
    par_chainName = NULL;

    CHECK_OBJECT( (PyObject *)par_numThreads );
    Py_DECREF( par_numThreads );
    par_numThreads = NULL;

    CHECK_OBJECT( (PyObject *)par_tickClock );
    Py_DECREF( par_tickClock );
    par_tickClock = NULL;

    CHECK_OBJECT( (PyObject *)par_threadPriority );
    Py_DECREF( par_threadPriority );
    par_threadPriority = NULL;

    CHECK_OBJECT( (PyObject *)par_frameBudget );
    Py_DECREF( par_frameBudget );
    par_frameBudget = NULL;

    CHECK_OBJECT( (PyObject *)par_frameSync );
    Py_DECREF( par_frameSync );
    par_frameSync = NULL;

    CHECK_OBJECT( (PyObject *)par_timeslicePriority );
    Py_DECREF( par_timeslicePriority );
    par_timeslicePriority = NULL;

    CHECK_OBJECT( (PyObject *)var_chain );
    Py_DECREF( var_chain );
    var_chain = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_chainName );
    Py_DECREF( par_chainName );
    par_chainName = NULL;

    CHECK_OBJECT( (PyObject *)par_numThreads );
    Py_DECREF( par_numThreads );
    par_numThreads = NULL;

    CHECK_OBJECT( (PyObject *)par_tickClock );
    Py_DECREF( par_tickClock );
    par_tickClock = NULL;

    CHECK_OBJECT( (PyObject *)par_threadPriority );
    Py_DECREF( par_threadPriority );
    par_threadPriority = NULL;

    CHECK_OBJECT( (PyObject *)par_frameBudget );
    Py_DECREF( par_frameBudget );
    par_frameBudget = NULL;

    CHECK_OBJECT( (PyObject *)par_frameSync );
    Py_DECREF( par_frameSync );
    par_frameSync = NULL;

    CHECK_OBJECT( (PyObject *)par_timeslicePriority );
    Py_DECREF( par_timeslicePriority );
    par_timeslicePriority = NULL;

    Py_XDECREF( var_chain );
    var_chain = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskName = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_bool_arg_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_860dbd981425fc7d6911219b7968a371, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_taskName;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 263;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_bool_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findTask, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_bool_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_return_value = TO_BOOL( tmp_bool_arg_1 );
    Py_DECREF( tmp_bool_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskName );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskName );
    Py_DECREF( par_taskName );
    par_taskName = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskName );
    Py_DECREF( par_taskName );
    par_taskName = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskName = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_52b4ef6bb6cf369ffc641db2e5bed903, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__TaskManager__makeTaskList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 268;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = par_taskName;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 268;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findTasks, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 268;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 268;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskName );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskName );
    Py_DECREF( par_taskName );
    par_taskName = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskName );
    Py_DECREF( par_taskName );
    par_taskName = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskPattern = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_088bf2142fffa6737970b898cd57c2ef, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__TaskManager__makeTaskList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_mgr );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_findTasksMatching );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_GlobPattern );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GlobPattern );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GlobPattern" );
        exception_tb = NULL;

        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = par_taskPattern;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 275;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 275;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 275;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskPattern );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskPattern );
    Py_DECREF( par_taskPattern );
    par_taskPattern = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskPattern );
    Py_DECREF( par_taskPattern );
    par_taskPattern = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_95ca09c6dabb993508688977ed1f28f8, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__TaskManager__makeTaskList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 280;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 280;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getTasks );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 280;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 280;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 280;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f012b734e998e4843f1c83a41b919e26, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__TaskManager__makeTaskList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 284;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 284;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getActiveTasks );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 284;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 284;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_160465e968dea0bb99ee34e50350b838, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__TaskManager__makeTaskList );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 288;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 288;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getSleepingTasks );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 288;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 288;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskCollection = python_pars[ 1 ];
    PyObject *var_l = NULL;
    PyObject *var_i = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_l == NULL );
    var_l = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_783b5de3b90c55d3d1dec390be52f8c3, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_taskCollection;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 292;
    tmp_range_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getNumTasks );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooo";
            frame_function->m_frame.f_lineno = 292;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_4;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_l;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_called_instance_2 = par_taskCollection;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = var_i;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 293;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getTask, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 293;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 293;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskCollection, var_l, var_i );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_l;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskCollection );
    Py_DECREF( par_taskCollection );
    par_taskCollection = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskCollection );
    Py_DECREF( par_taskCollection );
    par_taskCollection = NULL;

    CHECK_OBJECT( (PyObject *)var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_delayTime = python_pars[ 1 ];
    PyObject *par_funcOrTask = python_pars[ 2 ];
    PyObject *par_name = python_pars[ 3 ];
    PyObject *par_extraArgs = python_pars[ 4 ];
    PyObject *par_sort = python_pars[ 5 ];
    PyObject *par_priority = python_pars[ 6 ];
    PyObject *par_taskChain = python_pars[ 7 ];
    PyObject *par_uponDeath = python_pars[ 8 ];
    PyObject *par_appendTask = python_pars[ 9 ];
    PyObject *par_owner = python_pars[ 10 ];
    PyObject *var_task = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_20362686021c7e20ed2fb06d919d0022, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_1 = par_delayTime;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 312;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_notify );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_warning );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_366c6ab541682202d2ba4e1cfb8a21d8;
    tmp_right_name_1 = PyTuple_New( 2 );
    tmp_tuple_element_1 = par_name;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_delayTime;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_1, 1, tmp_tuple_element_1 );
    tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 313;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 313;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_cond_value_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 313;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 313;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 313;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    branch_no_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = par_funcOrTask;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_name;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_priority;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_sort;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_extraArgs;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = par_taskChain;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = par_appendTask;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = par_owner;

    CHECK_OBJECT( tmp_args_element_name_9 );
    tmp_args_element_name_10 = par_uponDeath;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 315;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS9( tmp_called_instance_1, const_str_plain__TaskManager__setupTask, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_task == NULL );
    var_task = tmp_assign_source_1;

    tmp_called_instance_2 = var_task;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_11 = par_delayTime;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_function->m_frame.f_lineno = 316;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setDelay, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_mgr );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_12 = var_task;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_function->m_frame.f_lineno = 317;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_add, call_args );
    }

    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description = "oooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_delayTime, par_funcOrTask, par_name, par_extraArgs, par_sort, par_priority, par_taskChain, par_uponDeath, par_appendTask, par_owner, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_task;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_delayTime );
    Py_DECREF( par_delayTime );
    par_delayTime = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_extraArgs );
    Py_DECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    CHECK_OBJECT( (PyObject *)par_appendTask );
    Py_DECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    CHECK_OBJECT( (PyObject *)var_task );
    Py_DECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_delayTime );
    Py_DECREF( par_delayTime );
    par_delayTime = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_extraArgs );
    Py_DECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    CHECK_OBJECT( (PyObject *)par_appendTask );
    Py_DECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_19_add( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_funcOrTask = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_sort = python_pars[ 3 ];
    PyObject *par_extraArgs = python_pars[ 4 ];
    PyObject *par_priority = python_pars[ 5 ];
    PyObject *par_uponDeath = python_pars[ 6 ];
    PyObject *par_appendTask = python_pars[ 7 ];
    PyObject *par_taskChain = python_pars[ 8 ];
    PyObject *par_owner = python_pars[ 9 ];
    PyObject *var_task = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_26ff3b2c3e3551d25329e13e5138e1cb, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_funcOrTask;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_name;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_priority;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_sort;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_extraArgs;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_taskChain;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = par_appendTask;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_args_element_name_8 = par_owner;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = par_uponDeath;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 379;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS9( tmp_called_instance_1, const_str_plain__TaskManager__setupTask, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 379;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_task == NULL );
    var_task = tmp_assign_source_1;

    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 380;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_10 = var_task;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 380;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_add, call_args );
    }

    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 380;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_funcOrTask, par_name, par_sort, par_extraArgs, par_priority, par_uponDeath, par_appendTask, par_taskChain, par_owner, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_task;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_19_add );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    CHECK_OBJECT( (PyObject *)par_extraArgs );
    Py_DECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    CHECK_OBJECT( (PyObject *)par_appendTask );
    Py_DECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    CHECK_OBJECT( (PyObject *)var_task );
    Py_DECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    CHECK_OBJECT( (PyObject *)par_extraArgs );
    Py_DECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    CHECK_OBJECT( (PyObject *)par_appendTask );
    Py_DECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_19_add );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_funcOrTask = python_pars[ 1 ];
    PyObject *par_name = python_pars[ 2 ];
    PyObject *par_priority = python_pars[ 3 ];
    PyObject *par_sort = python_pars[ 4 ];
    PyObject *par_extraArgs = python_pars[ 5 ];
    PyObject *par_taskChain = python_pars[ 6 ];
    PyObject *par_appendTask = python_pars[ 7 ];
    PyObject *par_owner = python_pars[ 8 ];
    PyObject *par_uponDeath = python_pars[ 9 ];
    PyObject *var_task = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_hasattr_attr_1;
    PyObject *tmp_hasattr_attr_2;
    PyObject *tmp_hasattr_source_1;
    PyObject *tmp_hasattr_source_2;
    bool tmp_is_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    bool tmp_isnot_1;
    bool tmp_isnot_2;
    bool tmp_isnot_3;
    bool tmp_isnot_4;
    bool tmp_isnot_5;
    bool tmp_isnot_6;
    bool tmp_isnot_7;
    PyObject *tmp_left_name_1;
    PyObject *tmp_operand_name_1;
    PyObject *tmp_raise_type_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_189ada8fa1f5a86a1eee23463063c5a4, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_funcOrTask;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 384;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 384;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = par_funcOrTask;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( var_task == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_task = tmp_assign_source_1;

    goto branch_end_1;
    branch_no_1:;
    tmp_hasattr_source_1 = par_funcOrTask;

    CHECK_OBJECT( tmp_hasattr_source_1 );
    tmp_hasattr_attr_1 = const_str_plain___call__;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_1, tmp_hasattr_attr_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 386;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_PythonTask );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonTask );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PythonTask" );
        exception_tb = NULL;

        exception_lineno = 387;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_funcOrTask;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 387;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 387;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_task == NULL );
    var_task = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_notify );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 389;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_error, &PyTuple_GET_ITEM( const_tuple_str_digest_4b971f3632718df8bdf7fc2cb7d90521_tuple, 0 ) );

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;
    branch_end_1:;
    tmp_hasattr_source_2 = var_task;

    if ( tmp_hasattr_source_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 392;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_hasattr_attr_2 = const_str_plain_setArgs;
    tmp_res = PyObject_HasAttr( tmp_hasattr_source_2, tmp_hasattr_attr_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 392;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_compare_left_1 = par_extraArgs;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_assign_source_3 = PyList_New( 0 );
    {
        PyObject *old = par_extraArgs;
        assert( old != NULL );
        par_extraArgs = tmp_assign_source_3;
        Py_DECREF( old );
    }

    tmp_assign_source_4 = Py_True;
    {
        PyObject *old = par_appendTask;
        assert( old != NULL );
        par_appendTask = tmp_assign_source_4;
        Py_INCREF( par_appendTask );
        Py_DECREF( old );
    }

    branch_no_4:;
    tmp_called_instance_2 = var_task;

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 397;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_extraArgs;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_appendTask;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 397;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_2, const_str_plain_setArgs, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 397;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_compare_left_2 = par_extraArgs;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_isnot_1 = ( tmp_compare_left_2 != tmp_compare_right_2 );
    if ( tmp_isnot_1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_source_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_notify );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 399;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_error );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 399;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_d9c88a80b6ea433ce132c4da5949f74d;
    tmp_operand_name_1 = var_task;

    if ( tmp_operand_name_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 400;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_1 = UNARY_OPERATION( PyObject_Repr, tmp_operand_name_1 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 400;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 400;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 399;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 399;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_5:;
    branch_end_3:;
    tmp_compare_left_3 = par_name;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_None;
    tmp_isnot_2 = ( tmp_compare_left_3 != tmp_compare_right_3 );
    if ( tmp_isnot_2 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_instance_3 = var_task;

    if ( tmp_called_instance_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 403;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = par_name;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 403;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setName, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 403;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    tmp_called_instance_4 = var_task;

    if ( tmp_called_instance_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 404;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 404;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_hasName );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 404;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 404;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 404;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooo";
    goto frame_exception_exit_1;
    branch_no_7:;
    tmp_compexpr_left_1 = par_priority;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_and_left_value_1 = BOOL_FROM( tmp_compexpr_left_1 != tmp_compexpr_right_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    assert( !(tmp_and_left_truth_1 == -1) );
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_compexpr_left_2 = par_sort;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_compexpr_right_2 = Py_None;
    tmp_and_right_value_1 = BOOL_FROM( tmp_compexpr_left_2 == tmp_compexpr_right_2 );
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    assert( !(tmp_cond_truth_2 == -1) );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_called_instance_5 = var_task;

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 409;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = par_priority;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 409;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_5, const_str_plain_setSort, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 409;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_4 = par_priority;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = Py_None;
    tmp_isnot_3 = ( tmp_compare_left_4 != tmp_compare_right_4 );
    if ( tmp_isnot_3 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_called_instance_6 = var_task;

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 412;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = par_priority;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 412;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_setPriority, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 412;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_9:;
    tmp_compare_left_5 = par_sort;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = Py_None;
    tmp_isnot_4 = ( tmp_compare_left_5 != tmp_compare_right_5 );
    if ( tmp_isnot_4 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_called_instance_7 = var_task;

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 414;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = par_sort;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_function->m_frame.f_lineno = 414;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_setSort, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_10:;
    branch_end_8:;
    tmp_compare_left_6 = par_taskChain;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = Py_None;
    tmp_isnot_5 = ( tmp_compare_left_6 != tmp_compare_right_6 );
    if ( tmp_isnot_5 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_called_instance_8 = var_task;

    if ( tmp_called_instance_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 417;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = par_taskChain;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 417;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_setTaskChain, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 417;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_11:;
    tmp_compare_left_7 = par_owner;

    CHECK_OBJECT( tmp_compare_left_7 );
    tmp_compare_right_7 = Py_None;
    tmp_isnot_6 = ( tmp_compare_left_7 != tmp_compare_right_7 );
    if ( tmp_isnot_6 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_called_instance_9 = var_task;

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 420;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = par_owner;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 420;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_setOwner, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 420;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_12:;
    tmp_compare_left_8 = par_uponDeath;

    CHECK_OBJECT( tmp_compare_left_8 );
    tmp_compare_right_8 = Py_None;
    tmp_isnot_7 = ( tmp_compare_left_8 != tmp_compare_right_8 );
    if ( tmp_isnot_7 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_called_instance_10 = var_task;

    if ( tmp_called_instance_10 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 423;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = par_uponDeath;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_function->m_frame.f_lineno = 423;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_10, const_str_plain_setUponDeath, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    tmp_return_value = var_task;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 425;
        type_description = "ooooooooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_funcOrTask, par_name, par_priority, par_sort, par_extraArgs, par_taskChain, par_appendTask, par_owner, par_uponDeath, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    Py_XDECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    Py_XDECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_funcOrTask );
    Py_DECREF( par_funcOrTask );
    par_funcOrTask = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_priority );
    Py_DECREF( par_priority );
    par_priority = NULL;

    CHECK_OBJECT( (PyObject *)par_sort );
    Py_DECREF( par_sort );
    par_sort = NULL;

    Py_XDECREF( par_extraArgs );
    par_extraArgs = NULL;

    CHECK_OBJECT( (PyObject *)par_taskChain );
    Py_DECREF( par_taskChain );
    par_taskChain = NULL;

    Py_XDECREF( par_appendTask );
    par_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)par_owner );
    Py_DECREF( par_owner );
    par_owner = NULL;

    CHECK_OBJECT( (PyObject *)par_uponDeath );
    Py_DECREF( par_uponDeath );
    par_uponDeath = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_21_remove( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskOrName = python_pars[ 1 ];
    PyObject *var_task = NULL;
    PyObject *var_tasks = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_cls_2;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_isinstance_inst_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_34fde79ef14e6d7b87a91b80e98450eb, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_taskOrName;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 436;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 436;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 437;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_taskOrName;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 437;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_remove, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 437;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_isinstance_inst_2 = par_taskOrName;

    CHECK_OBJECT( tmp_isinstance_inst_2 );
    tmp_isinstance_cls_2 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_isinstance_cls_2 != NULL );
    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_2, tmp_isinstance_cls_2 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 438;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_iter_arg_1 = par_taskOrName;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 439;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooo";
            frame_function->m_frame.f_lineno = 439;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_task;
        var_task = tmp_assign_source_3;
        Py_INCREF( var_task );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = var_task;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 440;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_remove, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 440;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 439;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = par_taskOrName;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 442;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_findTasks, call_args );
    }

    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_tasks == NULL );
    var_tasks = tmp_assign_source_4;

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_mgr );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 443;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = var_tasks;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 443;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_remove, call_args );
    }

    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 443;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskOrName, var_task, var_tasks );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_21_remove );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskOrName );
    Py_DECREF( par_taskOrName );
    par_taskOrName = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    Py_XDECREF( var_tasks );
    var_tasks = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskOrName );
    Py_DECREF( par_taskOrName );
    par_taskOrName = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    Py_XDECREF( var_tasks );
    var_tasks = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_21_remove );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_taskPattern = python_pars[ 1 ];
    PyObject *var_tasks = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_259c61b4f9811ad8ccc96af43b96bd59, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_mgr );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 452;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_findTasksMatching );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 452;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_GlobPattern );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_GlobPattern );
    }

    if ( tmp_called_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "GlobPattern" );
        exception_tb = NULL;

        exception_lineno = 452;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = par_taskPattern;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 452;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 452;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 452;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 452;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_tasks == NULL );
    var_tasks = tmp_assign_source_1;

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_mgr );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 453;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_tasks;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 453;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_remove, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 453;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_taskPattern, var_tasks );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskPattern );
    Py_DECREF( par_taskPattern );
    par_taskPattern = NULL;

    CHECK_OBJECT( (PyObject *)var_tasks );
    Py_DECREF( var_tasks );
    var_tasks = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_taskPattern );
    Py_DECREF( par_taskPattern );
    par_taskPattern = NULL;

    Py_XDECREF( var_tasks );
    var_tasks = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_23_step( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_startFrameTime = NULL;
    PyObject *var_nextTaskTime = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_raise_type_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_12aa142535b85eafe922a23f44924443, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = const_int_0;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_fKeyboardInterrupt, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = const_int_0;
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_interruptCount, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_cond_value_1 == NULL ))
    {
        tmp_cond_value_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_cond_value_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 466;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 466;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_signal );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_2 == NULL )
    {
        Py_DECREF( tmp_called_name_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_SIGINT );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_keyboardInterruptHandler );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_1 );

        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 467;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_globalClock );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 469;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getRealTime );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 469;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_startFrameTime == NULL );
    var_startFrameTime = tmp_assign_source_1;

    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_mgr );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 471;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 471;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_poll );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 471;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_6 = par_self;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_mgr );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 474;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getNextWakeTime );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 474;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_nextTaskTime == NULL );
    var_nextTaskTime = tmp_assign_source_2;

    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_3 = var_startFrameTime;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = var_nextTaskTime;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 475;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_4, const_str_plain_doYield, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 475;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_cond_value_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_cond_value_2 == NULL ))
    {
        tmp_cond_value_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_cond_value_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 478;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 478;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_signal );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_8 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_SIGINT );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_signal );
    }

    if ( tmp_source_name_9 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_5 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "signal" );
        exception_tb = NULL;

        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_default_int_handler );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_5 );

        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 479;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_5 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 479;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    tmp_source_name_10 = par_self;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_cond_value_3 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_fKeyboardInterrupt );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 480;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 480;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_raise_type_1 = PyExc_KeyboardInterrupt;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 481;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooo";
    goto frame_exception_exit_1;
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_startFrameTime, var_nextTaskTime );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_23_step );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_startFrameTime );
    Py_DECREF( var_startFrameTime );
    var_startFrameTime = NULL;

    CHECK_OBJECT( (PyObject *)var_nextTaskTime );
    Py_DECREF( var_nextTaskTime );
    var_nextTaskTime = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_startFrameTime );
    var_startFrameTime = NULL;

    Py_XDECREF( var_nextTaskTime );
    var_nextTaskTime = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_23_step );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_24_run( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    struct Nuitka_CellObject *par_self = PyCell_NEW1( python_pars[ 0 ] );
    PyObject *var_t = NULL;
    PyObject *var_timeDelta = NULL;
    PyObject *var_numFrames = NULL;
    PyObject *var_session = NULL;
    PyObject *var_callback = NULL;
    PyObject *var__profileFunc = NULL;
    PyObject *var_ioError = NULL;
    PyObject *var_code = NULL;
    PyObject *var_message = NULL;
    PyObject *var_e = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *tmp_tuple_unpack_1__element_3 = NULL;
    PyObject *tmp_tuple_unpack_2__source_iter = NULL;
    PyObject *tmp_tuple_unpack_2__element_1 = NULL;
    PyObject *tmp_tuple_unpack_2__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_instance_16;
    PyObject *tmp_called_instance_17;
    PyObject *tmp_called_instance_18;
    PyObject *tmp_called_instance_19;
    PyObject *tmp_called_instance_20;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_defaults_1;
    int tmp_exc_match_exception_match_1;
    int tmp_exc_match_exception_match_2;
    int tmp_exc_match_exception_match_3;
    int tmp_exc_match_exception_match_4;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_iterator_name_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    PyObject *tmp_unpack_3;
    PyObject *tmp_unpack_4;
    PyObject *tmp_unpack_5;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_893e0b32b6121f59fe207ad6d789310b, module_direct$task$Task, sizeof(struct Nuitka_CellObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_PandaSystem );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PandaSystem );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PandaSystem" );
        exception_tb = NULL;

        exception_lineno = 487;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 487;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getPlatform );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 487;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_str_plain_emscripten;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 487;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    if ( par_self == NULL )
    {
        tmp_source_name_1 = NULL;
    }
    else
    {
        tmp_source_name_1 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 492;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_globalClock );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 492;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getFrameTime );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_t == NULL );
    var_t = tmp_assign_source_1;

    tmp_left_name_1 = var_t;

    CHECK_OBJECT( tmp_left_name_1 );
    if ( par_self == NULL )
    {
        tmp_source_name_2 = NULL;
    }
    else
    {
        tmp_source_name_2 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 493;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_globalClock );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 493;
    tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getRealTime );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_timeDelta == NULL );
    var_timeDelta = tmp_assign_source_2;

    if ( par_self == NULL )
    {
        tmp_source_name_3 = NULL;
    }
    else
    {
        tmp_source_name_3 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 494;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_globalClock );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 494;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = var_t;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 494;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_setRealTime, call_args );
    }

    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 494;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_5 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_messenger );

    if (unlikely( tmp_called_instance_5 == NULL ))
    {
        tmp_called_instance_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_messenger );
    }

    if ( tmp_called_instance_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "messenger" );
        exception_tb = NULL;

        exception_lineno = 495;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = const_str_plain_resetClock;
    tmp_args_element_name_3 = PyList_New( 1 );
    tmp_list_element_1 = var_timeDelta;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_3, 0, tmp_list_element_1 );
    frame_function->m_frame.f_lineno = 495;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_5, const_str_plain_send, call_args );
    }

    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 495;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    if ( par_self == NULL )
    {
        tmp_source_name_4 = NULL;
    }
    else
    {
        tmp_source_name_4 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 497;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_resumeFunc );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 497;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = Py_None;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 497;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    if ( par_self == NULL )
    {
        tmp_called_instance_6 = NULL;
    }
    else
    {
        tmp_called_instance_6 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 498;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 498;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_resumeFunc );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 498;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_2:;
    if ( par_self == NULL )
    {
        tmp_source_name_5 = NULL;
    }
    else
    {
        tmp_source_name_5 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 500;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_stepping );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 500;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    if ( par_self == NULL )
    {
        tmp_called_instance_7 = NULL;
    }
    else
    {
        tmp_called_instance_7 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 501;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 501;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 501;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_assattr_name_1 = Py_True;
    if ( par_self == NULL )
    {
        tmp_assattr_target_1 = NULL;
    }
    else
    {
        tmp_assattr_target_1 = PyCell_GET( par_self );
    }

    if ( tmp_assattr_target_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 503;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_running, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 503;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    loop_start_1:;
    if ( par_self == NULL )
    {
        tmp_source_name_6 = NULL;
    }
    else
    {
        tmp_source_name_6 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 504;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_running );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 504;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 504;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    goto loop_end_1;
    branch_no_4:;
    // Tried code:
    if ( par_self == NULL )
    {
        tmp_source_name_7 = NULL;
    }
    else
    {
        tmp_source_name_7 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 506;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }

    tmp_len_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__frameProfileQueue );
    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    tmp_cond_value_3 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 506;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    // Tried code:
    if ( par_self == NULL )
    {
        tmp_source_name_8 = NULL;
    }
    else
    {
        tmp_source_name_8 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 507;
        type_description = "coooooooooo";
        goto try_except_handler_3;
    }

    tmp_called_instance_8 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain__frameProfileQueue );
    if ( tmp_called_instance_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 507;
        type_description = "coooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 507;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_pop );
    Py_DECREF( tmp_called_instance_8 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 507;
        type_description = "coooooooooo";
        goto try_except_handler_3;
    }
    tmp_assign_source_3 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 507;
        type_description = "coooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__source_iter;
        tmp_tuple_unpack_1__source_iter = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_4 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_4 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "coooooooooo";
        exception_lineno = 507;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_1;
        tmp_tuple_unpack_1__element_1 = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_5 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "coooooooooo";
        exception_lineno = 507;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_2;
        tmp_tuple_unpack_1__element_2 = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_unpack_3 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_3 );
    tmp_assign_source_6 = UNPACK_NEXT( tmp_unpack_3, 2 );
    if ( tmp_assign_source_6 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "coooooooooo";
        exception_lineno = 507;
        goto try_except_handler_4;
    }
    {
        PyObject *old = tmp_tuple_unpack_1__element_3;
        tmp_tuple_unpack_1__element_3 = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description = "coooooooooo";
                goto try_except_handler_4;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 3)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description = "coooooooooo";
        goto try_except_handler_4;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_3;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_2;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_7 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_7 );
    {
        PyObject *old = var_numFrames;
        var_numFrames = tmp_assign_source_7;
        Py_INCREF( var_numFrames );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_8 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_session;
        var_session = tmp_assign_source_8;
        Py_INCREF( var_session );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    tmp_assign_source_9 = tmp_tuple_unpack_1__element_3;

    CHECK_OBJECT( tmp_assign_source_9 );
    {
        PyObject *old = var_callback;
        var_callback = tmp_assign_source_9;
        Py_INCREF( var_callback );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_1__element_3 );
    tmp_tuple_unpack_1__element_3 = NULL;

    tmp_defaults_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_numFrames;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_1 );
    tmp_assign_source_10 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc( tmp_defaults_1, par_self );
    {
        PyObject *old = var__profileFunc;
        var__profileFunc = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    tmp_called_instance_9 = var_session;

    CHECK_OBJECT( tmp_called_instance_9 );
    tmp_args_element_name_4 = var__profileFunc;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 510;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_setFunc, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 510;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_10 = var_session;

    CHECK_OBJECT( tmp_called_instance_10 );
    frame_function->m_frame.f_lineno = 511;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_run );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 511;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_11 = Py_None;
    {
        PyObject *old = var__profileFunc;
        assert( old != NULL );
        var__profileFunc = tmp_assign_source_11;
        Py_INCREF( var__profileFunc );
        Py_DECREF( old );
    }

    tmp_cond_value_4 = var_callback;

    CHECK_OBJECT( tmp_cond_value_4 );
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 513;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_name_1 = var_callback;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_function->m_frame.f_lineno = 514;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_6:;
    tmp_called_instance_11 = var_session;

    CHECK_OBJECT( tmp_called_instance_11 );
    frame_function->m_frame.f_lineno = 515;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_release );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 515;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_5;
    branch_no_5:;
    if ( par_self == NULL )
    {
        tmp_called_instance_12 = NULL;
    }
    else
    {
        tmp_called_instance_12 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 517;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 517;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_12, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 517;
        type_description = "coooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_end_5:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != -1 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_function, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_compare_left_3 = PyThreadState_GET()->exc_type;
    tmp_compare_right_3 = PyExc_KeyboardInterrupt;
    tmp_exc_match_exception_match_1 = EXCEPTION_MATCH_BOOL( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_exc_match_exception_match_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 518;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_1 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    if ( par_self == NULL )
    {
        tmp_called_instance_13 = NULL;
    }
    else
    {
        tmp_called_instance_13 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 519;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 519;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_13, const_str_plain_stop );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 519;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_7;
    branch_no_7:;
    tmp_compare_left_4 = PyThreadState_GET()->exc_type;
    tmp_compare_right_4 = PyExc_SystemExit;
    tmp_exc_match_exception_match_2 = EXCEPTION_MATCH_BOOL( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_exc_match_exception_match_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_2 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    if ( par_self == NULL )
    {
        tmp_called_instance_14 = NULL;
    }
    else
    {
        tmp_called_instance_14 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_14 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 521;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 521;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_14, const_str_plain_stop );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 521;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == &frame_function->m_frame) frame_function->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description = "coooooooooo";
    goto frame_exception_exit_1;
    goto branch_end_8;
    branch_no_8:;
    tmp_compare_left_5 = PyThreadState_GET()->exc_type;
    tmp_compare_right_5 = PyExc_IOError;
    tmp_exc_match_exception_match_3 = EXCEPTION_MATCH_BOOL( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_exc_match_exception_match_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 523;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_3 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_assign_source_12 = PyThreadState_GET()->exc_value;
    {
        PyObject *old = var_ioError;
        var_ioError = tmp_assign_source_12;
        Py_INCREF( var_ioError );
        Py_XDECREF( old );
    }

    // Tried code:
    if ( par_self == NULL )
    {
        tmp_called_instance_15 = NULL;
    }
    else
    {
        tmp_called_instance_15 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_15 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 524;
        type_description = "coooooooooo";
        goto try_except_handler_5;
    }

    tmp_args_element_name_5 = var_ioError;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 524;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_iter_arg_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_15, const_str_plain__unpackIOError, call_args );
    }

    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 524;
        type_description = "coooooooooo";
        goto try_except_handler_5;
    }
    tmp_assign_source_13 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 524;
        type_description = "coooooooooo";
        goto try_except_handler_5;
    }
    {
        PyObject *old = tmp_tuple_unpack_2__source_iter;
        tmp_tuple_unpack_2__source_iter = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    // Tried code:
    tmp_unpack_4 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_unpack_4 );
    tmp_assign_source_14 = UNPACK_NEXT( tmp_unpack_4, 0 );
    if ( tmp_assign_source_14 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "coooooooooo";
        exception_lineno = 524;
        goto try_except_handler_6;
    }
    {
        PyObject *old = tmp_tuple_unpack_2__element_1;
        tmp_tuple_unpack_2__element_1 = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    tmp_unpack_5 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_unpack_5 );
    tmp_assign_source_15 = UNPACK_NEXT( tmp_unpack_5, 1 );
    if ( tmp_assign_source_15 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }


        type_description = "coooooooooo";
        exception_lineno = 524;
        goto try_except_handler_6;
    }
    {
        PyObject *old = tmp_tuple_unpack_2__element_2;
        tmp_tuple_unpack_2__element_2 = tmp_assign_source_15;
        Py_XDECREF( old );
    }

    tmp_iterator_name_2 = tmp_tuple_unpack_2__source_iter;

    CHECK_OBJECT( tmp_iterator_name_2 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_2 ); assert( HAS_ITERNEXT( tmp_iterator_name_2 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_2 )->tp_iternext)( tmp_iterator_name_2 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

                type_description = "coooooooooo";
                goto try_except_handler_6;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );

        type_description = "coooooooooo";
        goto try_except_handler_6;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto try_except_handler_5;
    // End of try:
    try_end_4:;
    goto try_end_5;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_2__source_iter );
    Py_DECREF( tmp_tuple_unpack_2__source_iter );
    tmp_tuple_unpack_2__source_iter = NULL;

    tmp_assign_source_16 = tmp_tuple_unpack_2__element_1;

    CHECK_OBJECT( tmp_assign_source_16 );
    {
        PyObject *old = var_code;
        var_code = tmp_assign_source_16;
        Py_INCREF( var_code );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_2__element_1 );
    tmp_tuple_unpack_2__element_1 = NULL;

    tmp_assign_source_17 = tmp_tuple_unpack_2__element_2;

    CHECK_OBJECT( tmp_assign_source_17 );
    {
        PyObject *old = var_message;
        var_message = tmp_assign_source_17;
        Py_INCREF( var_message );
        Py_XDECREF( old );
    }

    Py_XDECREF( tmp_tuple_unpack_2__element_2 );
    tmp_tuple_unpack_2__element_2 = NULL;

    tmp_compare_left_6 = var_code;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = const_int_pos_4;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 531;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    if ( par_self == NULL )
    {
        tmp_called_instance_16 = NULL;
    }
    else
    {
        tmp_called_instance_16 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_16 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 532;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 532;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_16, const_str_plain_stop );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 532;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_10;
    branch_no_10:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == &frame_function->m_frame) frame_function->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description = "coooooooooo";
    goto frame_exception_exit_1;
    branch_end_10:;
    goto branch_end_9;
    branch_no_9:;
    tmp_compare_left_7 = PyThreadState_GET()->exc_type;
    tmp_compare_right_7 = PyExc_Exception;
    tmp_exc_match_exception_match_4 = EXCEPTION_MATCH_BOOL( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_exc_match_exception_match_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_exc_match_exception_match_4 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_assign_source_18 = PyThreadState_GET()->exc_value;
    {
        PyObject *old = var_e;
        var_e = tmp_assign_source_18;
        Py_INCREF( var_e );
        Py_XDECREF( old );
    }

    if ( par_self == NULL )
    {
        tmp_source_name_9 = NULL;
    }
    else
    {
        tmp_source_name_9 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 536;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_5 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_extendedExceptions );
    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 536;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 536;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    if ( par_self == NULL )
    {
        tmp_called_instance_17 = NULL;
    }
    else
    {
        tmp_called_instance_17 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_17 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 537;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 537;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_17, const_str_plain_stop );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 537;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_print_exc_plus );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_print_exc_plus );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "print_exc_plus" );
        exception_tb = NULL;

        exception_lineno = 538;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 538;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 538;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_12;
    branch_no_12:;
    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExceptionVarDump" );
        exception_tb = NULL;

        exception_lineno = 540;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_left_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_wantStackDumpLog );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 540;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_and_left_value_1 );

        exception_lineno = 541;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    Py_DECREF( tmp_and_left_value_1 );
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );
    }

    if ( tmp_source_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExceptionVarDump" );
        exception_tb = NULL;

        exception_lineno = 541;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_and_right_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_dumpOnExceptionInit );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_6 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_6 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 541;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_called_instance_18 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );

    if (unlikely( tmp_called_instance_18 == NULL ))
    {
        tmp_called_instance_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump );
    }

    if ( tmp_called_instance_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ExceptionVarDump" );
        exception_tb = NULL;

        exception_lineno = 542;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = var_e;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 542;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_18, const_str_plain__varDump__print, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 542;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == &frame_function->m_frame) frame_function->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description = "coooooooooo";
    goto frame_exception_exit_1;
    branch_end_12:;
    goto branch_end_11;
    branch_no_11:;
    if ( par_self == NULL )
    {
        tmp_source_name_12 = NULL;
    }
    else
    {
        tmp_source_name_12 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_12 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 545;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_cond_value_7 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_extendedExceptions );
    if ( tmp_cond_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 545;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 545;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_14;
    }
    else
    {
        goto branch_no_14;
    }
    branch_yes_14:;
    if ( par_self == NULL )
    {
        tmp_called_instance_19 = NULL;
    }
    else
    {
        tmp_called_instance_19 = PyCell_GET( par_self );
    }

    if ( tmp_called_instance_19 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 546;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 546;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_19, const_str_plain_stop );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 546;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_print_exc_plus );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_print_exc_plus );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "print_exc_plus" );
        exception_tb = NULL;

        exception_lineno = 547;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 547;
    tmp_unused = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 547;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_14;
    branch_no_14:;
    RERAISE_EXCEPTION( &exception_type, &exception_value, &exception_tb );
    if (exception_tb && exception_tb->tb_frame == &frame_function->m_frame) frame_function->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description = "coooooooooo";
    goto frame_exception_exit_1;
    branch_end_14:;
    branch_end_11:;
    branch_end_9:;
    branch_end_8:;
    branch_end_7:;
    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_24_run );
    return NULL;
    // End of try:
    try_end_3:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 504;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    branch_end_3:;
    if ( par_self == NULL )
    {
        tmp_source_name_13 = NULL;
    }
    else
    {
        tmp_source_name_13 = PyCell_GET( par_self );
    }

    if ( tmp_source_name_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "self" );
        exception_tb = NULL;

        exception_lineno = 551;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_20 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_mgr );
    if ( tmp_called_instance_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 551;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 551;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_20, const_str_plain_stopThreads );
    Py_DECREF( tmp_called_instance_20 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 551;
        type_description = "coooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_t, var_timeDelta, var_numFrames, var_session, var_callback, var__profileFunc, var_ioError, var_code, var_message, var_e );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_24_run );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var_timeDelta );
    var_timeDelta = NULL;

    Py_XDECREF( var_numFrames );
    var_numFrames = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_callback );
    var_callback = NULL;

    Py_XDECREF( var__profileFunc );
    var__profileFunc = NULL;

    Py_XDECREF( var_ioError );
    var_ioError = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    Py_XDECREF( var_message );
    var_message = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var_timeDelta );
    var_timeDelta = NULL;

    Py_XDECREF( var_numFrames );
    var_numFrames = NULL;

    Py_XDECREF( var_session );
    var_session = NULL;

    Py_XDECREF( var_callback );
    var_callback = NULL;

    Py_XDECREF( var__profileFunc );
    var__profileFunc = NULL;

    Py_XDECREF( var_ioError );
    var_ioError = NULL;

    Py_XDECREF( var_code );
    var_code = NULL;

    Py_XDECREF( var_message );
    var_message = NULL;

    Py_XDECREF( var_e );
    var_e = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_24_run );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_numFrames = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_35ffccfa398837ded2bd5733c8d924d6, module_direct$task$Task, sizeof(struct Nuitka_CellObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    if ( self->m_closure[0] == NULL )
    {
        tmp_called_instance_1 = NULL;
    }
    else
    {
        tmp_called_instance_1 = PyCell_GET( self->m_closure[0] );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "free variable '%s' referenced before assignment in enclosing scope", "self" );
        exception_tb = NULL;

        exception_lineno = 509;
        type_description = "oc";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = par_numFrames;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 509;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain__doProfiledFrames, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;
        type_description = "oc";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_numFrames, self->m_closure[0] );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_numFrames );
    Py_DECREF( par_numFrames );
    par_numFrames = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_numFrames );
    Py_DECREF( par_numFrames );
    par_numFrames = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_ioError = python_pars[ 1 ];
    PyObject *var_code = NULL;
    PyObject *var_message = NULL;
    PyObject *tmp_tuple_unpack_1__source_iter = NULL;
    PyObject *tmp_tuple_unpack_1__element_1 = NULL;
    PyObject *tmp_tuple_unpack_1__element_2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iterator_attempt;
    PyObject *tmp_iterator_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_unpack_1;
    PyObject *tmp_unpack_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    tmp_return_value = NULL;

    // Actual function code.
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7cac45d21cdc2606c699c8d89e878305, module_direct$task$Task, 0 );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    // Tried code:
    // Tried code:
    tmp_iter_arg_1 = par_ioError;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 558;

        goto try_except_handler_2;
    }
    assert( tmp_tuple_unpack_1__source_iter == NULL );
    tmp_tuple_unpack_1__source_iter = tmp_assign_source_1;

    // Tried code:
    tmp_unpack_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_1 );
    tmp_assign_source_2 = UNPACK_NEXT( tmp_unpack_1, 0 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 558;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_1 == NULL );
    tmp_tuple_unpack_1__element_1 = tmp_assign_source_2;

    tmp_unpack_2 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_unpack_2 );
    tmp_assign_source_3 = UNPACK_NEXT( tmp_unpack_2, 1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( !ERROR_OCCURRED() )
        {
            exception_type = PyExc_StopIteration;
            Py_INCREF( exception_type );
            exception_value = NULL;
            exception_tb = NULL;
        }
        else
        {
            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        }



        exception_lineno = 558;
        goto try_except_handler_3;
    }
    assert( tmp_tuple_unpack_1__element_2 == NULL );
    tmp_tuple_unpack_1__element_2 = tmp_assign_source_3;

    tmp_iterator_name_1 = tmp_tuple_unpack_1__source_iter;

    CHECK_OBJECT( tmp_iterator_name_1 );
    // Check if iterator has left-over elements.
    CHECK_OBJECT( tmp_iterator_name_1 ); assert( HAS_ITERNEXT( tmp_iterator_name_1 ) );

    tmp_iterator_attempt = (*Py_TYPE( tmp_iterator_name_1 )->tp_iternext)( tmp_iterator_name_1 );

    if (likely( tmp_iterator_attempt == NULL ))
    {
        PyObject *error = GET_ERROR_OCCURRED();

        if ( error != NULL )
        {
            if ( EXCEPTION_MATCH_BOOL_SINGLE( error, PyExc_StopIteration ))
            {
                CLEAR_ERROR_OCCURRED();
            }
            else
            {
                FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


                goto try_except_handler_3;
            }
        }
    }
    else
    {
        Py_DECREF( tmp_iterator_attempt );

        // TODO: Could avoid PyErr_Format.
#if PYTHON_VERSION < 300
        PyErr_Format( PyExc_ValueError, "too many values to unpack" );
#else
        PyErr_Format( PyExc_ValueError, "too many values to unpack (expected 2)" );
#endif
        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        goto try_except_handler_3;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto try_except_handler_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_tuple_unpack_1__source_iter );
    Py_DECREF( tmp_tuple_unpack_1__source_iter );
    tmp_tuple_unpack_1__source_iter = NULL;

    tmp_assign_source_4 = tmp_tuple_unpack_1__element_1;

    CHECK_OBJECT( tmp_assign_source_4 );
    assert( var_code == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_code = tmp_assign_source_4;

    Py_XDECREF( tmp_tuple_unpack_1__element_1 );
    tmp_tuple_unpack_1__element_1 = NULL;

    tmp_assign_source_5 = tmp_tuple_unpack_1__element_2;

    CHECK_OBJECT( tmp_assign_source_5 );
    assert( var_message == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_message = tmp_assign_source_5;

    Py_XDECREF( tmp_tuple_unpack_1__element_2 );
    tmp_tuple_unpack_1__element_2 = NULL;

    goto try_end_3;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    // Preserve existing published exception.
    PRESERVE_FRAME_EXCEPTION( frame_function );
    if ( exception_keeper_tb_3 == NULL )
    {
        exception_keeper_tb_3 = MAKE_TRACEBACK( frame_function, exception_keeper_lineno_3 );
    }
    else if ( exception_keeper_lineno_3 != -1 )
    {
        exception_keeper_tb_3 = ADD_TRACEBACK( exception_keeper_tb_3, frame_function, exception_keeper_lineno_3 );
    }

    NORMALIZE_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    PUBLISH_EXCEPTION( &exception_keeper_type_3, &exception_keeper_value_3, &exception_keeper_tb_3 );
    tmp_assign_source_6 = const_int_0;
    assert( var_code == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_code = tmp_assign_source_6;

    tmp_assign_source_7 = par_ioError;

    CHECK_OBJECT( tmp_assign_source_7 );
    assert( var_message == NULL );
    Py_INCREF( tmp_assign_source_7 );
    var_message = tmp_assign_source_7;

    goto try_end_3;
    // exception handler codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError );
    return NULL;
    // End of try:
    try_end_3:;

#if 1
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_no_exception_1:;

    // Tried code:
    tmp_return_value = PyTuple_New( 2 );
    tmp_tuple_element_1 = var_code;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_message;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_return_value, 1, tmp_tuple_element_1 );
    goto try_return_handler_4;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError );
    return NULL;
    // Return handler code:
    try_return_handler_4:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_ioError );
    Py_DECREF( par_ioError );
    par_ioError = NULL;

    CHECK_OBJECT( (PyObject *)var_code );
    Py_DECREF( var_code );
    var_code = NULL;

    CHECK_OBJECT( (PyObject *)var_message );
    Py_DECREF( var_message );
    var_message = NULL;

    goto function_return_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_26_stop( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bfc43a007ad8797741d50f7fe2c022f5, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_assattr_name_1 = Py_False;
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_running, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 566;
        type_description = "o";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_26_stop );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_26_stop );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *par_oldMethod = python_pars[ 2 ];
    PyObject *par_newFunction = python_pars[ 3 ];
    PyObject *var_method = NULL;
    PyObject *var_function = NULL;
    PyObject *var_newMethod = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    int tmp_res;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_type_arg_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_15701462c26ef8d6ea9ee9534de654cd, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_isinstance_inst_1 = par_task;

    CHECK_OBJECT( tmp_isinstance_inst_1 );
    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_PythonTask );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonTask );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PythonTask" );
        exception_tb = NULL;

        exception_lineno = 569;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_res = Nuitka_IsInstance( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_res == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 569;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_res == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_task;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 572;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFunction );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 572;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_method == NULL );
    var_method = tmp_assign_source_1;

    tmp_type_arg_1 = var_method;

    CHECK_OBJECT( tmp_type_arg_1 );
    tmp_compare_left_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    assert( tmp_compare_left_1 != NULL );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_types );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_types );
    }

    if ( tmp_source_name_1 == NULL )
    {
        Py_DECREF( tmp_compare_left_1 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "types" );
        exception_tb = NULL;

        exception_lineno = 573;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_compare_right_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_MethodType );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 573;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 573;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_2 = var_method;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain___func__ );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 574;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_function == NULL );
    var_function = tmp_assign_source_2;

    goto branch_end_2;
    branch_no_2:;
    tmp_assign_source_3 = var_method;

    CHECK_OBJECT( tmp_assign_source_3 );
    assert( var_function == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_function = tmp_assign_source_3;

    branch_end_2:;
    tmp_compare_left_2 = var_function;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = par_oldMethod;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_types );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_types );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "types" );
        exception_tb = NULL;

        exception_lineno = 578;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_MethodType );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_newFunction;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_source_name_4 = var_method;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain___self__ );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 579;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = var_method;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_source_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain___self__ );
    if ( tmp_source_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 580;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE_CLASS_SLOT( tmp_source_name_5 );
    Py_DECREF( tmp_source_name_5 );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 580;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 578;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 578;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_newMethod == NULL );
    var_newMethod = tmp_assign_source_4;

    tmp_called_instance_2 = par_task;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_4 = var_newMethod;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 581;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setFunction, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 581;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_pos_1;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task, par_oldMethod, par_newFunction, var_method, var_function, var_newMethod );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_oldMethod );
    Py_DECREF( par_oldMethod );
    par_oldMethod = NULL;

    CHECK_OBJECT( (PyObject *)par_newFunction );
    Py_DECREF( par_newFunction );
    par_newFunction = NULL;

    Py_XDECREF( var_method );
    var_method = NULL;

    Py_XDECREF( var_function );
    var_function = NULL;

    Py_XDECREF( var_newMethod );
    var_newMethod = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_oldMethod );
    Py_DECREF( par_oldMethod );
    par_oldMethod = NULL;

    CHECK_OBJECT( (PyObject *)par_newFunction );
    Py_DECREF( par_newFunction );
    par_newFunction = NULL;

    Py_XDECREF( var_method );
    var_method = NULL;

    Py_XDECREF( var_function );
    var_function = NULL;

    Py_XDECREF( var_newMethod );
    var_newMethod = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_oldMethod = python_pars[ 1 ];
    PyObject *par_newFunction = python_pars[ 2 ];
    PyObject *var_numFound = NULL;
    PyObject *var_task = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_next_source_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_int_0;
    assert( var_numFound == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_numFound = tmp_assign_source_1;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e702ecd4827fa652e6590e8682d95714, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 588;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getAllTasks );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooo";
            frame_function->m_frame.f_lineno = 588;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_task;
        var_task = tmp_assign_source_4;
        Py_INCREF( var_task );
        Py_XDECREF( old );
    }

    tmp_left_name_1 = var_numFound;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "numFound" );
        exception_tb = NULL;

        exception_lineno = 589;
        type_description = "ooooo";
        goto try_except_handler_2;
    }

    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = var_task;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_oldMethod;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_newFunction;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 589;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_right_name_1 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain__TaskManager__tryReplaceTaskMethod, call_args );
    }

    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 589;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_5 = tmp_left_name_1;
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 589;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    var_numFound = tmp_assign_source_5;

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 588;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_numFound;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "numFound" );
        exception_tb = NULL;

        exception_lineno = 590;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_oldMethod, par_newFunction, var_numFound, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oldMethod );
    Py_DECREF( par_oldMethod );
    par_oldMethod = NULL;

    CHECK_OBJECT( (PyObject *)par_newFunction );
    Py_DECREF( par_newFunction );
    par_newFunction = NULL;

    Py_XDECREF( var_numFound );
    var_numFound = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_oldMethod );
    Py_DECREF( par_oldMethod );
    par_oldMethod = NULL;

    CHECK_OBJECT( (PyObject *)par_newFunction );
    Py_DECREF( par_newFunction );
    par_newFunction = NULL;

    Py_XDECREF( var_numFound );
    var_numFound = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_TaskManagerPanel = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_437f87a7b8a2bfcc26a548c69f7a50ba, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_importlib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "importlib" );
        exception_tb = NULL;

        exception_lineno = 595;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 595;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_071fbe783e195c14275508b31303991a_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 595;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_TaskManagerPanel == NULL );
    var_TaskManagerPanel = tmp_assign_source_1;

    tmp_called_instance_2 = var_TaskManagerPanel;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 596;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_TaskManagerPanel, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 596;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_TaskManagerPanel );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_TaskManagerPanel );
    Py_DECREF( var_TaskManagerPanel );
    var_TaskManagerPanel = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_TaskManagerPanel );
    var_TaskManagerPanel = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *var_PS = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    bool tmp_is_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_compare_left_1 = par_name;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = const_str_plain_taskMgrFrameProfile;
    {
        PyObject *old = par_name;
        assert( old != NULL );
        par_name = tmp_assign_source_1;
        Py_INCREF( par_name );
        Py_DECREF( old );
    }

    branch_no_1:;
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_03b873bf40115ff2336d78b244fb9290, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_importlib );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "importlib" );
        exception_tb = NULL;

        exception_lineno = 605;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 605;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_40c78e90f83f2d64d9fd828f457bffb6_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 605;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_PS == NULL );
    var_PS = tmp_assign_source_2;

    tmp_called_instance_2 = var_PS;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = par_name;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 606;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_ProfileSession, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 606;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name, var_PS );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)var_PS );
    Py_DECREF( var_PS );
    var_PS = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    Py_XDECREF( var_PS );
    var_PS = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_num = python_pars[ 1 ];
    PyObject *par_session = python_pars[ 2 ];
    PyObject *par_callback = python_pars[ 3 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    bool tmp_is_1;
    bool tmp_is_2;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_compare_left_1 = par_num;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_is_1 = ( tmp_compare_left_1 == tmp_compare_right_1 );
    if ( tmp_is_1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_1 = const_int_pos_1;
    {
        PyObject *old = par_num;
        assert( old != NULL );
        par_num = tmp_assign_source_1;
        Py_INCREF( par_num );
        Py_DECREF( old );
    }

    branch_no_1:;
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_26392af6f6494f1c3c610fcf382e43f2, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_compare_left_2 = par_session;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_is_2 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_2 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 612;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getProfileSession );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_session;
        assert( old != NULL );
        par_session = tmp_assign_source_2;
        Py_DECREF( old );
    }

    branch_no_2:;
    tmp_called_instance_2 = par_session;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 614;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_acquire );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 614;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__frameProfileQueue );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 615;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = PyTuple_New( 3 );
    tmp_tuple_element_1 = par_num;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_session;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = par_callback;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_args_element_name_1, 2, tmp_tuple_element_1 );
    frame_function->m_frame.f_lineno = 615;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_push, call_args );
    }

    Py_DECREF( tmp_called_instance_3 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 615;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_num, par_session, par_callback );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_num );
    Py_DECREF( par_num );
    par_num = NULL;

    CHECK_OBJECT( (PyObject *)par_session );
    Py_DECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_num );
    Py_DECREF( par_num );
    par_num = NULL;

    Py_XDECREF( par_session );
    par_session = NULL;

    CHECK_OBJECT( (PyObject *)par_callback );
    Py_DECREF( par_callback );
    par_callback = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_numFrames = python_pars[ 1 ];
    PyObject *var_i = NULL;
    PyObject *var_result = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9be619cf3323295ce5c2d4d8e9c31008, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_range_arg_1 = par_numFrames;

    CHECK_OBJECT( tmp_range_arg_1 );
    tmp_iter_arg_1 = BUILTIN_RANGE( tmp_range_arg_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooo";
            frame_function->m_frame.f_lineno = 618;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_3;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 619;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_step );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 619;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_result;
        var_result = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = var_result;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "result" );
        exception_tb = NULL;

        exception_lineno = 620;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_numFrames, var_i, var_result );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_numFrames );
    Py_DECREF( par_numFrames );
    par_numFrames = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_numFrames );
    Py_DECREF( par_numFrames );
    par_numFrames = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_result );
    var_result = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_c3612d9631208f6153f2c2d841b34ccf, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileFrames );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 623;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 623;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_2bc704666bbeaa4896b3f93bd0374366, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileFrames );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_profileFrames = python_pars[ 1 ];
    PyObject *var_FP = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_operand_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9e313032971706852e78187240f68f33, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileFrames );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 629;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_profileFrames;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 629;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_set, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 629;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__frameProfiler );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_and_right_value_1 = par_profileFrames;

    CHECK_OBJECT( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_importlib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "importlib" );
        exception_tb = NULL;

        exception_lineno = 632;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 632;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_36412136f6a38534526ee3bd8be027b3_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 632;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_FP == NULL );
    var_FP = tmp_assign_source_1;

    tmp_called_instance_3 = var_FP;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 633;
    tmp_assattr_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_FrameProfiler );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 633;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__frameProfiler, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 633;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_profileFrames, var_FP );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileFrames );
    Py_DECREF( par_profileFrames );
    par_profileFrames = NULL;

    Py_XDECREF( var_FP );
    var_FP = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileFrames );
    Py_DECREF( par_profileFrames );
    par_profileFrames = NULL;

    Py_XDECREF( var_FP );
    var_FP = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_948d539c21e35b6bfc38f19eca691423, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileTasks );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 636;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_get );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 636;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d36ce0e5dd46338a23c8346264516bfd, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileTasks );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 639;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_profileTasks = python_pars[ 1 ];
    PyObject *var_TP = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_operand_name_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_4f491396b898906b362b2120438c8d24, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__profileTasks );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 642;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_profileTasks;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 642;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_set, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 642;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_operand_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfiler );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    Py_DECREF( tmp_operand_name_1 );
    if ( tmp_and_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_and_right_value_1 = par_profileTasks;

    CHECK_OBJECT( tmp_and_right_value_1 );
    tmp_cond_value_1 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    tmp_cond_value_1 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_importlib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "importlib" );
        exception_tb = NULL;

        exception_lineno = 645;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 645;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_c3ccb889bb2a33c149f483685be0800b_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_TP == NULL );
    var_TP = tmp_assign_source_1;

    tmp_called_instance_3 = var_TP;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 646;
    tmp_assattr_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_TaskProfiler );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 646;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain__taskProfiler, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 646;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_profileTasks, var_TP );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileTasks );
    Py_DECREF( par_profileTasks );
    par_profileTasks = NULL;

    Py_XDECREF( var_TP );
    var_TP = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileTasks );
    Py_DECREF( par_profileTasks );
    par_profileTasks = NULL;

    Py_XDECREF( var_TP );
    var_TP = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e6ca53e3331ac817da7097ab320f1107, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__taskProfiler );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 649;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 649;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfiler );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 650;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_logProfiles, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_37970f8793037a4ddab592f241f4401c, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain__taskProfiler );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 653;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 653;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfiler );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_name;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 654;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_flush, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_key_5;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_dict_value_5;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_list_element_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d9d7300b276c32d2aec3e898ec71f6a8, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfileInfo );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_session );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 657;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 657;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_source_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain__taskProfileInfo );
    if ( tmp_source_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 658;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_session );
    Py_DECREF( tmp_source_name_3 );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 658;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 658;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_release );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 658;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assattr_name_1 = Py_None;
    tmp_source_name_5 = par_self;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_assattr_target_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain__taskProfileInfo );
    if ( tmp_assattr_target_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_session, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_target_1 );

        exception_lineno = 659;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_target_1 );
    branch_no_1:;
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ScratchPad );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ScratchPad );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ScratchPad" );
        exception_tb = NULL;

        exception_lineno = 660;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    tmp_kw_name_1 = _PyDict_NewPresized( 5 );
    tmp_called_instance_2 = par_task;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 661;
    tmp_dict_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getFunction );
    if ( tmp_dict_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 661;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_dict_key_1 = const_str_plain_taskFunc;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1 );
    Py_DECREF( tmp_dict_value_1 );
    tmp_called_instance_3 = par_task;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 662;
    tmp_dict_value_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getArgs );
    if ( tmp_dict_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_kw_name_1 );

        exception_lineno = 662;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_dict_key_2 = const_str_plain_taskArgs;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2 );
    Py_DECREF( tmp_dict_value_2 );
    tmp_dict_value_3 = par_task;

    CHECK_OBJECT( tmp_dict_value_3 );
    tmp_dict_key_3 = const_str_plain_task;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3 );
    tmp_dict_value_4 = Py_False;
    tmp_dict_key_4 = const_str_plain_profiled;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4 );
    tmp_dict_value_5 = Py_None;
    tmp_dict_key_5 = const_str_plain_session;
    PyDict_SetItem( tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5 );
    frame_function->m_frame.f_lineno = 660;
    tmp_assattr_name_2 = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_assattr_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_2 = par_self;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain__taskProfileInfo, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_2 );

        exception_lineno = 660;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_2 );
    tmp_source_name_6 = par_task;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_setFunction );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_7 = par_self;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain__profileTask );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 670;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 670;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_8 = par_task;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_setArgs );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_2 = PyList_New( 1 );
    tmp_source_name_9 = par_self;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_list_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain__taskProfileInfo );
    if ( tmp_list_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );
        Py_DECREF( tmp_args_element_name_2 );

        exception_lineno = 671;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    PyList_SET_ITEM( tmp_args_element_name_2, 0, tmp_list_element_1 );
    tmp_args_element_name_3 = Py_True;
    frame_function->m_frame.f_lineno = 671;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_profileInfo = python_pars[ 1 ];
    PyObject *par_task = python_pars[ 2 ];
    PyObject *var_appendTask = NULL;
    PyObject *var_taskArgs = NULL;
    PyObject *var_PS = NULL;
    PyObject *var_profileSession = NULL;
    PyObject *var_ret = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    int tmp_and_left_truth_1;
    PyObject *tmp_and_left_value_1;
    PyObject *tmp_and_right_value_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_name_2;
    PyObject *tmp_assattr_target_1;
    PyObject *tmp_assattr_target_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    Py_ssize_t tmp_slice_index_upper_1;
    PyObject *tmp_slice_source_1;
    Py_ssize_t tmp_sliceslicedel_index_lower_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_0fc3126900c7a9fcc9df582b4f7915e1, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_task );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 677;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = par_task;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 677;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 677;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_source_name_2 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_cond_value_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_profiled );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 679;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 679;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_raise_type_2 = PyExc_AssertionError;
    exception_type = tmp_raise_type_2;
    Py_INCREF( tmp_raise_type_2 );
    exception_lineno = 679;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = Py_False;
    assert( var_appendTask == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var_appendTask = tmp_assign_source_1;

    tmp_source_name_3 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_assign_source_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_taskArgs );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 683;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_taskArgs == NULL );
    var_taskArgs = tmp_assign_source_2;

    tmp_and_left_value_1 = var_taskArgs;

    CHECK_OBJECT( tmp_and_left_value_1 );
    tmp_and_left_truth_1 = CHECK_IF_TRUE( tmp_and_left_value_1 );
    if ( tmp_and_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_and_left_truth_1 == 1 )
    {
        goto and_right_1;
    }
    else
    {
        goto and_left_1;
    }
    and_right_1:;
    tmp_subscribed_name_1 = var_taskArgs;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_neg_1;
    tmp_compexpr_left_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = par_task;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_and_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_and_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 684;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_and_right_value_1;
    goto and_end_1;
    and_left_1:;
    Py_INCREF( tmp_and_left_value_1 );
    tmp_cond_value_2 = tmp_and_left_value_1;
    and_end_1:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 684;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_assign_source_3 = Py_True;
    {
        PyObject *old = var_appendTask;
        assert( old != NULL );
        var_appendTask = tmp_assign_source_3;
        Py_INCREF( var_appendTask );
        Py_DECREF( old );
    }

    tmp_sliceslicedel_index_lower_1 = 0;
    tmp_slice_index_upper_1 = -1;
    tmp_slice_source_1 = var_taskArgs;

    CHECK_OBJECT( tmp_slice_source_1 );
    tmp_assign_source_4 = LOOKUP_INDEX_SLICE( tmp_slice_source_1, tmp_sliceslicedel_index_lower_1, tmp_slice_index_upper_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_taskArgs;
        assert( old != NULL );
        var_taskArgs = tmp_assign_source_4;
        Py_DECREF( old );
    }

    branch_no_3:;
    tmp_called_instance_1 = par_task;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = var_taskArgs;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = var_appendTask;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 687;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_setArgs, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = par_task;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_setFunction );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 688;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_5 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_args_element_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_taskFunc );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 688;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 688;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 688;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib );

    if (unlikely( tmp_called_instance_2 == NULL ))
    {
        tmp_called_instance_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_importlib );
    }

    if ( tmp_called_instance_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "importlib" );
        exception_tb = NULL;

        exception_lineno = 692;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 692;
    tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_40c78e90f83f2d64d9fd828f457bffb6_tuple, 0 ) );

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 692;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_PS == NULL );
    var_PS = tmp_assign_source_5;

    tmp_source_name_6 = var_PS;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_ProfileSession );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = const_str_digest_014f9be8fa5c5a865d39b0a74bef3a6e;
    tmp_called_instance_3 = par_task;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 693;
    tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getName );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 693;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 693;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Functor );

    if (unlikely( tmp_dircall_arg1_1 == NULL ))
    {
        tmp_dircall_arg1_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Functor );
    }

    if ( tmp_dircall_arg1_1 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Functor" );
        exception_tb = NULL;

        exception_lineno = 694;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_source_name_7 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_tuple_element_1 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_taskFunc );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_dircall_arg2_1 );

        exception_lineno = 694;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_source_name_8 = par_profileInfo;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_dircall_arg3_1 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_taskArgs );
    if ( tmp_dircall_arg3_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );
        Py_DECREF( tmp_dircall_arg2_1 );

        exception_lineno = 694;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_INCREF( tmp_dircall_arg1_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
        tmp_args_element_name_5 = impl___internal__$$$function_5_complex_call_helper_pos_star_list( dir_call_args );
    }
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );
        Py_DECREF( tmp_args_element_name_4 );

        exception_lineno = 694;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 693;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_6 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_4 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_profileSession == NULL );
    var_profileSession = tmp_assign_source_6;

    tmp_called_instance_4 = var_profileSession;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 695;
    tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_run );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 695;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ret == NULL );
    var_ret = tmp_assign_source_7;

    tmp_assattr_name_1 = var_profileSession;

    CHECK_OBJECT( tmp_assattr_name_1 );
    tmp_assattr_target_1 = par_profileInfo;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_session, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_name_2 = Py_True;
    tmp_assattr_target_2 = par_profileInfo;

    CHECK_OBJECT( tmp_assattr_target_2 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_2, const_str_plain_profiled, tmp_assattr_name_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 699;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_profileInfo, par_task, var_appendTask, var_taskArgs, var_PS, var_profileSession, var_ret );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_ret;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileInfo );
    Py_DECREF( par_profileInfo );
    par_profileInfo = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)var_appendTask );
    Py_DECREF( var_appendTask );
    var_appendTask = NULL;

    CHECK_OBJECT( (PyObject *)var_taskArgs );
    Py_DECREF( var_taskArgs );
    var_taskArgs = NULL;

    CHECK_OBJECT( (PyObject *)var_PS );
    Py_DECREF( var_PS );
    var_PS = NULL;

    CHECK_OBJECT( (PyObject *)var_profileSession );
    Py_DECREF( var_profileSession );
    var_profileSession = NULL;

    CHECK_OBJECT( (PyObject *)var_ret );
    Py_DECREF( var_ret );
    var_ret = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_profileInfo );
    Py_DECREF( par_profileInfo );
    par_profileInfo = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    Py_XDECREF( var_appendTask );
    var_appendTask = NULL;

    Py_XDECREF( var_taskArgs );
    var_taskArgs = NULL;

    Py_XDECREF( var_PS );
    var_PS = NULL;

    Py_XDECREF( var_profileSession );
    var_profileSession = NULL;

    Py_XDECREF( var_ret );
    var_ret = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_55412ff8103be46f9405ae1c765f63e0, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfileInfo );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_profiled );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 705;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ad19eab5874f533bb4eb6b9c6695ecee, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_source_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain__taskProfileInfo );
    if ( tmp_source_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_session );
    Py_DECREF( tmp_source_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 708;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_now = NULL;
    PyObject *var_avgFrameRate = NULL;
    PyObject *var_avgFrameDur = NULL;
    PyObject *var_next = NULL;
    PyObject *var_tasks = NULL;
    PyObject *var_i = NULL;
    PyObject *var_task = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Lt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_isinstance_cls_1;
    PyObject *tmp_isinstance_inst_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_operand_name_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d89537e80c1f8aecb4da5c734ce0930b, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_globalClock );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 713;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 713;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getFrameTime );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 713;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_now == NULL );
    var_now = tmp_assign_source_1;

    tmp_source_name_2 = par_self;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_instance_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_globalClock );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 714;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getAverageFrameRate );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_avgFrameRate == NULL );
    var_avgFrameRate = tmp_assign_source_2;

    tmp_compare_left_1 = var_avgFrameRate;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = const_float_1e_minus_05;
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_assign_source_3 = const_float_0_0;
    assert( var_avgFrameDur == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_avgFrameDur = tmp_assign_source_3;

    goto branch_end_1;
    branch_no_1:;
    tmp_left_name_1 = const_float_1_0;
    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_instance_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_globalClock );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 718;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 718;
    tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getAverageFrameRate );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 718;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = BINARY_OPERATION_DIV( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 718;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_avgFrameDur == NULL );
    var_avgFrameDur = tmp_assign_source_4;

    branch_end_1:;
    tmp_left_name_2 = var_now;

    CHECK_OBJECT( tmp_left_name_2 );
    tmp_right_name_2 = var_avgFrameDur;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_assign_source_5 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 719;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_next == NULL );
    var_next = tmp_assign_source_5;

    tmp_source_name_4 = par_self;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_instance_4 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_mgr );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 722;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 722;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getTasks );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 722;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_tasks == NULL );
    var_tasks = tmp_assign_source_6;

    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_random );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_random );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "random" );
        exception_tb = NULL;

        exception_lineno = 723;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_randrange );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_5 = var_tasks;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 723;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getNumTasks );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 723;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 723;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_i == NULL );
    var_i = tmp_assign_source_7;

    tmp_called_instance_6 = var_tasks;

    CHECK_OBJECT( tmp_called_instance_6 );
    tmp_args_element_name_2 = var_i;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 724;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_getTask, call_args );
    }

    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 724;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_task == NULL );
    var_task = tmp_assign_source_8;

    loop_start_1:;
    tmp_isinstance_inst_1 = var_task;

    if ( tmp_isinstance_inst_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 725;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_PythonTask );

    if (unlikely( tmp_isinstance_cls_1 == NULL ))
    {
        tmp_isinstance_cls_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonTask );
    }

    if ( tmp_isinstance_cls_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "PythonTask" );
        exception_tb = NULL;

        exception_lineno = 725;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_operand_name_1 = BUILTIN_ISINSTANCE( tmp_isinstance_inst_1, tmp_isinstance_cls_1 );
    if ( tmp_operand_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = UNARY_OPERATION( UNARY_NOT, tmp_operand_name_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 726;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    tmp_called_instance_7 = var_task;

    if ( tmp_called_instance_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 726;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 726;
    tmp_compexpr_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getWakeTime );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 726;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = var_next;

    CHECK_OBJECT( tmp_compexpr_right_1 );
    tmp_or_right_value_1 = RICH_COMPARE_GT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 726;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    Py_INCREF( tmp_or_left_value_1 );
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 726;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    goto loop_end_1;
    branch_no_2:;
    tmp_source_name_6 = var_tasks;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_removeTask );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 727;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_3 = var_i;

    if ( tmp_args_element_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "i" );
        exception_tb = NULL;

        exception_lineno = 727;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 727;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 727;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_random );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_random );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "random" );
        exception_tb = NULL;

        exception_lineno = 728;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_randrange );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 728;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_8 = var_tasks;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 728;
    tmp_args_element_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getNumTasks );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 728;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 728;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_9 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 728;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_called_instance_9 = var_tasks;

    CHECK_OBJECT( tmp_called_instance_9 );
    tmp_args_element_name_5 = var_i;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 729;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_10 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_getTask, call_args );
    }

    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 729;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_task;
        var_task = tmp_assign_source_10;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    tmp_return_value = var_task;

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "task" );
        exception_tb = NULL;

        exception_lineno = 730;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_now, var_avgFrameRate, var_avgFrameDur, var_next, var_tasks, var_i, var_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_now );
    Py_DECREF( var_now );
    var_now = NULL;

    CHECK_OBJECT( (PyObject *)var_avgFrameRate );
    Py_DECREF( var_avgFrameRate );
    var_avgFrameRate = NULL;

    CHECK_OBJECT( (PyObject *)var_avgFrameDur );
    Py_DECREF( var_avgFrameDur );
    var_avgFrameDur = NULL;

    CHECK_OBJECT( (PyObject *)var_next );
    Py_DECREF( var_next );
    var_next = NULL;

    CHECK_OBJECT( (PyObject *)var_tasks );
    Py_DECREF( var_tasks );
    var_tasks = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_now );
    var_now = NULL;

    Py_XDECREF( var_avgFrameRate );
    var_avgFrameRate = NULL;

    Py_XDECREF( var_avgFrameDur );
    var_avgFrameDur = NULL;

    Py_XDECREF( var_next );
    var_next = NULL;

    Py_XDECREF( var_tasks );
    var_tasks = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_task );
    var_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_46___repr__( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_str_arg_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_95ee551f0efc18daaf624e3b714b82c1, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_self;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_str_arg_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_mgr );
    if ( tmp_str_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 733;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = PyObject_Str( tmp_str_arg_1 );
    Py_DECREF( tmp_str_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 733;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_46___repr__ );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_46___repr__ );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_47_doYield( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_frameStartTime = python_pars[ 1 ];
    PyObject *par_nextScheduledTaskTime = python_pars[ 2 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_47_doYield );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_frameStartTime );
    Py_DECREF( par_frameStartTime );
    par_frameStartTime = NULL;

    CHECK_OBJECT( (PyObject *)par_nextScheduledTaskTime );
    Py_DECREF( par_nextScheduledTaskTime );
    par_nextScheduledTaskTime = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_frameStartTime );
    Py_DECREF( par_frameStartTime );
    par_frameStartTime = NULL;

    CHECK_OBJECT( (PyObject *)par_nextScheduledTaskTime );
    Py_DECREF( par_nextScheduledTaskTime );
    par_nextScheduledTaskTime = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_47_doYield );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_tm = NULL;
    PyObject *var_l = NULL;
    PyObject *var__testDone = NULL;
    PyObject *var__testRemoveByName = NULL;
    PyObject *var__testDupNamedTasks = NULL;
    PyObject *var__testCont = NULL;
    PyObject *var__testContDone = NULL;
    PyObject *var__testHasTaskNamed = NULL;
    PyObject *var__testPri1 = NULL;
    PyObject *var__testPri2 = NULL;
    PyObject *var__testExtraArgs = NULL;
    PyObject *var__testAppendTask = NULL;
    PyObject *var__uponDeathFunc = NULL;
    PyObject *var__testUponDeath = NULL;
    PyObject *var__TaskOwner = NULL;
    PyObject *var_to = NULL;
    PyObject *var__testOwner = NULL;
    PyObject *var_doLaterTests = NULL;
    PyObject *var__testDoLater1 = NULL;
    PyObject *var__testDoLater2 = NULL;
    PyObject *var__monitorDoLater = NULL;
    PyObject *var__testDoLaterPri1 = NULL;
    PyObject *var__testDoLaterPri2 = NULL;
    PyObject *var__monitorDoLaterPri = NULL;
    PyObject *var__testDoLaterExtraArgs = NULL;
    PyObject *var__monitorDoLaterExtraArgs = NULL;
    PyObject *var__testDoLaterAppendTask = NULL;
    PyObject *var__monitorDoLaterAppendTask = NULL;
    PyObject *var__testUponDeathFunc = NULL;
    PyObject *var__testDoLaterUponDeath = NULL;
    PyObject *var__monitorDoLaterUponDeath = NULL;
    PyObject *var__DoLaterOwner = NULL;
    PyObject *var_doLaterOwner = NULL;
    PyObject *var__testDoLaterOwner = NULL;
    PyObject *var__monitorDoLaterOwner = NULL;
    PyObject *var__testGetTasks = NULL;
    PyObject *var__testGetDoLaters = NULL;
    PyObject *var__testDupNameDoLaters = NULL;
    PyObject *var__testDupNameDoLatersRemove = NULL;
    PyObject *var_dl1 = NULL;
    PyObject *var_dl2 = NULL;
    PyObject *var__testGetTasksNamed = NULL;
    PyObject *var__testRemoveTasksMatching = NULL;
    PyObject *var__testTaskObj = NULL;
    PyObject *var_t = NULL;
    PyObject *var__testTaskObjRemove = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *tmp_inplace_assign_subscr_2__target = NULL;
    PyObject *tmp_inplace_assign_subscr_3__target = NULL;
    PyObject *tmp_inplace_assign_subscr_4__target = NULL;
    PyObject *tmp_inplace_assign_subscr_5__target = NULL;
    PyObject *tmp_class_creation_2__class_dict = NULL;
    PyObject *tmp_class_creation_2__metaclass = NULL;
    PyObject *tmp_class_creation_2__class = NULL;
    PyObject *tmp_inplace_assign_subscr_6__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;
    PyObject *exception_keeper_type_8;
    PyObject *exception_keeper_value_8;
    PyTracebackObject *exception_keeper_tb_8;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_8;
    PyObject *exception_keeper_type_9;
    PyObject *exception_keeper_value_9;
    PyTracebackObject *exception_keeper_tb_9;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_9;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_args_element_name_50;
    PyObject *tmp_args_element_name_51;
    PyObject *tmp_args_element_name_52;
    PyObject *tmp_args_element_name_53;
    PyObject *tmp_args_element_name_54;
    PyObject *tmp_args_element_name_55;
    PyObject *tmp_args_element_name_56;
    PyObject *tmp_args_element_name_57;
    PyObject *tmp_args_element_name_58;
    PyObject *tmp_args_element_name_59;
    PyObject *tmp_args_element_name_60;
    PyObject *tmp_args_element_name_61;
    PyObject *tmp_args_element_name_62;
    PyObject *tmp_args_element_name_63;
    PyObject *tmp_args_element_name_64;
    PyObject *tmp_args_element_name_65;
    PyObject *tmp_args_element_name_66;
    PyObject *tmp_args_element_name_67;
    PyObject *tmp_args_element_name_68;
    PyObject *tmp_args_element_name_69;
    PyObject *tmp_args_element_name_70;
    PyObject *tmp_args_element_name_71;
    PyObject *tmp_args_element_name_72;
    PyObject *tmp_args_element_name_73;
    PyObject *tmp_args_element_name_74;
    PyObject *tmp_args_element_name_75;
    PyObject *tmp_args_element_name_76;
    PyObject *tmp_args_name_1;
    PyObject *tmp_args_name_2;
    PyObject *tmp_args_name_3;
    PyObject *tmp_args_name_4;
    PyObject *tmp_args_name_5;
    PyObject *tmp_args_name_6;
    PyObject *tmp_args_name_7;
    PyObject *tmp_args_name_8;
    PyObject *tmp_args_name_9;
    PyObject *tmp_args_name_10;
    PyObject *tmp_args_name_11;
    PyObject *tmp_args_name_12;
    PyObject *tmp_args_name_13;
    PyObject *tmp_args_name_14;
    PyObject *tmp_args_name_15;
    PyObject *tmp_args_name_16;
    PyObject *tmp_args_name_17;
    PyObject *tmp_args_name_18;
    PyObject *tmp_args_name_19;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscribed_3;
    PyObject *tmp_ass_subscribed_4;
    PyObject *tmp_ass_subscribed_5;
    PyObject *tmp_ass_subscribed_6;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subscript_3;
    PyObject *tmp_ass_subscript_4;
    PyObject *tmp_ass_subscript_5;
    PyObject *tmp_ass_subscript_6;
    int tmp_ass_subscript_res_1;
    int tmp_ass_subscript_res_2;
    int tmp_ass_subscript_res_3;
    int tmp_ass_subscript_res_4;
    int tmp_ass_subscript_res_5;
    int tmp_ass_subscript_res_6;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_ass_subvalue_3;
    PyObject *tmp_ass_subvalue_4;
    PyObject *tmp_ass_subvalue_5;
    PyObject *tmp_ass_subvalue_6;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_assign_source_63;
    PyObject *tmp_assign_source_64;
    PyObject *tmp_assign_source_65;
    PyObject *tmp_assign_source_66;
    PyObject *tmp_assign_source_67;
    PyObject *tmp_assign_source_68;
    PyObject *tmp_assign_source_69;
    PyObject *tmp_assign_source_70;
    PyObject *tmp_assign_source_71;
    PyObject *tmp_assign_source_72;
    PyObject *tmp_assign_source_73;
    PyObject *tmp_assign_source_74;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_bases_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_instance_16;
    PyObject *tmp_called_instance_17;
    PyObject *tmp_called_instance_18;
    PyObject *tmp_called_instance_19;
    PyObject *tmp_called_instance_20;
    PyObject *tmp_called_instance_21;
    PyObject *tmp_called_instance_22;
    PyObject *tmp_called_instance_23;
    PyObject *tmp_called_instance_24;
    PyObject *tmp_called_instance_25;
    PyObject *tmp_called_instance_26;
    PyObject *tmp_called_instance_27;
    PyObject *tmp_called_instance_28;
    PyObject *tmp_called_instance_29;
    PyObject *tmp_called_instance_30;
    PyObject *tmp_called_instance_31;
    PyObject *tmp_called_instance_32;
    PyObject *tmp_called_instance_33;
    PyObject *tmp_called_instance_34;
    PyObject *tmp_called_instance_35;
    PyObject *tmp_called_instance_36;
    PyObject *tmp_called_instance_37;
    PyObject *tmp_called_instance_38;
    PyObject *tmp_called_instance_39;
    PyObject *tmp_called_instance_40;
    PyObject *tmp_called_instance_41;
    PyObject *tmp_called_instance_42;
    PyObject *tmp_called_instance_43;
    PyObject *tmp_called_instance_44;
    PyObject *tmp_called_instance_45;
    PyObject *tmp_called_instance_46;
    PyObject *tmp_called_instance_47;
    PyObject *tmp_called_instance_48;
    PyObject *tmp_called_instance_49;
    PyObject *tmp_called_instance_50;
    PyObject *tmp_called_instance_51;
    PyObject *tmp_called_instance_52;
    PyObject *tmp_called_instance_53;
    PyObject *tmp_called_instance_54;
    PyObject *tmp_called_instance_55;
    PyObject *tmp_called_instance_56;
    PyObject *tmp_called_instance_57;
    PyObject *tmp_called_instance_58;
    PyObject *tmp_called_instance_59;
    PyObject *tmp_called_instance_60;
    PyObject *tmp_called_instance_61;
    PyObject *tmp_called_instance_62;
    PyObject *tmp_called_instance_63;
    PyObject *tmp_called_instance_64;
    PyObject *tmp_called_instance_65;
    PyObject *tmp_called_instance_66;
    PyObject *tmp_called_instance_67;
    PyObject *tmp_called_instance_68;
    PyObject *tmp_called_instance_69;
    PyObject *tmp_called_instance_70;
    PyObject *tmp_called_instance_71;
    PyObject *tmp_called_instance_72;
    PyObject *tmp_called_instance_73;
    PyObject *tmp_called_instance_74;
    PyObject *tmp_called_instance_75;
    PyObject *tmp_called_instance_76;
    PyObject *tmp_called_instance_77;
    PyObject *tmp_called_instance_78;
    PyObject *tmp_called_instance_79;
    PyObject *tmp_called_instance_80;
    PyObject *tmp_called_instance_81;
    PyObject *tmp_called_instance_82;
    PyObject *tmp_called_instance_83;
    PyObject *tmp_called_instance_84;
    PyObject *tmp_called_instance_85;
    PyObject *tmp_called_instance_86;
    PyObject *tmp_called_instance_87;
    PyObject *tmp_called_instance_88;
    PyObject *tmp_called_instance_89;
    PyObject *tmp_called_instance_90;
    PyObject *tmp_called_instance_91;
    PyObject *tmp_called_instance_92;
    PyObject *tmp_called_instance_93;
    PyObject *tmp_called_instance_94;
    PyObject *tmp_called_instance_95;
    PyObject *tmp_called_instance_96;
    PyObject *tmp_called_instance_97;
    PyObject *tmp_called_instance_98;
    PyObject *tmp_called_instance_99;
    PyObject *tmp_called_instance_100;
    PyObject *tmp_called_instance_101;
    PyObject *tmp_called_instance_102;
    PyObject *tmp_called_instance_103;
    PyObject *tmp_called_instance_104;
    PyObject *tmp_called_instance_105;
    PyObject *tmp_called_instance_106;
    PyObject *tmp_called_instance_107;
    PyObject *tmp_called_instance_108;
    PyObject *tmp_called_instance_109;
    PyObject *tmp_called_instance_110;
    PyObject *tmp_called_instance_111;
    PyObject *tmp_called_instance_112;
    PyObject *tmp_called_instance_113;
    PyObject *tmp_called_instance_114;
    PyObject *tmp_called_instance_115;
    PyObject *tmp_called_instance_116;
    PyObject *tmp_called_instance_117;
    PyObject *tmp_called_instance_118;
    PyObject *tmp_called_instance_119;
    PyObject *tmp_called_instance_120;
    PyObject *tmp_called_instance_121;
    PyObject *tmp_called_instance_122;
    PyObject *tmp_called_instance_123;
    PyObject *tmp_called_instance_124;
    PyObject *tmp_called_instance_125;
    PyObject *tmp_called_instance_126;
    PyObject *tmp_called_instance_127;
    PyObject *tmp_called_instance_128;
    PyObject *tmp_called_instance_129;
    PyObject *tmp_called_instance_130;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Eq_3;
    int tmp_cmp_Eq_4;
    int tmp_cmp_Eq_5;
    int tmp_cmp_Eq_6;
    int tmp_cmp_Eq_7;
    int tmp_cmp_Eq_8;
    int tmp_cmp_Eq_9;
    int tmp_cmp_Eq_10;
    int tmp_cmp_Eq_11;
    int tmp_cmp_Eq_12;
    int tmp_cmp_Eq_13;
    int tmp_cmp_Eq_14;
    int tmp_cmp_Eq_15;
    int tmp_cmp_Eq_16;
    int tmp_cmp_Eq_17;
    int tmp_cmp_Eq_18;
    int tmp_cmp_Eq_19;
    int tmp_cmp_Eq_20;
    int tmp_cmp_Eq_21;
    int tmp_cmp_Eq_22;
    int tmp_cmp_Eq_23;
    int tmp_cmp_Eq_24;
    int tmp_cmp_Eq_25;
    int tmp_cmp_Eq_26;
    int tmp_cmp_Eq_27;
    int tmp_cmp_Eq_28;
    int tmp_cmp_Eq_29;
    int tmp_cmp_Eq_30;
    int tmp_cmp_Eq_31;
    int tmp_cmp_Eq_32;
    int tmp_cmp_Eq_33;
    int tmp_cmp_Eq_34;
    int tmp_cmp_Eq_35;
    int tmp_cmp_Eq_36;
    int tmp_cmp_Eq_37;
    int tmp_cmp_Eq_38;
    int tmp_cmp_Eq_39;
    int tmp_cmp_Eq_40;
    int tmp_cmp_Eq_41;
    int tmp_cmp_Eq_42;
    int tmp_cmp_Eq_43;
    int tmp_cmp_Eq_44;
    int tmp_cmp_Eq_45;
    int tmp_cmp_Eq_46;
    int tmp_cmp_Eq_47;
    int tmp_cmp_Eq_48;
    int tmp_cmp_Eq_49;
    int tmp_cmp_Eq_50;
    int tmp_cmp_Eq_51;
    int tmp_cmp_Eq_52;
    int tmp_cmp_Eq_53;
    int tmp_cmp_Eq_54;
    int tmp_cmp_Eq_55;
    int tmp_cmp_Eq_56;
    int tmp_cmp_Eq_57;
    int tmp_cmp_Eq_58;
    int tmp_cmp_Eq_59;
    int tmp_cmp_Gt_1;
    int tmp_cmp_In_1;
    int tmp_cmp_In_2;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_left_10;
    PyObject *tmp_compare_left_11;
    PyObject *tmp_compare_left_12;
    PyObject *tmp_compare_left_13;
    PyObject *tmp_compare_left_14;
    PyObject *tmp_compare_left_15;
    PyObject *tmp_compare_left_16;
    PyObject *tmp_compare_left_17;
    PyObject *tmp_compare_left_18;
    PyObject *tmp_compare_left_19;
    PyObject *tmp_compare_left_20;
    PyObject *tmp_compare_left_21;
    PyObject *tmp_compare_left_22;
    PyObject *tmp_compare_left_23;
    PyObject *tmp_compare_left_24;
    PyObject *tmp_compare_left_25;
    PyObject *tmp_compare_left_26;
    PyObject *tmp_compare_left_27;
    PyObject *tmp_compare_left_28;
    PyObject *tmp_compare_left_29;
    PyObject *tmp_compare_left_30;
    PyObject *tmp_compare_left_31;
    PyObject *tmp_compare_left_32;
    PyObject *tmp_compare_left_33;
    PyObject *tmp_compare_left_34;
    PyObject *tmp_compare_left_35;
    PyObject *tmp_compare_left_36;
    PyObject *tmp_compare_left_37;
    PyObject *tmp_compare_left_38;
    PyObject *tmp_compare_left_39;
    PyObject *tmp_compare_left_40;
    PyObject *tmp_compare_left_41;
    PyObject *tmp_compare_left_42;
    PyObject *tmp_compare_left_43;
    PyObject *tmp_compare_left_44;
    PyObject *tmp_compare_left_45;
    PyObject *tmp_compare_left_46;
    PyObject *tmp_compare_left_47;
    PyObject *tmp_compare_left_48;
    PyObject *tmp_compare_left_49;
    PyObject *tmp_compare_left_50;
    PyObject *tmp_compare_left_51;
    PyObject *tmp_compare_left_52;
    PyObject *tmp_compare_left_53;
    PyObject *tmp_compare_left_54;
    PyObject *tmp_compare_left_55;
    PyObject *tmp_compare_left_56;
    PyObject *tmp_compare_left_57;
    PyObject *tmp_compare_left_58;
    PyObject *tmp_compare_left_59;
    PyObject *tmp_compare_left_60;
    PyObject *tmp_compare_left_61;
    PyObject *tmp_compare_left_62;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compare_right_10;
    PyObject *tmp_compare_right_11;
    PyObject *tmp_compare_right_12;
    PyObject *tmp_compare_right_13;
    PyObject *tmp_compare_right_14;
    PyObject *tmp_compare_right_15;
    PyObject *tmp_compare_right_16;
    PyObject *tmp_compare_right_17;
    PyObject *tmp_compare_right_18;
    PyObject *tmp_compare_right_19;
    PyObject *tmp_compare_right_20;
    PyObject *tmp_compare_right_21;
    PyObject *tmp_compare_right_22;
    PyObject *tmp_compare_right_23;
    PyObject *tmp_compare_right_24;
    PyObject *tmp_compare_right_25;
    PyObject *tmp_compare_right_26;
    PyObject *tmp_compare_right_27;
    PyObject *tmp_compare_right_28;
    PyObject *tmp_compare_right_29;
    PyObject *tmp_compare_right_30;
    PyObject *tmp_compare_right_31;
    PyObject *tmp_compare_right_32;
    PyObject *tmp_compare_right_33;
    PyObject *tmp_compare_right_34;
    PyObject *tmp_compare_right_35;
    PyObject *tmp_compare_right_36;
    PyObject *tmp_compare_right_37;
    PyObject *tmp_compare_right_38;
    PyObject *tmp_compare_right_39;
    PyObject *tmp_compare_right_40;
    PyObject *tmp_compare_right_41;
    PyObject *tmp_compare_right_42;
    PyObject *tmp_compare_right_43;
    PyObject *tmp_compare_right_44;
    PyObject *tmp_compare_right_45;
    PyObject *tmp_compare_right_46;
    PyObject *tmp_compare_right_47;
    PyObject *tmp_compare_right_48;
    PyObject *tmp_compare_right_49;
    PyObject *tmp_compare_right_50;
    PyObject *tmp_compare_right_51;
    PyObject *tmp_compare_right_52;
    PyObject *tmp_compare_right_53;
    PyObject *tmp_compare_right_54;
    PyObject *tmp_compare_right_55;
    PyObject *tmp_compare_right_56;
    PyObject *tmp_compare_right_57;
    PyObject *tmp_compare_right_58;
    PyObject *tmp_compare_right_59;
    PyObject *tmp_compare_right_60;
    PyObject *tmp_compare_right_61;
    PyObject *tmp_compare_right_62;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_defaults_8;
    PyObject *tmp_defaults_9;
    PyObject *tmp_defaults_10;
    PyObject *tmp_defaults_11;
    PyObject *tmp_defaults_12;
    PyObject *tmp_defaults_13;
    PyObject *tmp_defaults_14;
    PyObject *tmp_defaults_15;
    PyObject *tmp_defaults_16;
    PyObject *tmp_defaults_17;
    PyObject *tmp_defaults_18;
    PyObject *tmp_defaults_19;
    PyObject *tmp_defaults_20;
    PyObject *tmp_defaults_21;
    PyObject *tmp_defaults_22;
    PyObject *tmp_defaults_23;
    PyObject *tmp_defaults_24;
    PyObject *tmp_defaults_25;
    PyObject *tmp_dict_key_1;
    PyObject *tmp_dict_key_2;
    PyObject *tmp_dict_key_3;
    PyObject *tmp_dict_key_4;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_dict_name_2;
    PyObject *tmp_dict_value_1;
    PyObject *tmp_dict_value_2;
    PyObject *tmp_dict_value_3;
    PyObject *tmp_dict_value_4;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_attr_2;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_default_2;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_getattr_target_2;
    PyObject *tmp_key_name_1;
    PyObject *tmp_key_name_2;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_kw_name_2;
    PyObject *tmp_kw_name_3;
    PyObject *tmp_kw_name_4;
    PyObject *tmp_kw_name_5;
    PyObject *tmp_kw_name_6;
    PyObject *tmp_kw_name_7;
    PyObject *tmp_kw_name_8;
    PyObject *tmp_kw_name_9;
    PyObject *tmp_kw_name_10;
    PyObject *tmp_kw_name_11;
    PyObject *tmp_kw_name_12;
    PyObject *tmp_kw_name_13;
    PyObject *tmp_kw_name_14;
    PyObject *tmp_kw_name_15;
    PyObject *tmp_kw_name_16;
    PyObject *tmp_kw_name_17;
    PyObject *tmp_kw_name_18;
    PyObject *tmp_kw_name_19;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_len_arg_3;
    PyObject *tmp_len_arg_4;
    PyObject *tmp_len_arg_5;
    PyObject *tmp_len_arg_6;
    PyObject *tmp_len_arg_7;
    PyObject *tmp_len_arg_8;
    PyObject *tmp_len_arg_9;
    PyObject *tmp_len_arg_10;
    PyObject *tmp_len_arg_11;
    PyObject *tmp_len_arg_12;
    PyObject *tmp_len_arg_13;
    PyObject *tmp_len_arg_14;
    PyObject *tmp_len_arg_15;
    PyObject *tmp_len_arg_16;
    PyObject *tmp_len_arg_17;
    PyObject *tmp_len_arg_18;
    PyObject *tmp_len_arg_19;
    PyObject *tmp_len_arg_20;
    PyObject *tmp_len_arg_21;
    PyObject *tmp_len_arg_22;
    PyObject *tmp_len_arg_23;
    PyObject *tmp_len_arg_24;
    PyObject *tmp_len_arg_25;
    PyObject *tmp_len_arg_26;
    PyObject *tmp_len_arg_27;
    PyObject *tmp_len_arg_28;
    PyObject *tmp_len_arg_29;
    PyObject *tmp_len_arg_30;
    PyObject *tmp_len_arg_31;
    PyObject *tmp_len_arg_32;
    PyObject *tmp_len_arg_33;
    PyObject *tmp_len_arg_34;
    PyObject *tmp_len_arg_35;
    PyObject *tmp_len_arg_36;
    PyObject *tmp_len_arg_37;
    PyObject *tmp_len_arg_38;
    PyObject *tmp_len_arg_39;
    PyObject *tmp_len_arg_40;
    PyObject *tmp_len_arg_41;
    PyObject *tmp_len_arg_42;
    PyObject *tmp_len_arg_43;
    PyObject *tmp_len_arg_44;
    PyObject *tmp_len_arg_45;
    PyObject *tmp_len_arg_46;
    PyObject *tmp_len_arg_47;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_raise_type_3;
    PyObject *tmp_raise_type_4;
    PyObject *tmp_raise_type_5;
    PyObject *tmp_raise_type_6;
    PyObject *tmp_raise_type_7;
    PyObject *tmp_raise_type_8;
    PyObject *tmp_raise_type_9;
    PyObject *tmp_raise_type_10;
    PyObject *tmp_raise_type_11;
    PyObject *tmp_raise_type_12;
    PyObject *tmp_raise_type_13;
    PyObject *tmp_raise_type_14;
    PyObject *tmp_raise_type_15;
    PyObject *tmp_raise_type_16;
    PyObject *tmp_raise_type_17;
    PyObject *tmp_raise_type_18;
    PyObject *tmp_raise_type_19;
    PyObject *tmp_raise_type_20;
    PyObject *tmp_raise_type_21;
    PyObject *tmp_raise_type_22;
    PyObject *tmp_raise_type_23;
    PyObject *tmp_raise_type_24;
    PyObject *tmp_raise_type_25;
    PyObject *tmp_raise_type_26;
    PyObject *tmp_raise_type_27;
    PyObject *tmp_raise_type_28;
    PyObject *tmp_raise_type_29;
    PyObject *tmp_raise_type_30;
    PyObject *tmp_raise_type_31;
    PyObject *tmp_raise_type_32;
    PyObject *tmp_raise_type_33;
    PyObject *tmp_raise_type_34;
    PyObject *tmp_raise_type_35;
    PyObject *tmp_raise_type_36;
    PyObject *tmp_raise_type_37;
    PyObject *tmp_raise_type_38;
    PyObject *tmp_raise_type_39;
    PyObject *tmp_raise_type_40;
    PyObject *tmp_raise_type_41;
    PyObject *tmp_raise_type_42;
    PyObject *tmp_raise_type_43;
    PyObject *tmp_raise_type_44;
    PyObject *tmp_raise_type_45;
    PyObject *tmp_raise_type_46;
    PyObject *tmp_raise_type_47;
    PyObject *tmp_raise_type_48;
    PyObject *tmp_raise_type_49;
    PyObject *tmp_raise_type_50;
    PyObject *tmp_raise_type_51;
    PyObject *tmp_raise_type_52;
    PyObject *tmp_raise_type_53;
    PyObject *tmp_raise_type_54;
    PyObject *tmp_raise_type_55;
    PyObject *tmp_raise_type_56;
    PyObject *tmp_raise_type_57;
    PyObject *tmp_raise_type_58;
    PyObject *tmp_raise_type_59;
    PyObject *tmp_raise_type_60;
    PyObject *tmp_raise_type_61;
    PyObject *tmp_raise_type_62;
    PyObject *tmp_raise_type_63;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_source_name_17;
    PyObject *tmp_source_name_18;
    PyObject *tmp_source_name_19;
    PyObject *tmp_source_name_20;
    PyObject *tmp_source_name_21;
    PyObject *tmp_source_name_22;
    PyObject *tmp_source_name_23;
    PyObject *tmp_source_name_24;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscribed_name_10;
    PyObject *tmp_subscribed_name_11;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_subscript_name_10;
    PyObject *tmp_subscript_name_11;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    PyObject *tmp_tuple_element_8;
    PyObject *tmp_tuple_element_9;
    PyObject *tmp_tuple_element_10;
    PyObject *tmp_tuple_element_11;
    PyObject *tmp_tuple_element_12;
    PyObject *tmp_tuple_element_13;
    PyObject *tmp_tuple_element_14;
    PyObject *tmp_tuple_element_15;
    PyObject *tmp_tuple_element_16;
    PyObject *tmp_tuple_element_17;
    PyObject *tmp_tuple_element_18;
    PyObject *tmp_tuple_element_19;
    PyObject *tmp_tuple_element_20;
    PyObject *tmp_tuple_element_21;
    PyObject *tmp_tuple_element_22;
    PyObject *tmp_tuple_element_23;
    PyObject *tmp_tuple_element_24;
    PyObject *tmp_tuple_element_25;
    PyObject *tmp_tuple_element_26;
    PyObject *tmp_tuple_element_27;
    PyObject *tmp_tuple_element_28;
    PyObject *tmp_tuple_element_29;
    PyObject *tmp_tuple_element_30;
    PyObject *tmp_tuple_element_31;
    PyObject *tmp_tuple_element_32;
    PyObject *tmp_tuple_element_33;
    PyObject *tmp_tuple_element_34;
    PyObject *tmp_tuple_element_35;
    PyObject *tmp_tuple_element_36;
    PyObject *tmp_tuple_element_37;
    PyObject *tmp_tuple_element_38;
    PyObject *tmp_tuple_element_39;
    PyObject *tmp_tuple_element_40;
    PyObject *tmp_tuple_element_41;
    PyObject *tmp_tuple_element_42;
    PyObject *tmp_tuple_element_43;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bc19b89aaa8ec43cf5aebdc7db613c7d, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_TaskManager );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_TaskManager );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "TaskManager" );
        exception_tb = NULL;

        exception_lineno = 766;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 766;
    tmp_assign_source_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 766;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_tm == NULL );
    var_tm = tmp_assign_source_1;

    tmp_source_name_1 = var_tm;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_setClock );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ClockObject );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_ClockObject );
    }

    if ( tmp_called_name_3 == NULL )
    {
        Py_DECREF( tmp_called_name_2 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "ClockObject" );
        exception_tb = NULL;

        exception_lineno = 767;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 767;
    tmp_args_element_name_1 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 767;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 767;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = var_tm;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_setupTaskChain );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 768;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_1 = const_tuple_str_plain_default_tuple;
    tmp_kw_name_1 = PyDict_Copy( const_dict_e43c4b6e448be1e6a26efea5089b8672 );
    frame_function->m_frame.f_lineno = 768;
    tmp_unused = CALL_FUNCTION( tmp_called_name_4, tmp_args_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 768;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_1 = var_tm;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 771;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain__startTrackingMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 771;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_tm;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 772;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 772;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_2 = PyList_New( 0 );
    assert( var_l == NULL );
    var_l = tmp_assign_source_2;

    tmp_defaults_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_l;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_defaults_1, 0, tmp_tuple_element_1 );
    tmp_assign_source_3 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone( tmp_defaults_1 );
    assert( var__testDone == NULL );
    var__testDone = tmp_assign_source_3;

    tmp_called_instance_3 = var_tm;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_2 = var__testDone;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = const_str_plain_testDone;
    frame_function->m_frame.f_lineno = 779;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = var_tm;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 780;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 780;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_1 = var_l;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    assert( tmp_compare_left_1 != NULL );
    tmp_compare_right_1 = const_int_pos_1;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 781;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 781;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_5 = var_tm;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 782;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 782;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_2 = var_l;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_compare_left_2 = BUILTIN_LEN( tmp_len_arg_2 );
    assert( tmp_compare_left_2 != NULL );
    tmp_compare_right_2 = const_int_pos_1;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 783;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_2 = PyExc_AssertionError;
    exception_type = tmp_raise_type_2;
    Py_INCREF( tmp_raise_type_2 );
    exception_lineno = 783;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    Py_XDECREF( var__testDone );
    var__testDone = NULL;

    tmp_called_instance_6 = var_tm;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 785;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_4 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName(  );
    assert( var__testRemoveByName == NULL );
    var__testRemoveByName = tmp_assign_source_4;

    tmp_called_instance_7 = var_tm;

    CHECK_OBJECT( tmp_called_instance_7 );
    tmp_args_element_name_4 = var__testRemoveByName;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = const_str_plain_testRemoveByName;
    frame_function->m_frame.f_lineno = 790;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_7, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 790;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_8 = var_tm;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 791;
    tmp_compare_left_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_8, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveByName_tuple, 0 ) );

    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 791;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_int_pos_1;
    tmp_cmp_Eq_3 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 791;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_3 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_raise_type_3 = PyExc_AssertionError;
    exception_type = tmp_raise_type_3;
    Py_INCREF( tmp_raise_type_3 );
    exception_lineno = 791;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_called_instance_9 = var_tm;

    CHECK_OBJECT( tmp_called_instance_9 );
    frame_function->m_frame.f_lineno = 792;
    tmp_compare_left_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_9, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveByName_tuple, 0 ) );

    if ( tmp_compare_left_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_4 = const_int_0;
    tmp_cmp_Eq_4 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Eq_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_4 );

        exception_lineno = 792;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_4 );
    if ( tmp_cmp_Eq_4 == 1 )
    {
        goto branch_no_4;
    }
    else
    {
        goto branch_yes_4;
    }
    branch_yes_4:;
    tmp_raise_type_4 = PyExc_AssertionError;
    exception_type = tmp_raise_type_4;
    Py_INCREF( tmp_raise_type_4 );
    exception_lineno = 792;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_4:;
    Py_XDECREF( var__testRemoveByName );
    var__testRemoveByName = NULL;

    tmp_called_instance_10 = var_tm;

    CHECK_OBJECT( tmp_called_instance_10 );
    frame_function->m_frame.f_lineno = 794;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_5 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks(  );
    assert( var__testDupNamedTasks == NULL );
    var__testDupNamedTasks = tmp_assign_source_5;

    tmp_called_instance_11 = var_tm;

    CHECK_OBJECT( tmp_called_instance_11 );
    tmp_args_element_name_6 = var__testDupNamedTasks;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = const_str_plain_testDupNamedTasks;
    frame_function->m_frame.f_lineno = 799;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_11, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 799;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_12 = var_tm;

    CHECK_OBJECT( tmp_called_instance_12 );
    tmp_args_element_name_8 = var__testDupNamedTasks;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = const_str_plain_testDupNamedTasks;
    frame_function->m_frame.f_lineno = 800;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_12, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 800;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_13 = var_tm;

    CHECK_OBJECT( tmp_called_instance_13 );
    frame_function->m_frame.f_lineno = 801;
    tmp_compare_left_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_13, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveByName_tuple, 0 ) );

    if ( tmp_compare_left_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 801;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_5 = const_int_0;
    tmp_cmp_Eq_5 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Eq_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_5 );

        exception_lineno = 801;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_5 );
    if ( tmp_cmp_Eq_5 == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_raise_type_5 = PyExc_AssertionError;
    exception_type = tmp_raise_type_5;
    Py_INCREF( tmp_raise_type_5 );
    exception_lineno = 801;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_5:;
    Py_XDECREF( var__testDupNamedTasks );
    var__testDupNamedTasks = NULL;

    tmp_called_instance_14 = var_tm;

    CHECK_OBJECT( tmp_called_instance_14 );
    frame_function->m_frame.f_lineno = 803;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_14, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_6 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_6;
        Py_DECREF( old );
    }

    tmp_defaults_2 = PyTuple_New( 1 );
    tmp_tuple_element_2 = var_l;

    CHECK_OBJECT( tmp_tuple_element_2 );
    Py_INCREF( tmp_tuple_element_2 );
    PyTuple_SET_ITEM( tmp_defaults_2, 0, tmp_tuple_element_2 );
    tmp_assign_source_7 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont( tmp_defaults_2 );
    assert( var__testCont == NULL );
    var__testCont = tmp_assign_source_7;

    tmp_called_instance_15 = var_tm;

    CHECK_OBJECT( tmp_called_instance_15 );
    tmp_args_element_name_10 = var__testCont;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = const_str_plain_testCont;
    frame_function->m_frame.f_lineno = 810;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_15, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 810;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_16 = var_tm;

    CHECK_OBJECT( tmp_called_instance_16 );
    frame_function->m_frame.f_lineno = 811;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_16, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 811;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_3 = var_l;

    CHECK_OBJECT( tmp_len_arg_3 );
    tmp_compare_left_6 = BUILTIN_LEN( tmp_len_arg_3 );
    assert( tmp_compare_left_6 != NULL );
    tmp_compare_right_6 = const_int_pos_1;
    tmp_cmp_Eq_6 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Eq_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_6 );

        exception_lineno = 812;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_6 );
    if ( tmp_cmp_Eq_6 == 1 )
    {
        goto branch_no_6;
    }
    else
    {
        goto branch_yes_6;
    }
    branch_yes_6:;
    tmp_raise_type_6 = PyExc_AssertionError;
    exception_type = tmp_raise_type_6;
    Py_INCREF( tmp_raise_type_6 );
    exception_lineno = 812;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_6:;
    tmp_called_instance_17 = var_tm;

    CHECK_OBJECT( tmp_called_instance_17 );
    frame_function->m_frame.f_lineno = 813;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_17, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 813;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_4 = var_l;

    CHECK_OBJECT( tmp_len_arg_4 );
    tmp_compare_left_7 = BUILTIN_LEN( tmp_len_arg_4 );
    assert( tmp_compare_left_7 != NULL );
    tmp_compare_right_7 = const_int_pos_2;
    tmp_cmp_Eq_7 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Eq_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_7 );

        exception_lineno = 814;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_7 );
    if ( tmp_cmp_Eq_7 == 1 )
    {
        goto branch_no_7;
    }
    else
    {
        goto branch_yes_7;
    }
    branch_yes_7:;
    tmp_raise_type_7 = PyExc_AssertionError;
    exception_type = tmp_raise_type_7;
    Py_INCREF( tmp_raise_type_7 );
    exception_lineno = 814;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_7:;
    tmp_called_instance_18 = var_tm;

    CHECK_OBJECT( tmp_called_instance_18 );
    frame_function->m_frame.f_lineno = 815;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_18, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testCont_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 815;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testCont );
    var__testCont = NULL;

    tmp_called_instance_19 = var_tm;

    CHECK_OBJECT( tmp_called_instance_19 );
    frame_function->m_frame.f_lineno = 817;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_19, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_8 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_8;
        Py_DECREF( old );
    }

    tmp_defaults_3 = PyTuple_New( 1 );
    tmp_tuple_element_3 = var_l;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_defaults_3, 0, tmp_tuple_element_3 );
    tmp_assign_source_9 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone( tmp_defaults_3 );
    assert( var__testContDone == NULL );
    var__testContDone = tmp_assign_source_9;

    tmp_called_instance_20 = var_tm;

    CHECK_OBJECT( tmp_called_instance_20 );
    tmp_args_element_name_12 = var__testContDone;

    CHECK_OBJECT( tmp_args_element_name_12 );
    tmp_args_element_name_13 = const_str_plain_testContDone;
    frame_function->m_frame.f_lineno = 827;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_20, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 827;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_21 = var_tm;

    CHECK_OBJECT( tmp_called_instance_21 );
    frame_function->m_frame.f_lineno = 828;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_21, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_5 = var_l;

    CHECK_OBJECT( tmp_len_arg_5 );
    tmp_compare_left_8 = BUILTIN_LEN( tmp_len_arg_5 );
    assert( tmp_compare_left_8 != NULL );
    tmp_compare_right_8 = const_int_pos_1;
    tmp_cmp_Eq_8 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_cmp_Eq_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_8 );

        exception_lineno = 829;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_8 );
    if ( tmp_cmp_Eq_8 == 1 )
    {
        goto branch_no_8;
    }
    else
    {
        goto branch_yes_8;
    }
    branch_yes_8:;
    tmp_raise_type_8 = PyExc_AssertionError;
    exception_type = tmp_raise_type_8;
    Py_INCREF( tmp_raise_type_8 );
    exception_lineno = 829;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_8:;
    tmp_called_instance_22 = var_tm;

    CHECK_OBJECT( tmp_called_instance_22 );
    frame_function->m_frame.f_lineno = 830;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_22, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_6 = var_l;

    CHECK_OBJECT( tmp_len_arg_6 );
    tmp_compare_left_9 = BUILTIN_LEN( tmp_len_arg_6 );
    assert( tmp_compare_left_9 != NULL );
    tmp_compare_right_9 = const_int_pos_2;
    tmp_cmp_Eq_9 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_9, tmp_compare_right_9 );
    if ( tmp_cmp_Eq_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_9 );

        exception_lineno = 831;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_9 );
    if ( tmp_cmp_Eq_9 == 1 )
    {
        goto branch_no_9;
    }
    else
    {
        goto branch_yes_9;
    }
    branch_yes_9:;
    tmp_raise_type_9 = PyExc_AssertionError;
    exception_type = tmp_raise_type_9;
    Py_INCREF( tmp_raise_type_9 );
    exception_lineno = 831;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_9:;
    tmp_called_instance_23 = var_tm;

    CHECK_OBJECT( tmp_called_instance_23 );
    frame_function->m_frame.f_lineno = 832;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_23, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_7 = var_l;

    CHECK_OBJECT( tmp_len_arg_7 );
    tmp_compare_left_10 = BUILTIN_LEN( tmp_len_arg_7 );
    assert( tmp_compare_left_10 != NULL );
    tmp_compare_right_10 = const_int_pos_2;
    tmp_cmp_Eq_10 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_10, tmp_compare_right_10 );
    if ( tmp_cmp_Eq_10 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_10 );

        exception_lineno = 833;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_10 );
    if ( tmp_cmp_Eq_10 == 1 )
    {
        goto branch_no_10;
    }
    else
    {
        goto branch_yes_10;
    }
    branch_yes_10:;
    tmp_raise_type_10 = PyExc_AssertionError;
    exception_type = tmp_raise_type_10;
    Py_INCREF( tmp_raise_type_10 );
    exception_lineno = 833;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_10:;
    tmp_called_instance_24 = var_tm;

    CHECK_OBJECT( tmp_called_instance_24 );
    frame_function->m_frame.f_lineno = 834;
    tmp_cond_value_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_24, const_str_plain_hasTaskNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testContDone_tuple, 0 ) );

    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 834;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_raise_type_11 = PyExc_AssertionError;
    exception_type = tmp_raise_type_11;
    Py_INCREF( tmp_raise_type_11 );
    exception_lineno = 834;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_11:;
    Py_XDECREF( var__testContDone );
    var__testContDone = NULL;

    tmp_called_instance_25 = var_tm;

    CHECK_OBJECT( tmp_called_instance_25 );
    frame_function->m_frame.f_lineno = 836;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_25, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 836;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_10 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed(  );
    assert( var__testHasTaskNamed == NULL );
    var__testHasTaskNamed = tmp_assign_source_10;

    tmp_called_instance_26 = var_tm;

    CHECK_OBJECT( tmp_called_instance_26 );
    tmp_args_element_name_14 = var__testHasTaskNamed;

    CHECK_OBJECT( tmp_args_element_name_14 );
    tmp_args_element_name_15 = const_str_plain_testHasTaskNamed;
    frame_function->m_frame.f_lineno = 841;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_15 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_26, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 841;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_27 = var_tm;

    CHECK_OBJECT( tmp_called_instance_27 );
    frame_function->m_frame.f_lineno = 842;
    tmp_cond_value_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_27, const_str_plain_hasTaskNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testHasTaskNamed_tuple, 0 ) );

    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 842;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 842;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_12;
    }
    else
    {
        goto branch_yes_12;
    }
    branch_yes_12:;
    tmp_raise_type_12 = PyExc_AssertionError;
    exception_type = tmp_raise_type_12;
    Py_INCREF( tmp_raise_type_12 );
    exception_lineno = 842;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_12:;
    tmp_called_instance_28 = var_tm;

    CHECK_OBJECT( tmp_called_instance_28 );
    frame_function->m_frame.f_lineno = 843;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_28, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 843;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_29 = var_tm;

    CHECK_OBJECT( tmp_called_instance_29 );
    frame_function->m_frame.f_lineno = 844;
    tmp_cond_value_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_29, const_str_plain_hasTaskNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testHasTaskNamed_tuple, 0 ) );

    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 844;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 844;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_raise_type_13 = PyExc_AssertionError;
    exception_type = tmp_raise_type_13;
    Py_INCREF( tmp_raise_type_13 );
    exception_lineno = 844;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_13:;
    Py_XDECREF( var__testHasTaskNamed );
    var__testHasTaskNamed = NULL;

    tmp_called_instance_30 = var_tm;

    CHECK_OBJECT( tmp_called_instance_30 );
    frame_function->m_frame.f_lineno = 846;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_30, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 846;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_11 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_11;
        Py_DECREF( old );
    }

    tmp_defaults_4 = PyTuple_New( 1 );
    tmp_tuple_element_4 = var_l;

    CHECK_OBJECT( tmp_tuple_element_4 );
    Py_INCREF( tmp_tuple_element_4 );
    PyTuple_SET_ITEM( tmp_defaults_4, 0, tmp_tuple_element_4 );
    tmp_assign_source_12 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1( tmp_defaults_4 );
    assert( var__testPri1 == NULL );
    var__testPri1 = tmp_assign_source_12;

    tmp_defaults_5 = PyTuple_New( 1 );
    tmp_tuple_element_5 = var_l;

    CHECK_OBJECT( tmp_tuple_element_5 );
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_defaults_5, 0, tmp_tuple_element_5 );
    tmp_assign_source_13 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2( tmp_defaults_5 );
    assert( var__testPri2 == NULL );
    var__testPri2 = tmp_assign_source_13;

    tmp_source_name_3 = var_tm;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_add );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_2 = PyTuple_New( 2 );
    tmp_tuple_element_6 = var__testPri1;

    CHECK_OBJECT( tmp_tuple_element_6 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_args_name_2, 0, tmp_tuple_element_6 );
    tmp_tuple_element_6 = const_str_plain_testPri1;
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_args_name_2, 1, tmp_tuple_element_6 );
    tmp_kw_name_2 = PyDict_Copy( const_dict_20bf4839fda8a49cec676ef6853196ef );
    frame_function->m_frame.f_lineno = 856;
    tmp_unused = CALL_FUNCTION( tmp_called_name_5, tmp_args_name_2, tmp_kw_name_2 );
    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_name_2 );
    Py_DECREF( tmp_kw_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 856;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = var_tm;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_add );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_3 = PyTuple_New( 2 );
    tmp_tuple_element_7 = var__testPri2;

    CHECK_OBJECT( tmp_tuple_element_7 );
    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_3, 0, tmp_tuple_element_7 );
    tmp_tuple_element_7 = const_str_plain_testPri2;
    Py_INCREF( tmp_tuple_element_7 );
    PyTuple_SET_ITEM( tmp_args_name_3, 1, tmp_tuple_element_7 );
    tmp_kw_name_3 = PyDict_Copy( const_dict_1b3ca16c1519c7adb9906eff10d088a1 );
    frame_function->m_frame.f_lineno = 857;
    tmp_unused = CALL_FUNCTION( tmp_called_name_6, tmp_args_name_3, tmp_kw_name_3 );
    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_name_3 );
    Py_DECREF( tmp_kw_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 857;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_31 = var_tm;

    CHECK_OBJECT( tmp_called_instance_31 );
    frame_function->m_frame.f_lineno = 858;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_31, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 858;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_8 = var_l;

    CHECK_OBJECT( tmp_len_arg_8 );
    tmp_compare_left_11 = BUILTIN_LEN( tmp_len_arg_8 );
    assert( tmp_compare_left_11 != NULL );
    tmp_compare_right_11 = const_int_pos_2;
    tmp_cmp_Eq_11 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_11, tmp_compare_right_11 );
    if ( tmp_cmp_Eq_11 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_11 );

        exception_lineno = 859;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_11 );
    if ( tmp_cmp_Eq_11 == 1 )
    {
        goto branch_no_14;
    }
    else
    {
        goto branch_yes_14;
    }
    branch_yes_14:;
    tmp_raise_type_14 = PyExc_AssertionError;
    exception_type = tmp_raise_type_14;
    Py_INCREF( tmp_raise_type_14 );
    exception_lineno = 859;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_14:;
    tmp_compare_left_12 = var_l;

    CHECK_OBJECT( tmp_compare_left_12 );
    tmp_compare_right_12 = LIST_COPY( const_list_int_pos_1_int_pos_2_list );
    tmp_cmp_Eq_12 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_12, tmp_compare_right_12 );
    if ( tmp_cmp_Eq_12 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_12 );

        exception_lineno = 860;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_12 );
    if ( tmp_cmp_Eq_12 == 1 )
    {
        goto branch_no_15;
    }
    else
    {
        goto branch_yes_15;
    }
    branch_yes_15:;
    tmp_raise_type_15 = PyExc_AssertionError;
    exception_type = tmp_raise_type_15;
    Py_INCREF( tmp_raise_type_15 );
    exception_lineno = 860;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_15:;
    tmp_called_instance_32 = var_tm;

    CHECK_OBJECT( tmp_called_instance_32 );
    frame_function->m_frame.f_lineno = 861;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_32, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 861;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_9 = var_l;

    CHECK_OBJECT( tmp_len_arg_9 );
    tmp_compare_left_13 = BUILTIN_LEN( tmp_len_arg_9 );
    assert( tmp_compare_left_13 != NULL );
    tmp_compare_right_13 = const_int_pos_4;
    tmp_cmp_Eq_13 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_13, tmp_compare_right_13 );
    if ( tmp_cmp_Eq_13 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_13 );

        exception_lineno = 862;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_13 );
    if ( tmp_cmp_Eq_13 == 1 )
    {
        goto branch_no_16;
    }
    else
    {
        goto branch_yes_16;
    }
    branch_yes_16:;
    tmp_raise_type_16 = PyExc_AssertionError;
    exception_type = tmp_raise_type_16;
    Py_INCREF( tmp_raise_type_16 );
    exception_lineno = 862;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_16:;
    tmp_compare_left_14 = var_l;

    CHECK_OBJECT( tmp_compare_left_14 );
    tmp_compare_right_14 = LIST_COPY( const_list_int_pos_1_int_pos_2_int_pos_1_int_pos_2_list );
    tmp_cmp_Eq_14 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_14, tmp_compare_right_14 );
    if ( tmp_cmp_Eq_14 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_14 );

        exception_lineno = 863;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_14 );
    if ( tmp_cmp_Eq_14 == 1 )
    {
        goto branch_no_17;
    }
    else
    {
        goto branch_yes_17;
    }
    branch_yes_17:;
    tmp_raise_type_17 = PyExc_AssertionError;
    exception_type = tmp_raise_type_17;
    Py_INCREF( tmp_raise_type_17 );
    exception_lineno = 863;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_17:;
    tmp_called_instance_33 = var_tm;

    CHECK_OBJECT( tmp_called_instance_33 );
    frame_function->m_frame.f_lineno = 864;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_33, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testPri1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 864;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_34 = var_tm;

    CHECK_OBJECT( tmp_called_instance_34 );
    frame_function->m_frame.f_lineno = 865;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_34, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testPri2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 865;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testPri1 );
    var__testPri1 = NULL;

    Py_XDECREF( var__testPri2 );
    var__testPri2 = NULL;

    tmp_called_instance_35 = var_tm;

    CHECK_OBJECT( tmp_called_instance_35 );
    frame_function->m_frame.f_lineno = 868;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_35, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 868;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_14 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_14;
        Py_DECREF( old );
    }

    tmp_defaults_6 = PyTuple_New( 1 );
    tmp_tuple_element_8 = var_l;

    CHECK_OBJECT( tmp_tuple_element_8 );
    Py_INCREF( tmp_tuple_element_8 );
    PyTuple_SET_ITEM( tmp_defaults_6, 0, tmp_tuple_element_8 );
    tmp_assign_source_15 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs( tmp_defaults_6 );
    assert( var__testExtraArgs == NULL );
    var__testExtraArgs = tmp_assign_source_15;

    tmp_source_name_5 = var_tm;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_add );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 875;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_4 = PyTuple_New( 2 );
    tmp_tuple_element_9 = var__testExtraArgs;

    CHECK_OBJECT( tmp_tuple_element_9 );
    Py_INCREF( tmp_tuple_element_9 );
    PyTuple_SET_ITEM( tmp_args_name_4, 0, tmp_tuple_element_9 );
    tmp_tuple_element_9 = const_str_plain_testExtraArgs;
    Py_INCREF( tmp_tuple_element_9 );
    PyTuple_SET_ITEM( tmp_args_name_4, 1, tmp_tuple_element_9 );
    tmp_kw_name_4 = DEEP_COPY( const_dict_f6fd31b757f98ae2cae04de91e28d807 );
    frame_function->m_frame.f_lineno = 875;
    tmp_unused = CALL_FUNCTION( tmp_called_name_7, tmp_args_name_4, tmp_kw_name_4 );
    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_name_4 );
    Py_DECREF( tmp_kw_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 875;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_36 = var_tm;

    CHECK_OBJECT( tmp_called_instance_36 );
    frame_function->m_frame.f_lineno = 876;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_36, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 876;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_10 = var_l;

    CHECK_OBJECT( tmp_len_arg_10 );
    tmp_compare_left_15 = BUILTIN_LEN( tmp_len_arg_10 );
    assert( tmp_compare_left_15 != NULL );
    tmp_compare_right_15 = const_int_pos_2;
    tmp_cmp_Eq_15 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_15, tmp_compare_right_15 );
    if ( tmp_cmp_Eq_15 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_15 );

        exception_lineno = 877;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_15 );
    if ( tmp_cmp_Eq_15 == 1 )
    {
        goto branch_no_18;
    }
    else
    {
        goto branch_yes_18;
    }
    branch_yes_18:;
    tmp_raise_type_18 = PyExc_AssertionError;
    exception_type = tmp_raise_type_18;
    Py_INCREF( tmp_raise_type_18 );
    exception_lineno = 877;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_18:;
    tmp_compare_left_16 = var_l;

    CHECK_OBJECT( tmp_compare_left_16 );
    tmp_compare_right_16 = LIST_COPY( const_list_int_pos_4_int_pos_5_list );
    tmp_cmp_Eq_16 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_16, tmp_compare_right_16 );
    if ( tmp_cmp_Eq_16 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_16 );

        exception_lineno = 878;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_16 );
    if ( tmp_cmp_Eq_16 == 1 )
    {
        goto branch_no_19;
    }
    else
    {
        goto branch_yes_19;
    }
    branch_yes_19:;
    tmp_raise_type_19 = PyExc_AssertionError;
    exception_type = tmp_raise_type_19;
    Py_INCREF( tmp_raise_type_19 );
    exception_lineno = 878;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_19:;
    Py_XDECREF( var__testExtraArgs );
    var__testExtraArgs = NULL;

    tmp_called_instance_37 = var_tm;

    CHECK_OBJECT( tmp_called_instance_37 );
    frame_function->m_frame.f_lineno = 880;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_37, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 880;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_16 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_16;
        Py_DECREF( old );
    }

    tmp_defaults_7 = PyTuple_New( 1 );
    tmp_tuple_element_10 = var_l;

    CHECK_OBJECT( tmp_tuple_element_10 );
    Py_INCREF( tmp_tuple_element_10 );
    PyTuple_SET_ITEM( tmp_defaults_7, 0, tmp_tuple_element_10 );
    tmp_assign_source_17 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask( tmp_defaults_7 );
    assert( var__testAppendTask == NULL );
    var__testAppendTask = tmp_assign_source_17;

    tmp_source_name_6 = var_tm;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_8 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_add );
    if ( tmp_called_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 887;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_5 = PyTuple_New( 2 );
    tmp_tuple_element_11 = var__testAppendTask;

    CHECK_OBJECT( tmp_tuple_element_11 );
    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_args_name_5, 0, tmp_tuple_element_11 );
    tmp_tuple_element_11 = const_str_plain__testAppendTask;
    Py_INCREF( tmp_tuple_element_11 );
    PyTuple_SET_ITEM( tmp_args_name_5, 1, tmp_tuple_element_11 );
    tmp_kw_name_5 = DEEP_COPY( const_dict_393ba663cb39d8e5662104836ff43bdd );
    frame_function->m_frame.f_lineno = 887;
    tmp_unused = CALL_FUNCTION( tmp_called_name_8, tmp_args_name_5, tmp_kw_name_5 );
    Py_DECREF( tmp_called_name_8 );
    Py_DECREF( tmp_args_name_5 );
    Py_DECREF( tmp_kw_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 887;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_38 = var_tm;

    CHECK_OBJECT( tmp_called_instance_38 );
    frame_function->m_frame.f_lineno = 888;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_38, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 888;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_11 = var_l;

    CHECK_OBJECT( tmp_len_arg_11 );
    tmp_compare_left_17 = BUILTIN_LEN( tmp_len_arg_11 );
    assert( tmp_compare_left_17 != NULL );
    tmp_compare_right_17 = const_int_pos_2;
    tmp_cmp_Eq_17 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_17, tmp_compare_right_17 );
    if ( tmp_cmp_Eq_17 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_17 );

        exception_lineno = 889;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_17 );
    if ( tmp_cmp_Eq_17 == 1 )
    {
        goto branch_no_20;
    }
    else
    {
        goto branch_yes_20;
    }
    branch_yes_20:;
    tmp_raise_type_20 = PyExc_AssertionError;
    exception_type = tmp_raise_type_20;
    Py_INCREF( tmp_raise_type_20 );
    exception_lineno = 889;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_20:;
    tmp_compare_left_18 = var_l;

    CHECK_OBJECT( tmp_compare_left_18 );
    tmp_compare_right_18 = LIST_COPY( const_list_int_pos_4_int_pos_5_list );
    tmp_cmp_Eq_18 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_18, tmp_compare_right_18 );
    if ( tmp_cmp_Eq_18 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_18 );

        exception_lineno = 890;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_18 );
    if ( tmp_cmp_Eq_18 == 1 )
    {
        goto branch_no_21;
    }
    else
    {
        goto branch_yes_21;
    }
    branch_yes_21:;
    tmp_raise_type_21 = PyExc_AssertionError;
    exception_type = tmp_raise_type_21;
    Py_INCREF( tmp_raise_type_21 );
    exception_lineno = 890;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_21:;
    Py_XDECREF( var__testAppendTask );
    var__testAppendTask = NULL;

    tmp_called_instance_39 = var_tm;

    CHECK_OBJECT( tmp_called_instance_39 );
    frame_function->m_frame.f_lineno = 892;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_39, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 892;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_18 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_18;
        Py_DECREF( old );
    }

    tmp_defaults_8 = PyTuple_New( 1 );
    tmp_tuple_element_12 = var_l;

    CHECK_OBJECT( tmp_tuple_element_12 );
    Py_INCREF( tmp_tuple_element_12 );
    PyTuple_SET_ITEM( tmp_defaults_8, 0, tmp_tuple_element_12 );
    tmp_assign_source_19 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc( tmp_defaults_8 );
    assert( var__uponDeathFunc == NULL );
    var__uponDeathFunc = tmp_assign_source_19;

    tmp_assign_source_20 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath(  );
    assert( var__testUponDeath == NULL );
    var__testUponDeath = tmp_assign_source_20;

    tmp_source_name_7 = var_tm;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_add );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 900;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_6 = PyTuple_New( 2 );
    tmp_tuple_element_13 = var__testUponDeath;

    CHECK_OBJECT( tmp_tuple_element_13 );
    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_args_name_6, 0, tmp_tuple_element_13 );
    tmp_tuple_element_13 = const_str_plain_testUponDeath;
    Py_INCREF( tmp_tuple_element_13 );
    PyTuple_SET_ITEM( tmp_args_name_6, 1, tmp_tuple_element_13 );
    tmp_kw_name_6 = _PyDict_NewPresized( 1 );
    tmp_dict_value_1 = var__uponDeathFunc;

    CHECK_OBJECT( tmp_dict_value_1 );
    tmp_dict_key_1 = const_str_plain_uponDeath;
    PyDict_SetItem( tmp_kw_name_6, tmp_dict_key_1, tmp_dict_value_1 );
    frame_function->m_frame.f_lineno = 900;
    tmp_unused = CALL_FUNCTION( tmp_called_name_9, tmp_args_name_6, tmp_kw_name_6 );
    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_name_6 );
    Py_DECREF( tmp_kw_name_6 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 900;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_40 = var_tm;

    CHECK_OBJECT( tmp_called_instance_40 );
    frame_function->m_frame.f_lineno = 901;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_40, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 901;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_12 = var_l;

    CHECK_OBJECT( tmp_len_arg_12 );
    tmp_compare_left_19 = BUILTIN_LEN( tmp_len_arg_12 );
    assert( tmp_compare_left_19 != NULL );
    tmp_compare_right_19 = const_int_pos_1;
    tmp_cmp_Eq_19 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_19, tmp_compare_right_19 );
    if ( tmp_cmp_Eq_19 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_19 );

        exception_lineno = 902;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_19 );
    if ( tmp_cmp_Eq_19 == 1 )
    {
        goto branch_no_22;
    }
    else
    {
        goto branch_yes_22;
    }
    branch_yes_22:;
    tmp_raise_type_22 = PyExc_AssertionError;
    exception_type = tmp_raise_type_22;
    Py_INCREF( tmp_raise_type_22 );
    exception_lineno = 902;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_22:;
    tmp_compare_left_20 = var_l;

    CHECK_OBJECT( tmp_compare_left_20 );
    tmp_compare_right_20 = LIST_COPY( const_list_str_plain_testUponDeath_list );
    tmp_cmp_Eq_20 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_20, tmp_compare_right_20 );
    if ( tmp_cmp_Eq_20 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_20 );

        exception_lineno = 903;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_20 );
    if ( tmp_cmp_Eq_20 == 1 )
    {
        goto branch_no_23;
    }
    else
    {
        goto branch_yes_23;
    }
    branch_yes_23:;
    tmp_raise_type_23 = PyExc_AssertionError;
    exception_type = tmp_raise_type_23;
    Py_INCREF( tmp_raise_type_23 );
    exception_lineno = 903;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_23:;
    Py_XDECREF( var__testUponDeath );
    var__testUponDeath = NULL;

    Py_XDECREF( var__uponDeathFunc );
    var__uponDeathFunc = NULL;

    tmp_called_instance_41 = var_tm;

    CHECK_OBJECT( tmp_called_instance_41 );
    frame_function->m_frame.f_lineno = 906;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_41, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 906;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_21 = impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner( NULL );
    assert( tmp_assign_source_21 != NULL );
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_21;

    // Tried code:
    tmp_compare_left_21 = const_str_plain___metaclass__;
    tmp_compare_right_21 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_compare_right_21 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_21, tmp_compare_left_21 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_22 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 909;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_bases_name_1 = const_tuple_empty;
    tmp_assign_source_22 = SELECT_METACLASS( tmp_bases_name_1, GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_22;

    tmp_called_name_10 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_10 );
    tmp_args_element_name_16 = const_str_plain__TaskOwner;
    tmp_args_element_name_17 = const_tuple_empty;
    tmp_args_element_name_18 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_args_element_name_18 );
    frame_function->m_frame.f_lineno = 909;
    {
        PyObject *call_args[] = { tmp_args_element_name_16, tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_assign_source_23 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_10, call_args );
    }

    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 909;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_23;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_24 = tmp_class_creation_1__class;

    CHECK_OBJECT( tmp_assign_source_24 );
    assert( var__TaskOwner == NULL );
    Py_INCREF( tmp_assign_source_24 );
    var__TaskOwner = tmp_assign_source_24;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_called_name_11 = var__TaskOwner;

    CHECK_OBJECT( tmp_called_name_11 );
    frame_function->m_frame.f_lineno = 914;
    tmp_assign_source_25 = CALL_FUNCTION_NO_ARGS( tmp_called_name_11 );
    if ( tmp_assign_source_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 914;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_to == NULL );
    var_to = tmp_assign_source_25;

    tmp_assign_source_26 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_26;
        Py_DECREF( old );
    }

    tmp_assign_source_27 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner(  );
    assert( var__testOwner == NULL );
    var__testOwner = tmp_assign_source_27;

    tmp_source_name_8 = var_tm;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_add );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 918;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_7 = PyTuple_New( 2 );
    tmp_tuple_element_14 = var__testOwner;

    CHECK_OBJECT( tmp_tuple_element_14 );
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_7, 0, tmp_tuple_element_14 );
    tmp_tuple_element_14 = const_str_plain_testOwner;
    Py_INCREF( tmp_tuple_element_14 );
    PyTuple_SET_ITEM( tmp_args_name_7, 1, tmp_tuple_element_14 );
    tmp_kw_name_7 = _PyDict_NewPresized( 1 );
    tmp_dict_value_2 = var_to;

    CHECK_OBJECT( tmp_dict_value_2 );
    tmp_dict_key_2 = const_str_plain_owner;
    PyDict_SetItem( tmp_kw_name_7, tmp_dict_key_2, tmp_dict_value_2 );
    frame_function->m_frame.f_lineno = 918;
    tmp_unused = CALL_FUNCTION( tmp_called_name_12, tmp_args_name_7, tmp_kw_name_7 );
    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_args_name_7 );
    Py_DECREF( tmp_kw_name_7 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 918;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_42 = var_tm;

    CHECK_OBJECT( tmp_called_instance_42 );
    frame_function->m_frame.f_lineno = 919;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_42, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 919;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_getattr_target_1 = var_to;

    CHECK_OBJECT( tmp_getattr_target_1 );
    tmp_getattr_attr_1 = const_str_plain_addedTaskName;
    tmp_getattr_default_1 = Py_None;
    tmp_compare_left_22 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
    if ( tmp_compare_left_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 920;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_22 = const_str_plain_testOwner;
    tmp_cmp_Eq_21 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_22, tmp_compare_right_22 );
    if ( tmp_cmp_Eq_21 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_22 );

        exception_lineno = 920;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_22 );
    if ( tmp_cmp_Eq_21 == 1 )
    {
        goto branch_no_24;
    }
    else
    {
        goto branch_yes_24;
    }
    branch_yes_24:;
    tmp_raise_type_24 = PyExc_AssertionError;
    exception_type = tmp_raise_type_24;
    Py_INCREF( tmp_raise_type_24 );
    exception_lineno = 920;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_24:;
    tmp_getattr_target_2 = var_to;

    CHECK_OBJECT( tmp_getattr_target_2 );
    tmp_getattr_attr_2 = const_str_plain_clearedTaskName;
    tmp_getattr_default_2 = Py_None;
    tmp_compare_left_23 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, tmp_getattr_default_2 );
    if ( tmp_compare_left_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 921;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_23 = const_str_plain_testOwner;
    tmp_cmp_Eq_22 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_23, tmp_compare_right_23 );
    if ( tmp_cmp_Eq_22 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_23 );

        exception_lineno = 921;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_23 );
    if ( tmp_cmp_Eq_22 == 1 )
    {
        goto branch_no_25;
    }
    else
    {
        goto branch_yes_25;
    }
    branch_yes_25:;
    tmp_raise_type_25 = PyExc_AssertionError;
    exception_type = tmp_raise_type_25;
    Py_INCREF( tmp_raise_type_25 );
    exception_lineno = 921;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_25:;
    Py_XDECREF( var__testOwner );
    var__testOwner = NULL;

    CHECK_OBJECT( var_to );
    Py_DECREF( var_to );
    var_to = NULL;

    Py_XDECREF( var__TaskOwner );
    var__TaskOwner = NULL;

    tmp_called_instance_43 = var_tm;

    CHECK_OBJECT( tmp_called_instance_43 );
    frame_function->m_frame.f_lineno = 925;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_43, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 925;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_28 = LIST_COPY( const_list_int_0_list );
    assert( var_doLaterTests == NULL );
    var_doLaterTests = tmp_assign_source_28;

    tmp_assign_source_29 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_29;
        Py_DECREF( old );
    }

    tmp_defaults_9 = PyTuple_New( 1 );
    tmp_tuple_element_15 = var_l;

    CHECK_OBJECT( tmp_tuple_element_15 );
    Py_INCREF( tmp_tuple_element_15 );
    PyTuple_SET_ITEM( tmp_defaults_9, 0, tmp_tuple_element_15 );
    tmp_assign_source_30 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1( tmp_defaults_9 );
    assert( var__testDoLater1 == NULL );
    var__testDoLater1 = tmp_assign_source_30;

    tmp_defaults_10 = PyTuple_New( 1 );
    tmp_tuple_element_16 = var_l;

    CHECK_OBJECT( tmp_tuple_element_16 );
    Py_INCREF( tmp_tuple_element_16 );
    PyTuple_SET_ITEM( tmp_defaults_10, 0, tmp_tuple_element_16 );
    tmp_assign_source_31 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2( tmp_defaults_10 );
    assert( var__testDoLater2 == NULL );
    var__testDoLater2 = tmp_assign_source_31;

    tmp_defaults_11 = PyTuple_New( 3 );
    tmp_tuple_element_17 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_17 );
    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_defaults_11, 0, tmp_tuple_element_17 );
    tmp_tuple_element_17 = var_l;

    CHECK_OBJECT( tmp_tuple_element_17 );
    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_defaults_11, 1, tmp_tuple_element_17 );
    tmp_tuple_element_17 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_17 );
    Py_INCREF( tmp_tuple_element_17 );
    PyTuple_SET_ITEM( tmp_defaults_11, 2, tmp_tuple_element_17 );
    tmp_assign_source_32 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater( tmp_defaults_11 );
    assert( var__monitorDoLater == NULL );
    var__monitorDoLater = tmp_assign_source_32;

    tmp_called_instance_44 = var_tm;

    CHECK_OBJECT( tmp_called_instance_44 );
    tmp_args_element_name_19 = const_float_0_01;
    tmp_args_element_name_20 = var__testDoLater1;

    CHECK_OBJECT( tmp_args_element_name_20 );
    tmp_args_element_name_21 = const_str_plain_testDoLater1;
    frame_function->m_frame.f_lineno = 942;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20, tmp_args_element_name_21 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_44, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 942;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_45 = var_tm;

    CHECK_OBJECT( tmp_called_instance_45 );
    tmp_args_element_name_22 = const_float_0_02;
    tmp_args_element_name_23 = var__testDoLater2;

    CHECK_OBJECT( tmp_args_element_name_23 );
    tmp_args_element_name_24 = const_str_plain_testDoLater2;
    frame_function->m_frame.f_lineno = 943;
    {
        PyObject *call_args[] = { tmp_args_element_name_22, tmp_args_element_name_23, tmp_args_element_name_24 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_45, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 943;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_33 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_33 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_33 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_33;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 944;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 944;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 944;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_9 = var_tm;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_add );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_8 = PyTuple_New( 2 );
    tmp_tuple_element_18 = var__monitorDoLater;

    CHECK_OBJECT( tmp_tuple_element_18 );
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_args_name_8, 0, tmp_tuple_element_18 );
    tmp_tuple_element_18 = const_str_plain_monitorDoLater;
    Py_INCREF( tmp_tuple_element_18 );
    PyTuple_SET_ITEM( tmp_args_name_8, 1, tmp_tuple_element_18 );
    tmp_kw_name_8 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 946;
    tmp_unused = CALL_FUNCTION( tmp_called_name_13, tmp_args_name_8, tmp_kw_name_8 );
    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_args_name_8 );
    Py_DECREF( tmp_kw_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 946;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testDoLater1 );
    var__testDoLater1 = NULL;

    Py_XDECREF( var__testDoLater2 );
    var__testDoLater2 = NULL;

    Py_XDECREF( var__monitorDoLater );
    var__monitorDoLater = NULL;

    tmp_assign_source_34 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_34;
        Py_DECREF( old );
    }

    tmp_defaults_12 = PyTuple_New( 1 );
    tmp_tuple_element_19 = var_l;

    CHECK_OBJECT( tmp_tuple_element_19 );
    Py_INCREF( tmp_tuple_element_19 );
    PyTuple_SET_ITEM( tmp_defaults_12, 0, tmp_tuple_element_19 );
    tmp_assign_source_35 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1( tmp_defaults_12 );
    assert( var__testDoLaterPri1 == NULL );
    var__testDoLaterPri1 = tmp_assign_source_35;

    tmp_defaults_13 = PyTuple_New( 1 );
    tmp_tuple_element_20 = var_l;

    CHECK_OBJECT( tmp_tuple_element_20 );
    Py_INCREF( tmp_tuple_element_20 );
    PyTuple_SET_ITEM( tmp_defaults_13, 0, tmp_tuple_element_20 );
    tmp_assign_source_36 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2( tmp_defaults_13 );
    assert( var__testDoLaterPri2 == NULL );
    var__testDoLaterPri2 = tmp_assign_source_36;

    tmp_defaults_14 = PyTuple_New( 3 );
    tmp_tuple_element_21 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_21 );
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_defaults_14, 0, tmp_tuple_element_21 );
    tmp_tuple_element_21 = var_l;

    CHECK_OBJECT( tmp_tuple_element_21 );
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_defaults_14, 1, tmp_tuple_element_21 );
    tmp_tuple_element_21 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_21 );
    Py_INCREF( tmp_tuple_element_21 );
    PyTuple_SET_ITEM( tmp_defaults_14, 2, tmp_tuple_element_21 );
    tmp_assign_source_37 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri( tmp_defaults_14 );
    assert( var__monitorDoLaterPri == NULL );
    var__monitorDoLaterPri = tmp_assign_source_37;

    tmp_source_name_10 = var_tm;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_doMethodLater );
    if ( tmp_called_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 965;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_9 = PyTuple_New( 3 );
    tmp_tuple_element_22 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_args_name_9, 0, tmp_tuple_element_22 );
    tmp_tuple_element_22 = var__testDoLaterPri1;

    CHECK_OBJECT( tmp_tuple_element_22 );
    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_args_name_9, 1, tmp_tuple_element_22 );
    tmp_tuple_element_22 = const_str_plain_testDoLaterPri1;
    Py_INCREF( tmp_tuple_element_22 );
    PyTuple_SET_ITEM( tmp_args_name_9, 2, tmp_tuple_element_22 );
    tmp_kw_name_9 = PyDict_Copy( const_dict_20bf4839fda8a49cec676ef6853196ef );
    frame_function->m_frame.f_lineno = 965;
    tmp_unused = CALL_FUNCTION( tmp_called_name_14, tmp_args_name_9, tmp_kw_name_9 );
    Py_DECREF( tmp_called_name_14 );
    Py_DECREF( tmp_args_name_9 );
    Py_DECREF( tmp_kw_name_9 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 965;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_11 = var_tm;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_doMethodLater );
    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_10 = PyTuple_New( 3 );
    tmp_tuple_element_23 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_23 );
    PyTuple_SET_ITEM( tmp_args_name_10, 0, tmp_tuple_element_23 );
    tmp_tuple_element_23 = var__testDoLaterPri2;

    CHECK_OBJECT( tmp_tuple_element_23 );
    Py_INCREF( tmp_tuple_element_23 );
    PyTuple_SET_ITEM( tmp_args_name_10, 1, tmp_tuple_element_23 );
    tmp_tuple_element_23 = const_str_plain_testDoLaterPri2;
    Py_INCREF( tmp_tuple_element_23 );
    PyTuple_SET_ITEM( tmp_args_name_10, 2, tmp_tuple_element_23 );
    tmp_kw_name_10 = PyDict_Copy( const_dict_1b3ca16c1519c7adb9906eff10d088a1 );
    frame_function->m_frame.f_lineno = 966;
    tmp_unused = CALL_FUNCTION( tmp_called_name_15, tmp_args_name_10, tmp_kw_name_10 );
    Py_DECREF( tmp_called_name_15 );
    Py_DECREF( tmp_args_name_10 );
    Py_DECREF( tmp_kw_name_10 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 966;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_38 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_38 );
    assert( tmp_inplace_assign_subscr_2__target == NULL );
    Py_INCREF( tmp_assign_source_38 );
    tmp_inplace_assign_subscr_2__target = tmp_assign_source_38;

    // Tried code:
    tmp_subscribed_name_2 = tmp_inplace_assign_subscr_2__target;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_0;
    tmp_left_name_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_4;
    }
    tmp_right_name_2 = const_int_pos_1;
    tmp_ass_subvalue_2 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_ass_subvalue_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_4;
    }
    tmp_ass_subscribed_2 = tmp_inplace_assign_subscr_2__target;

    CHECK_OBJECT( tmp_ass_subscribed_2 );
    tmp_ass_subscript_2 = const_int_0;
    tmp_ass_subscript_res_2 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_2, tmp_ass_subscript_2, 0, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subvalue_2 );
    if ( tmp_ass_subscript_res_2 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 967;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_4;
    }
    goto try_end_3;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_2__target );
    Py_DECREF( tmp_inplace_assign_subscr_2__target );
    tmp_inplace_assign_subscr_2__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_3:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_2__target );
    Py_DECREF( tmp_inplace_assign_subscr_2__target );
    tmp_inplace_assign_subscr_2__target = NULL;

    tmp_source_name_12 = var_tm;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_add );
    if ( tmp_called_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 969;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_11 = PyTuple_New( 2 );
    tmp_tuple_element_24 = var__monitorDoLaterPri;

    CHECK_OBJECT( tmp_tuple_element_24 );
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_args_name_11, 0, tmp_tuple_element_24 );
    tmp_tuple_element_24 = const_str_plain_monitorDoLaterPri;
    Py_INCREF( tmp_tuple_element_24 );
    PyTuple_SET_ITEM( tmp_args_name_11, 1, tmp_tuple_element_24 );
    tmp_kw_name_11 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 969;
    tmp_unused = CALL_FUNCTION( tmp_called_name_16, tmp_args_name_11, tmp_kw_name_11 );
    Py_DECREF( tmp_called_name_16 );
    Py_DECREF( tmp_args_name_11 );
    Py_DECREF( tmp_kw_name_11 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 969;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testDoLaterPri1 );
    var__testDoLaterPri1 = NULL;

    Py_XDECREF( var__testDoLaterPri2 );
    var__testDoLaterPri2 = NULL;

    Py_XDECREF( var__monitorDoLaterPri );
    var__monitorDoLaterPri = NULL;

    tmp_assign_source_39 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_39;
        Py_DECREF( old );
    }

    tmp_defaults_15 = PyTuple_New( 1 );
    tmp_tuple_element_25 = var_l;

    CHECK_OBJECT( tmp_tuple_element_25 );
    Py_INCREF( tmp_tuple_element_25 );
    PyTuple_SET_ITEM( tmp_defaults_15, 0, tmp_tuple_element_25 );
    tmp_assign_source_40 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs( tmp_defaults_15 );
    assert( var__testDoLaterExtraArgs == NULL );
    var__testDoLaterExtraArgs = tmp_assign_source_40;

    tmp_defaults_16 = PyTuple_New( 3 );
    tmp_tuple_element_26 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_26 );
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_defaults_16, 0, tmp_tuple_element_26 );
    tmp_tuple_element_26 = var_l;

    CHECK_OBJECT( tmp_tuple_element_26 );
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_defaults_16, 1, tmp_tuple_element_26 );
    tmp_tuple_element_26 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_26 );
    Py_INCREF( tmp_tuple_element_26 );
    PyTuple_SET_ITEM( tmp_defaults_16, 2, tmp_tuple_element_26 );
    tmp_assign_source_41 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs( tmp_defaults_16 );
    assert( var__monitorDoLaterExtraArgs == NULL );
    var__monitorDoLaterExtraArgs = tmp_assign_source_41;

    tmp_source_name_13 = var_tm;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_doMethodLater );
    if ( tmp_called_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 986;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_12 = PyTuple_New( 3 );
    tmp_tuple_element_27 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_12, 0, tmp_tuple_element_27 );
    tmp_tuple_element_27 = var__testDoLaterExtraArgs;

    CHECK_OBJECT( tmp_tuple_element_27 );
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_12, 1, tmp_tuple_element_27 );
    tmp_tuple_element_27 = const_str_plain_testDoLaterExtraArgs;
    Py_INCREF( tmp_tuple_element_27 );
    PyTuple_SET_ITEM( tmp_args_name_12, 2, tmp_tuple_element_27 );
    tmp_kw_name_12 = DEEP_COPY( const_dict_752c9f51c629c62cd37d9eb2a6272323 );
    frame_function->m_frame.f_lineno = 986;
    tmp_unused = CALL_FUNCTION( tmp_called_name_17, tmp_args_name_12, tmp_kw_name_12 );
    Py_DECREF( tmp_called_name_17 );
    Py_DECREF( tmp_args_name_12 );
    Py_DECREF( tmp_kw_name_12 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 986;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_42 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_42 );
    assert( tmp_inplace_assign_subscr_3__target == NULL );
    Py_INCREF( tmp_assign_source_42 );
    tmp_inplace_assign_subscr_3__target = tmp_assign_source_42;

    // Tried code:
    tmp_subscribed_name_3 = tmp_inplace_assign_subscr_3__target;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_0;
    tmp_left_name_3 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_left_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_5;
    }
    tmp_right_name_3 = const_int_pos_1;
    tmp_ass_subvalue_3 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_3 );
    if ( tmp_ass_subvalue_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_5;
    }
    tmp_ass_subscribed_3 = tmp_inplace_assign_subscr_3__target;

    CHECK_OBJECT( tmp_ass_subscribed_3 );
    tmp_ass_subscript_3 = const_int_0;
    tmp_ass_subscript_res_3 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_3, tmp_ass_subscript_3, 0, tmp_ass_subvalue_3 );
    Py_DECREF( tmp_ass_subvalue_3 );
    if ( tmp_ass_subscript_res_3 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 987;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_5;
    }
    goto try_end_4;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_3__target );
    Py_DECREF( tmp_inplace_assign_subscr_3__target );
    tmp_inplace_assign_subscr_3__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_3__target );
    Py_DECREF( tmp_inplace_assign_subscr_3__target );
    tmp_inplace_assign_subscr_3__target = NULL;

    tmp_source_name_14 = var_tm;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_called_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_add );
    if ( tmp_called_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 989;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_13 = PyTuple_New( 2 );
    tmp_tuple_element_28 = var__monitorDoLaterExtraArgs;

    CHECK_OBJECT( tmp_tuple_element_28 );
    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_args_name_13, 0, tmp_tuple_element_28 );
    tmp_tuple_element_28 = const_str_plain_monitorDoLaterExtraArgs;
    Py_INCREF( tmp_tuple_element_28 );
    PyTuple_SET_ITEM( tmp_args_name_13, 1, tmp_tuple_element_28 );
    tmp_kw_name_13 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 989;
    tmp_unused = CALL_FUNCTION( tmp_called_name_18, tmp_args_name_13, tmp_kw_name_13 );
    Py_DECREF( tmp_called_name_18 );
    Py_DECREF( tmp_args_name_13 );
    Py_DECREF( tmp_kw_name_13 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 989;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testDoLaterExtraArgs );
    var__testDoLaterExtraArgs = NULL;

    Py_XDECREF( var__monitorDoLaterExtraArgs );
    var__monitorDoLaterExtraArgs = NULL;

    tmp_assign_source_43 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_43;
        Py_DECREF( old );
    }

    tmp_defaults_17 = PyTuple_New( 1 );
    tmp_tuple_element_29 = var_l;

    CHECK_OBJECT( tmp_tuple_element_29 );
    Py_INCREF( tmp_tuple_element_29 );
    PyTuple_SET_ITEM( tmp_defaults_17, 0, tmp_tuple_element_29 );
    tmp_assign_source_44 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask( tmp_defaults_17 );
    assert( var__testDoLaterAppendTask == NULL );
    var__testDoLaterAppendTask = tmp_assign_source_44;

    tmp_defaults_18 = PyTuple_New( 3 );
    tmp_tuple_element_30 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_30 );
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_defaults_18, 0, tmp_tuple_element_30 );
    tmp_tuple_element_30 = var_l;

    CHECK_OBJECT( tmp_tuple_element_30 );
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_defaults_18, 1, tmp_tuple_element_30 );
    tmp_tuple_element_30 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_30 );
    Py_INCREF( tmp_tuple_element_30 );
    PyTuple_SET_ITEM( tmp_defaults_18, 2, tmp_tuple_element_30 );
    tmp_assign_source_45 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask( tmp_defaults_18 );
    assert( var__monitorDoLaterAppendTask == NULL );
    var__monitorDoLaterAppendTask = tmp_assign_source_45;

    tmp_source_name_15 = var_tm;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_doMethodLater );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_14 = PyTuple_New( 3 );
    tmp_tuple_element_31 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_31 );
    PyTuple_SET_ITEM( tmp_args_name_14, 0, tmp_tuple_element_31 );
    tmp_tuple_element_31 = var__testDoLaterAppendTask;

    CHECK_OBJECT( tmp_tuple_element_31 );
    Py_INCREF( tmp_tuple_element_31 );
    PyTuple_SET_ITEM( tmp_args_name_14, 1, tmp_tuple_element_31 );
    tmp_tuple_element_31 = const_str_plain_testDoLaterAppendTask;
    Py_INCREF( tmp_tuple_element_31 );
    PyTuple_SET_ITEM( tmp_args_name_14, 2, tmp_tuple_element_31 );
    tmp_kw_name_14 = DEEP_COPY( const_dict_fe8e6ab2fc04c0d3fcc53136375f69ef );
    frame_function->m_frame.f_lineno = 1006;
    tmp_unused = CALL_FUNCTION( tmp_called_name_19, tmp_args_name_14, tmp_kw_name_14 );
    Py_DECREF( tmp_called_name_19 );
    Py_DECREF( tmp_args_name_14 );
    Py_DECREF( tmp_kw_name_14 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1006;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_46 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_46 );
    assert( tmp_inplace_assign_subscr_4__target == NULL );
    Py_INCREF( tmp_assign_source_46 );
    tmp_inplace_assign_subscr_4__target = tmp_assign_source_46;

    // Tried code:
    tmp_subscribed_name_4 = tmp_inplace_assign_subscr_4__target;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_left_name_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_6;
    }
    tmp_right_name_4 = const_int_pos_1;
    tmp_ass_subvalue_4 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_ass_subvalue_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_6;
    }
    tmp_ass_subscribed_4 = tmp_inplace_assign_subscr_4__target;

    CHECK_OBJECT( tmp_ass_subscribed_4 );
    tmp_ass_subscript_4 = const_int_0;
    tmp_ass_subscript_res_4 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_4, tmp_ass_subscript_4, 0, tmp_ass_subvalue_4 );
    Py_DECREF( tmp_ass_subvalue_4 );
    if ( tmp_ass_subscript_res_4 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1008;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_6;
    }
    goto try_end_5;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_4__target );
    Py_DECREF( tmp_inplace_assign_subscr_4__target );
    tmp_inplace_assign_subscr_4__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto frame_exception_exit_1;
    // End of try:
    try_end_5:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_4__target );
    Py_DECREF( tmp_inplace_assign_subscr_4__target );
    tmp_inplace_assign_subscr_4__target = NULL;

    tmp_source_name_16 = var_tm;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_called_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_add );
    if ( tmp_called_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_15 = PyTuple_New( 2 );
    tmp_tuple_element_32 = var__monitorDoLaterAppendTask;

    CHECK_OBJECT( tmp_tuple_element_32 );
    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_args_name_15, 0, tmp_tuple_element_32 );
    tmp_tuple_element_32 = const_str_plain_monitorDoLaterAppendTask;
    Py_INCREF( tmp_tuple_element_32 );
    PyTuple_SET_ITEM( tmp_args_name_15, 1, tmp_tuple_element_32 );
    tmp_kw_name_15 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 1010;
    tmp_unused = CALL_FUNCTION( tmp_called_name_20, tmp_args_name_15, tmp_kw_name_15 );
    Py_DECREF( tmp_called_name_20 );
    Py_DECREF( tmp_args_name_15 );
    Py_DECREF( tmp_kw_name_15 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1010;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testDoLaterAppendTask );
    var__testDoLaterAppendTask = NULL;

    Py_XDECREF( var__monitorDoLaterAppendTask );
    var__monitorDoLaterAppendTask = NULL;

    tmp_assign_source_47 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_47;
        Py_DECREF( old );
    }

    tmp_defaults_19 = PyTuple_New( 1 );
    tmp_tuple_element_33 = var_l;

    CHECK_OBJECT( tmp_tuple_element_33 );
    Py_INCREF( tmp_tuple_element_33 );
    PyTuple_SET_ITEM( tmp_defaults_19, 0, tmp_tuple_element_33 );
    tmp_assign_source_48 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc( tmp_defaults_19 );
    assert( var__testUponDeathFunc == NULL );
    var__testUponDeathFunc = tmp_assign_source_48;

    tmp_defaults_20 = PyTuple_New( 1 );
    tmp_tuple_element_34 = var_l;

    CHECK_OBJECT( tmp_tuple_element_34 );
    Py_INCREF( tmp_tuple_element_34 );
    PyTuple_SET_ITEM( tmp_defaults_20, 0, tmp_tuple_element_34 );
    tmp_assign_source_49 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath( tmp_defaults_20 );
    assert( var__testDoLaterUponDeath == NULL );
    var__testDoLaterUponDeath = tmp_assign_source_49;

    tmp_defaults_21 = PyTuple_New( 3 );
    tmp_tuple_element_35 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_35 );
    Py_INCREF( tmp_tuple_element_35 );
    PyTuple_SET_ITEM( tmp_defaults_21, 0, tmp_tuple_element_35 );
    tmp_tuple_element_35 = var_l;

    CHECK_OBJECT( tmp_tuple_element_35 );
    Py_INCREF( tmp_tuple_element_35 );
    PyTuple_SET_ITEM( tmp_defaults_21, 1, tmp_tuple_element_35 );
    tmp_tuple_element_35 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_35 );
    Py_INCREF( tmp_tuple_element_35 );
    PyTuple_SET_ITEM( tmp_defaults_21, 2, tmp_tuple_element_35 );
    tmp_assign_source_50 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath( tmp_defaults_21 );
    assert( var__monitorDoLaterUponDeath == NULL );
    var__monitorDoLaterUponDeath = tmp_assign_source_50;

    tmp_source_name_17 = var_tm;

    CHECK_OBJECT( tmp_source_name_17 );
    tmp_called_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_17, const_str_plain_doMethodLater );
    if ( tmp_called_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_16 = PyTuple_New( 3 );
    tmp_tuple_element_36 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_16, 0, tmp_tuple_element_36 );
    tmp_tuple_element_36 = var__testDoLaterUponDeath;

    CHECK_OBJECT( tmp_tuple_element_36 );
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_16, 1, tmp_tuple_element_36 );
    tmp_tuple_element_36 = const_str_plain_testDoLaterUponDeath;
    Py_INCREF( tmp_tuple_element_36 );
    PyTuple_SET_ITEM( tmp_args_name_16, 2, tmp_tuple_element_36 );
    tmp_kw_name_16 = _PyDict_NewPresized( 1 );
    tmp_dict_value_3 = var__testUponDeathFunc;

    CHECK_OBJECT( tmp_dict_value_3 );
    tmp_dict_key_3 = const_str_plain_uponDeath;
    PyDict_SetItem( tmp_kw_name_16, tmp_dict_key_3, tmp_dict_value_3 );
    frame_function->m_frame.f_lineno = 1029;
    tmp_unused = CALL_FUNCTION( tmp_called_name_21, tmp_args_name_16, tmp_kw_name_16 );
    Py_DECREF( tmp_called_name_21 );
    Py_DECREF( tmp_args_name_16 );
    Py_DECREF( tmp_kw_name_16 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1029;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_51 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_51 );
    assert( tmp_inplace_assign_subscr_5__target == NULL );
    Py_INCREF( tmp_assign_source_51 );
    tmp_inplace_assign_subscr_5__target = tmp_assign_source_51;

    // Tried code:
    tmp_subscribed_name_5 = tmp_inplace_assign_subscr_5__target;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_0;
    tmp_left_name_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1031;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_7;
    }
    tmp_right_name_5 = const_int_pos_1;
    tmp_ass_subvalue_5 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_ass_subvalue_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1031;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_7;
    }
    tmp_ass_subscribed_5 = tmp_inplace_assign_subscr_5__target;

    CHECK_OBJECT( tmp_ass_subscribed_5 );
    tmp_ass_subscript_5 = const_int_0;
    tmp_ass_subscript_res_5 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_5, tmp_ass_subscript_5, 0, tmp_ass_subvalue_5 );
    Py_DECREF( tmp_ass_subvalue_5 );
    if ( tmp_ass_subscript_res_5 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1031;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_7;
    }
    goto try_end_6;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_5__target );
    Py_DECREF( tmp_inplace_assign_subscr_5__target );
    tmp_inplace_assign_subscr_5__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_6:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_5__target );
    Py_DECREF( tmp_inplace_assign_subscr_5__target );
    tmp_inplace_assign_subscr_5__target = NULL;

    tmp_source_name_18 = var_tm;

    CHECK_OBJECT( tmp_source_name_18 );
    tmp_called_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_18, const_str_plain_add );
    if ( tmp_called_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_17 = PyTuple_New( 2 );
    tmp_tuple_element_37 = var__monitorDoLaterUponDeath;

    CHECK_OBJECT( tmp_tuple_element_37 );
    Py_INCREF( tmp_tuple_element_37 );
    PyTuple_SET_ITEM( tmp_args_name_17, 0, tmp_tuple_element_37 );
    tmp_tuple_element_37 = const_str_plain_monitorDoLaterUponDeath;
    Py_INCREF( tmp_tuple_element_37 );
    PyTuple_SET_ITEM( tmp_args_name_17, 1, tmp_tuple_element_37 );
    tmp_kw_name_17 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 1033;
    tmp_unused = CALL_FUNCTION( tmp_called_name_22, tmp_args_name_17, tmp_kw_name_17 );
    Py_DECREF( tmp_called_name_22 );
    Py_DECREF( tmp_args_name_17 );
    Py_DECREF( tmp_kw_name_17 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1033;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testUponDeathFunc );
    var__testUponDeathFunc = NULL;

    Py_XDECREF( var__testDoLaterUponDeath );
    var__testDoLaterUponDeath = NULL;

    Py_XDECREF( var__monitorDoLaterUponDeath );
    var__monitorDoLaterUponDeath = NULL;

    tmp_assign_source_52 = impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner( NULL );
    assert( tmp_assign_source_52 != NULL );
    assert( tmp_class_creation_2__class_dict == NULL );
    tmp_class_creation_2__class_dict = tmp_assign_source_52;

    // Tried code:
    tmp_compare_left_24 = const_str_plain___metaclass__;
    tmp_compare_right_24 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_compare_right_24 );
    tmp_cmp_In_2 = PySequence_Contains( tmp_compare_right_24, tmp_compare_left_24 );
    assert( !(tmp_cmp_In_2 == -1) );
    if ( tmp_cmp_In_2 == 1 )
    {
        goto condexpr_true_2;
    }
    else
    {
        goto condexpr_false_2;
    }
    condexpr_true_2:;
    tmp_dict_name_2 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_dict_name_2 );
    tmp_key_name_2 = const_str_plain___metaclass__;
    tmp_assign_source_53 = DICT_GET_ITEM( tmp_dict_name_2, tmp_key_name_2 );
    if ( tmp_assign_source_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1041;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_8;
    }
    goto condexpr_end_2;
    condexpr_false_2:;
    tmp_bases_name_2 = const_tuple_empty;
    tmp_assign_source_53 = SELECT_METACLASS( tmp_bases_name_2, GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_2:;
    assert( tmp_class_creation_2__metaclass == NULL );
    tmp_class_creation_2__metaclass = tmp_assign_source_53;

    tmp_called_name_23 = tmp_class_creation_2__metaclass;

    CHECK_OBJECT( tmp_called_name_23 );
    tmp_args_element_name_25 = const_str_plain__DoLaterOwner;
    tmp_args_element_name_26 = const_tuple_empty;
    tmp_args_element_name_27 = tmp_class_creation_2__class_dict;

    CHECK_OBJECT( tmp_args_element_name_27 );
    frame_function->m_frame.f_lineno = 1041;
    {
        PyObject *call_args[] = { tmp_args_element_name_25, tmp_args_element_name_26, tmp_args_element_name_27 };
        tmp_assign_source_54 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_23, call_args );
    }

    if ( tmp_assign_source_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1041;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_8;
    }
    assert( tmp_class_creation_2__class == NULL );
    tmp_class_creation_2__class = tmp_assign_source_54;

    goto try_end_7;
    // Exception handler code:
    try_except_handler_8:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto frame_exception_exit_1;
    // End of try:
    try_end_7:;
    tmp_assign_source_55 = tmp_class_creation_2__class;

    CHECK_OBJECT( tmp_assign_source_55 );
    assert( var__DoLaterOwner == NULL );
    Py_INCREF( tmp_assign_source_55 );
    var__DoLaterOwner = tmp_assign_source_55;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class );
    Py_DECREF( tmp_class_creation_2__class );
    tmp_class_creation_2__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__class_dict );
    Py_DECREF( tmp_class_creation_2__class_dict );
    tmp_class_creation_2__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_2__metaclass );
    Py_DECREF( tmp_class_creation_2__metaclass );
    tmp_class_creation_2__metaclass = NULL;

    tmp_called_name_24 = var__DoLaterOwner;

    CHECK_OBJECT( tmp_called_name_24 );
    frame_function->m_frame.f_lineno = 1046;
    tmp_assign_source_56 = CALL_FUNCTION_NO_ARGS( tmp_called_name_24 );
    if ( tmp_assign_source_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1046;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_doLaterOwner == NULL );
    var_doLaterOwner = tmp_assign_source_56;

    tmp_assign_source_57 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_57;
        Py_DECREF( old );
    }

    tmp_defaults_22 = PyTuple_New( 1 );
    tmp_tuple_element_38 = var_l;

    CHECK_OBJECT( tmp_tuple_element_38 );
    Py_INCREF( tmp_tuple_element_38 );
    PyTuple_SET_ITEM( tmp_defaults_22, 0, tmp_tuple_element_38 );
    tmp_assign_source_58 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner( tmp_defaults_22 );
    assert( var__testDoLaterOwner == NULL );
    var__testDoLaterOwner = tmp_assign_source_58;

    tmp_defaults_23 = PyTuple_New( 4 );
    tmp_tuple_element_39 = var_tm;

    CHECK_OBJECT( tmp_tuple_element_39 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_defaults_23, 0, tmp_tuple_element_39 );
    tmp_tuple_element_39 = var_l;

    CHECK_OBJECT( tmp_tuple_element_39 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_defaults_23, 1, tmp_tuple_element_39 );
    tmp_tuple_element_39 = var_doLaterOwner;

    CHECK_OBJECT( tmp_tuple_element_39 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_defaults_23, 2, tmp_tuple_element_39 );
    tmp_tuple_element_39 = var_doLaterTests;

    CHECK_OBJECT( tmp_tuple_element_39 );
    Py_INCREF( tmp_tuple_element_39 );
    PyTuple_SET_ITEM( tmp_defaults_23, 3, tmp_tuple_element_39 );
    tmp_assign_source_59 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner( tmp_defaults_23 );
    assert( var__monitorDoLaterOwner == NULL );
    var__monitorDoLaterOwner = tmp_assign_source_59;

    tmp_source_name_19 = var_tm;

    CHECK_OBJECT( tmp_source_name_19 );
    tmp_called_name_25 = LOOKUP_ATTRIBUTE( tmp_source_name_19, const_str_plain_doMethodLater );
    if ( tmp_called_name_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_18 = PyTuple_New( 3 );
    tmp_tuple_element_40 = const_float_0_01;
    Py_INCREF( tmp_tuple_element_40 );
    PyTuple_SET_ITEM( tmp_args_name_18, 0, tmp_tuple_element_40 );
    tmp_tuple_element_40 = var__testDoLaterOwner;

    CHECK_OBJECT( tmp_tuple_element_40 );
    Py_INCREF( tmp_tuple_element_40 );
    PyTuple_SET_ITEM( tmp_args_name_18, 1, tmp_tuple_element_40 );
    tmp_tuple_element_40 = const_str_plain_testDoLaterOwner;
    Py_INCREF( tmp_tuple_element_40 );
    PyTuple_SET_ITEM( tmp_args_name_18, 2, tmp_tuple_element_40 );
    tmp_kw_name_18 = _PyDict_NewPresized( 1 );
    tmp_dict_value_4 = var_doLaterOwner;

    CHECK_OBJECT( tmp_dict_value_4 );
    tmp_dict_key_4 = const_str_plain_owner;
    PyDict_SetItem( tmp_kw_name_18, tmp_dict_key_4, tmp_dict_value_4 );
    frame_function->m_frame.f_lineno = 1058;
    tmp_unused = CALL_FUNCTION( tmp_called_name_25, tmp_args_name_18, tmp_kw_name_18 );
    Py_DECREF( tmp_called_name_25 );
    Py_DECREF( tmp_args_name_18 );
    Py_DECREF( tmp_kw_name_18 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1058;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_60 = var_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_60 );
    assert( tmp_inplace_assign_subscr_6__target == NULL );
    Py_INCREF( tmp_assign_source_60 );
    tmp_inplace_assign_subscr_6__target = tmp_assign_source_60;

    // Tried code:
    tmp_subscribed_name_6 = tmp_inplace_assign_subscr_6__target;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_0;
    tmp_left_name_6 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_9;
    }
    tmp_right_name_6 = const_int_pos_1;
    tmp_ass_subvalue_6 = BINARY_OPERATION( PyNumber_InPlaceAdd, tmp_left_name_6, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_6 );
    if ( tmp_ass_subvalue_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_9;
    }
    tmp_ass_subscribed_6 = tmp_inplace_assign_subscr_6__target;

    CHECK_OBJECT( tmp_ass_subscribed_6 );
    tmp_ass_subscript_6 = const_int_0;
    tmp_ass_subscript_res_6 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_6, tmp_ass_subscript_6, 0, tmp_ass_subvalue_6 );
    Py_DECREF( tmp_ass_subvalue_6 );
    if ( tmp_ass_subscript_res_6 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1060;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_9;
    }
    goto try_end_8;
    // Exception handler code:
    try_except_handler_9:;
    exception_keeper_type_8 = exception_type;
    exception_keeper_value_8 = exception_value;
    exception_keeper_tb_8 = exception_tb;
    exception_keeper_lineno_8 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_6__target );
    Py_DECREF( tmp_inplace_assign_subscr_6__target );
    tmp_inplace_assign_subscr_6__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_8;
    exception_value = exception_keeper_value_8;
    exception_tb = exception_keeper_tb_8;
    exception_lineno = exception_keeper_lineno_8;

    goto frame_exception_exit_1;
    // End of try:
    try_end_8:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_6__target );
    Py_DECREF( tmp_inplace_assign_subscr_6__target );
    tmp_inplace_assign_subscr_6__target = NULL;

    tmp_source_name_20 = var_tm;

    CHECK_OBJECT( tmp_source_name_20 );
    tmp_called_name_26 = LOOKUP_ATTRIBUTE( tmp_source_name_20, const_str_plain_add );
    if ( tmp_called_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1062;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_name_19 = PyTuple_New( 2 );
    tmp_tuple_element_41 = var__monitorDoLaterOwner;

    CHECK_OBJECT( tmp_tuple_element_41 );
    Py_INCREF( tmp_tuple_element_41 );
    PyTuple_SET_ITEM( tmp_args_name_19, 0, tmp_tuple_element_41 );
    tmp_tuple_element_41 = const_str_plain_monitorDoLaterOwner;
    Py_INCREF( tmp_tuple_element_41 );
    PyTuple_SET_ITEM( tmp_args_name_19, 1, tmp_tuple_element_41 );
    tmp_kw_name_19 = PyDict_Copy( const_dict_2c309b6a9a07f2a3a999dce9e263b6ff );
    frame_function->m_frame.f_lineno = 1062;
    tmp_unused = CALL_FUNCTION( tmp_called_name_26, tmp_args_name_19, tmp_kw_name_19 );
    Py_DECREF( tmp_called_name_26 );
    Py_DECREF( tmp_args_name_19 );
    Py_DECREF( tmp_kw_name_19 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1062;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    Py_XDECREF( var__testDoLaterOwner );
    var__testDoLaterOwner = NULL;

    Py_XDECREF( var__monitorDoLaterOwner );
    var__monitorDoLaterOwner = NULL;

    CHECK_OBJECT( var_doLaterOwner );
    Py_DECREF( var_doLaterOwner );
    var_doLaterOwner = NULL;

    Py_XDECREF( var__DoLaterOwner );
    var__DoLaterOwner = NULL;

    loop_start_1:;
    tmp_subscribed_name_7 = var_doLaterTests;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_compare_left_25 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_compare_left_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1071;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_25 = const_int_0;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_25, tmp_compare_right_25 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_25 );

        exception_lineno = 1071;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_25 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_no_26;
    }
    else
    {
        goto branch_yes_26;
    }
    branch_yes_26:;
    goto loop_end_1;
    branch_no_26:;
    tmp_called_instance_46 = var_tm;

    CHECK_OBJECT( tmp_called_instance_46 );
    frame_function->m_frame.f_lineno = 1072;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_46, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1072;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1071;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;
    CHECK_OBJECT( var_doLaterTests );
    Py_DECREF( var_doLaterTests );
    var_doLaterTests = NULL;

    tmp_called_instance_47 = var_tm;

    CHECK_OBJECT( tmp_called_instance_47 );
    frame_function->m_frame.f_lineno = 1074;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_47, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1074;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_61 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks(  );
    assert( var__testGetTasks == NULL );
    var__testGetTasks = tmp_assign_source_61;

    tmp_called_instance_48 = var_tm;

    CHECK_OBJECT( tmp_called_instance_48 );
    frame_function->m_frame.f_lineno = 1080;
    tmp_len_arg_13 = CALL_METHOD_NO_ARGS( tmp_called_instance_48, const_str_plain_getTasks );
    if ( tmp_len_arg_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_26 = BUILTIN_LEN( tmp_len_arg_13 );
    Py_DECREF( tmp_len_arg_13 );
    if ( tmp_compare_left_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1080;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_26 = const_int_0;
    tmp_cmp_Eq_23 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_26, tmp_compare_right_26 );
    if ( tmp_cmp_Eq_23 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_26 );

        exception_lineno = 1080;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_26 );
    if ( tmp_cmp_Eq_23 == 1 )
    {
        goto branch_no_27;
    }
    else
    {
        goto branch_yes_27;
    }
    branch_yes_27:;
    tmp_raise_type_26 = PyExc_AssertionError;
    exception_type = tmp_raise_type_26;
    Py_INCREF( tmp_raise_type_26 );
    exception_lineno = 1080;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_27:;
    tmp_called_instance_49 = var_tm;

    CHECK_OBJECT( tmp_called_instance_49 );
    tmp_args_element_name_28 = var__testGetTasks;

    CHECK_OBJECT( tmp_args_element_name_28 );
    tmp_args_element_name_29 = const_str_plain_testGetTasks1;
    frame_function->m_frame.f_lineno = 1081;
    {
        PyObject *call_args[] = { tmp_args_element_name_28, tmp_args_element_name_29 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_49, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1081;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_50 = var_tm;

    CHECK_OBJECT( tmp_called_instance_50 );
    frame_function->m_frame.f_lineno = 1082;
    tmp_len_arg_14 = CALL_METHOD_NO_ARGS( tmp_called_instance_50, const_str_plain_getTasks );
    if ( tmp_len_arg_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_27 = BUILTIN_LEN( tmp_len_arg_14 );
    Py_DECREF( tmp_len_arg_14 );
    if ( tmp_compare_left_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1082;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_27 = const_int_pos_1;
    tmp_cmp_Eq_24 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_27, tmp_compare_right_27 );
    if ( tmp_cmp_Eq_24 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_27 );

        exception_lineno = 1082;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_27 );
    if ( tmp_cmp_Eq_24 == 1 )
    {
        goto branch_no_28;
    }
    else
    {
        goto branch_yes_28;
    }
    branch_yes_28:;
    tmp_raise_type_27 = PyExc_AssertionError;
    exception_type = tmp_raise_type_27;
    Py_INCREF( tmp_raise_type_27 );
    exception_lineno = 1082;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_28:;
    tmp_called_instance_51 = var_tm;

    CHECK_OBJECT( tmp_called_instance_51 );
    frame_function->m_frame.f_lineno = 1083;
    tmp_subscribed_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_51, const_str_plain_getTasks );
    if ( tmp_subscribed_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_8 = const_int_0;
    tmp_source_name_21 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    Py_DECREF( tmp_subscribed_name_8 );
    if ( tmp_source_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_21, const_str_plain_name );
    Py_DECREF( tmp_source_name_21 );
    if ( tmp_compexpr_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_1 = const_str_plain_testGetTasks1;
    tmp_or_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_left_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1083;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_instance_52 = var_tm;

    CHECK_OBJECT( tmp_called_instance_52 );
    frame_function->m_frame.f_lineno = 1084;
    tmp_subscribed_name_9 = CALL_METHOD_NO_ARGS( tmp_called_instance_52, const_str_plain_getTasks );
    if ( tmp_subscribed_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_9 = const_int_pos_1;
    tmp_source_name_22 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    Py_DECREF( tmp_subscribed_name_9 );
    if ( tmp_source_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_left_2 = LOOKUP_ATTRIBUTE( tmp_source_name_22, const_str_plain_name );
    Py_DECREF( tmp_source_name_22 );
    if ( tmp_compexpr_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compexpr_right_2 = const_str_plain_testGetTasks1;
    tmp_or_right_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_left_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_4 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_4 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 1084;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_no_29;
    }
    else
    {
        goto branch_yes_29;
    }
    branch_yes_29:;
    tmp_raise_type_28 = PyExc_AssertionError;
    exception_type = tmp_raise_type_28;
    Py_INCREF( tmp_raise_type_28 );
    exception_lineno = 1083;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_29:;
    tmp_called_instance_53 = var_tm;

    CHECK_OBJECT( tmp_called_instance_53 );
    tmp_args_element_name_30 = var__testGetTasks;

    CHECK_OBJECT( tmp_args_element_name_30 );
    tmp_args_element_name_31 = const_str_plain_testGetTasks2;
    frame_function->m_frame.f_lineno = 1085;
    {
        PyObject *call_args[] = { tmp_args_element_name_30, tmp_args_element_name_31 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_53, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1085;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_54 = var_tm;

    CHECK_OBJECT( tmp_called_instance_54 );
    tmp_args_element_name_32 = var__testGetTasks;

    CHECK_OBJECT( tmp_args_element_name_32 );
    tmp_args_element_name_33 = const_str_plain_testGetTasks3;
    frame_function->m_frame.f_lineno = 1086;
    {
        PyObject *call_args[] = { tmp_args_element_name_32, tmp_args_element_name_33 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_54, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1086;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_55 = var_tm;

    CHECK_OBJECT( tmp_called_instance_55 );
    frame_function->m_frame.f_lineno = 1087;
    tmp_len_arg_15 = CALL_METHOD_NO_ARGS( tmp_called_instance_55, const_str_plain_getTasks );
    if ( tmp_len_arg_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1087;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_28 = BUILTIN_LEN( tmp_len_arg_15 );
    Py_DECREF( tmp_len_arg_15 );
    if ( tmp_compare_left_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1087;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_28 = const_int_pos_3;
    tmp_cmp_Eq_25 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_28, tmp_compare_right_28 );
    if ( tmp_cmp_Eq_25 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_28 );

        exception_lineno = 1087;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_28 );
    if ( tmp_cmp_Eq_25 == 1 )
    {
        goto branch_no_30;
    }
    else
    {
        goto branch_yes_30;
    }
    branch_yes_30:;
    tmp_raise_type_29 = PyExc_AssertionError;
    exception_type = tmp_raise_type_29;
    Py_INCREF( tmp_raise_type_29 );
    exception_lineno = 1087;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_30:;
    tmp_called_instance_56 = var_tm;

    CHECK_OBJECT( tmp_called_instance_56 );
    frame_function->m_frame.f_lineno = 1088;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_56, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasks2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1088;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_57 = var_tm;

    CHECK_OBJECT( tmp_called_instance_57 );
    frame_function->m_frame.f_lineno = 1089;
    tmp_len_arg_16 = CALL_METHOD_NO_ARGS( tmp_called_instance_57, const_str_plain_getTasks );
    if ( tmp_len_arg_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1089;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_29 = BUILTIN_LEN( tmp_len_arg_16 );
    Py_DECREF( tmp_len_arg_16 );
    if ( tmp_compare_left_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1089;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_29 = const_int_pos_2;
    tmp_cmp_Eq_26 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_29, tmp_compare_right_29 );
    if ( tmp_cmp_Eq_26 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_29 );

        exception_lineno = 1089;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_29 );
    if ( tmp_cmp_Eq_26 == 1 )
    {
        goto branch_no_31;
    }
    else
    {
        goto branch_yes_31;
    }
    branch_yes_31:;
    tmp_raise_type_30 = PyExc_AssertionError;
    exception_type = tmp_raise_type_30;
    Py_INCREF( tmp_raise_type_30 );
    exception_lineno = 1089;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_31:;
    tmp_called_instance_58 = var_tm;

    CHECK_OBJECT( tmp_called_instance_58 );
    frame_function->m_frame.f_lineno = 1090;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_58, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasks1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1090;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_59 = var_tm;

    CHECK_OBJECT( tmp_called_instance_59 );
    frame_function->m_frame.f_lineno = 1091;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_59, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasks3_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1091;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_60 = var_tm;

    CHECK_OBJECT( tmp_called_instance_60 );
    frame_function->m_frame.f_lineno = 1092;
    tmp_len_arg_17 = CALL_METHOD_NO_ARGS( tmp_called_instance_60, const_str_plain_getTasks );
    if ( tmp_len_arg_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_30 = BUILTIN_LEN( tmp_len_arg_17 );
    Py_DECREF( tmp_len_arg_17 );
    if ( tmp_compare_left_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1092;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_30 = const_int_0;
    tmp_cmp_Eq_27 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_30, tmp_compare_right_30 );
    if ( tmp_cmp_Eq_27 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_30 );

        exception_lineno = 1092;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_30 );
    if ( tmp_cmp_Eq_27 == 1 )
    {
        goto branch_no_32;
    }
    else
    {
        goto branch_yes_32;
    }
    branch_yes_32:;
    tmp_raise_type_31 = PyExc_AssertionError;
    exception_type = tmp_raise_type_31;
    Py_INCREF( tmp_raise_type_31 );
    exception_lineno = 1092;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_32:;
    Py_XDECREF( var__testGetTasks );
    var__testGetTasks = NULL;

    tmp_called_instance_61 = var_tm;

    CHECK_OBJECT( tmp_called_instance_61 );
    frame_function->m_frame.f_lineno = 1094;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_61, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1094;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_62 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters(  );
    assert( var__testGetDoLaters == NULL );
    var__testGetDoLaters = tmp_assign_source_62;

    tmp_called_instance_62 = var_tm;

    CHECK_OBJECT( tmp_called_instance_62 );
    frame_function->m_frame.f_lineno = 1099;
    tmp_len_arg_18 = CALL_METHOD_NO_ARGS( tmp_called_instance_62, const_str_plain_getDoLaters );
    if ( tmp_len_arg_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_31 = BUILTIN_LEN( tmp_len_arg_18 );
    Py_DECREF( tmp_len_arg_18 );
    if ( tmp_compare_left_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1099;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_31 = const_int_0;
    tmp_cmp_Eq_28 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_31, tmp_compare_right_31 );
    if ( tmp_cmp_Eq_28 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_31 );

        exception_lineno = 1099;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_31 );
    if ( tmp_cmp_Eq_28 == 1 )
    {
        goto branch_no_33;
    }
    else
    {
        goto branch_yes_33;
    }
    branch_yes_33:;
    tmp_raise_type_32 = PyExc_AssertionError;
    exception_type = tmp_raise_type_32;
    Py_INCREF( tmp_raise_type_32 );
    exception_lineno = 1099;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_33:;
    tmp_called_instance_63 = var_tm;

    CHECK_OBJECT( tmp_called_instance_63 );
    tmp_args_element_name_34 = const_float_0_1;
    tmp_args_element_name_35 = var__testGetDoLaters;

    CHECK_OBJECT( tmp_args_element_name_35 );
    tmp_args_element_name_36 = const_str_plain_testDoLater1;
    frame_function->m_frame.f_lineno = 1100;
    {
        PyObject *call_args[] = { tmp_args_element_name_34, tmp_args_element_name_35, tmp_args_element_name_36 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_63, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1100;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_64 = var_tm;

    CHECK_OBJECT( tmp_called_instance_64 );
    frame_function->m_frame.f_lineno = 1101;
    tmp_len_arg_19 = CALL_METHOD_NO_ARGS( tmp_called_instance_64, const_str_plain_getDoLaters );
    if ( tmp_len_arg_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1101;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_32 = BUILTIN_LEN( tmp_len_arg_19 );
    Py_DECREF( tmp_len_arg_19 );
    if ( tmp_compare_left_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1101;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_32 = const_int_pos_1;
    tmp_cmp_Eq_29 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_32, tmp_compare_right_32 );
    if ( tmp_cmp_Eq_29 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_32 );

        exception_lineno = 1101;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_32 );
    if ( tmp_cmp_Eq_29 == 1 )
    {
        goto branch_no_34;
    }
    else
    {
        goto branch_yes_34;
    }
    branch_yes_34:;
    tmp_raise_type_33 = PyExc_AssertionError;
    exception_type = tmp_raise_type_33;
    Py_INCREF( tmp_raise_type_33 );
    exception_lineno = 1101;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_34:;
    tmp_called_instance_65 = var_tm;

    CHECK_OBJECT( tmp_called_instance_65 );
    frame_function->m_frame.f_lineno = 1102;
    tmp_subscribed_name_10 = CALL_METHOD_NO_ARGS( tmp_called_instance_65, const_str_plain_getDoLaters );
    if ( tmp_subscribed_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1102;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_10 = const_int_0;
    tmp_source_name_23 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_10, tmp_subscript_name_10 );
    Py_DECREF( tmp_subscribed_name_10 );
    if ( tmp_source_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1102;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_33 = LOOKUP_ATTRIBUTE( tmp_source_name_23, const_str_plain_name );
    Py_DECREF( tmp_source_name_23 );
    if ( tmp_compare_left_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1102;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_33 = const_str_plain_testDoLater1;
    tmp_cmp_Eq_30 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_33, tmp_compare_right_33 );
    if ( tmp_cmp_Eq_30 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_33 );

        exception_lineno = 1102;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_33 );
    if ( tmp_cmp_Eq_30 == 1 )
    {
        goto branch_no_35;
    }
    else
    {
        goto branch_yes_35;
    }
    branch_yes_35:;
    tmp_raise_type_34 = PyExc_AssertionError;
    exception_type = tmp_raise_type_34;
    Py_INCREF( tmp_raise_type_34 );
    exception_lineno = 1102;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_35:;
    tmp_called_instance_66 = var_tm;

    CHECK_OBJECT( tmp_called_instance_66 );
    tmp_args_element_name_37 = const_float_0_1;
    tmp_args_element_name_38 = var__testGetDoLaters;

    CHECK_OBJECT( tmp_args_element_name_38 );
    tmp_args_element_name_39 = const_str_plain_testDoLater2;
    frame_function->m_frame.f_lineno = 1103;
    {
        PyObject *call_args[] = { tmp_args_element_name_37, tmp_args_element_name_38, tmp_args_element_name_39 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_66, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1103;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_67 = var_tm;

    CHECK_OBJECT( tmp_called_instance_67 );
    tmp_args_element_name_40 = const_float_0_1;
    tmp_args_element_name_41 = var__testGetDoLaters;

    CHECK_OBJECT( tmp_args_element_name_41 );
    tmp_args_element_name_42 = const_str_plain_testDoLater3;
    frame_function->m_frame.f_lineno = 1104;
    {
        PyObject *call_args[] = { tmp_args_element_name_40, tmp_args_element_name_41, tmp_args_element_name_42 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_67, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1104;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_68 = var_tm;

    CHECK_OBJECT( tmp_called_instance_68 );
    frame_function->m_frame.f_lineno = 1105;
    tmp_len_arg_20 = CALL_METHOD_NO_ARGS( tmp_called_instance_68, const_str_plain_getDoLaters );
    if ( tmp_len_arg_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1105;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_34 = BUILTIN_LEN( tmp_len_arg_20 );
    Py_DECREF( tmp_len_arg_20 );
    if ( tmp_compare_left_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1105;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_34 = const_int_pos_3;
    tmp_cmp_Eq_31 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_34, tmp_compare_right_34 );
    if ( tmp_cmp_Eq_31 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_34 );

        exception_lineno = 1105;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_34 );
    if ( tmp_cmp_Eq_31 == 1 )
    {
        goto branch_no_36;
    }
    else
    {
        goto branch_yes_36;
    }
    branch_yes_36:;
    tmp_raise_type_35 = PyExc_AssertionError;
    exception_type = tmp_raise_type_35;
    Py_INCREF( tmp_raise_type_35 );
    exception_lineno = 1105;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_36:;
    tmp_called_instance_69 = var_tm;

    CHECK_OBJECT( tmp_called_instance_69 );
    frame_function->m_frame.f_lineno = 1106;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_69, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testDoLater2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1106;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_70 = var_tm;

    CHECK_OBJECT( tmp_called_instance_70 );
    frame_function->m_frame.f_lineno = 1107;
    tmp_len_arg_21 = CALL_METHOD_NO_ARGS( tmp_called_instance_70, const_str_plain_getDoLaters );
    if ( tmp_len_arg_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1107;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_35 = BUILTIN_LEN( tmp_len_arg_21 );
    Py_DECREF( tmp_len_arg_21 );
    if ( tmp_compare_left_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1107;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_35 = const_int_pos_2;
    tmp_cmp_Eq_32 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_35, tmp_compare_right_35 );
    if ( tmp_cmp_Eq_32 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_35 );

        exception_lineno = 1107;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_35 );
    if ( tmp_cmp_Eq_32 == 1 )
    {
        goto branch_no_37;
    }
    else
    {
        goto branch_yes_37;
    }
    branch_yes_37:;
    tmp_raise_type_36 = PyExc_AssertionError;
    exception_type = tmp_raise_type_36;
    Py_INCREF( tmp_raise_type_36 );
    exception_lineno = 1107;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_37:;
    tmp_called_instance_71 = var_tm;

    CHECK_OBJECT( tmp_called_instance_71 );
    frame_function->m_frame.f_lineno = 1108;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_71, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testDoLater1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1108;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_72 = var_tm;

    CHECK_OBJECT( tmp_called_instance_72 );
    frame_function->m_frame.f_lineno = 1109;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_72, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testDoLater3_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1109;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_73 = var_tm;

    CHECK_OBJECT( tmp_called_instance_73 );
    frame_function->m_frame.f_lineno = 1110;
    tmp_len_arg_22 = CALL_METHOD_NO_ARGS( tmp_called_instance_73, const_str_plain_getDoLaters );
    if ( tmp_len_arg_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1110;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_36 = BUILTIN_LEN( tmp_len_arg_22 );
    Py_DECREF( tmp_len_arg_22 );
    if ( tmp_compare_left_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1110;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_36 = const_int_0;
    tmp_cmp_Eq_33 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_36, tmp_compare_right_36 );
    if ( tmp_cmp_Eq_33 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_36 );

        exception_lineno = 1110;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_36 );
    if ( tmp_cmp_Eq_33 == 1 )
    {
        goto branch_no_38;
    }
    else
    {
        goto branch_yes_38;
    }
    branch_yes_38:;
    tmp_raise_type_37 = PyExc_AssertionError;
    exception_type = tmp_raise_type_37;
    Py_INCREF( tmp_raise_type_37 );
    exception_lineno = 1110;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_38:;
    Py_XDECREF( var__testGetDoLaters );
    var__testGetDoLaters = NULL;

    tmp_called_instance_74 = var_tm;

    CHECK_OBJECT( tmp_called_instance_74 );
    frame_function->m_frame.f_lineno = 1112;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_74, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1112;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_63 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters(  );
    assert( var__testDupNameDoLaters == NULL );
    var__testDupNameDoLaters = tmp_assign_source_63;

    tmp_called_instance_75 = var_tm;

    CHECK_OBJECT( tmp_called_instance_75 );
    tmp_args_element_name_43 = const_float_0_1;
    tmp_args_element_name_44 = var__testDupNameDoLaters;

    CHECK_OBJECT( tmp_args_element_name_44 );
    tmp_args_element_name_45 = const_str_plain_testDupNameDoLater;
    frame_function->m_frame.f_lineno = 1118;
    {
        PyObject *call_args[] = { tmp_args_element_name_43, tmp_args_element_name_44, tmp_args_element_name_45 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_75, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1118;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_76 = var_tm;

    CHECK_OBJECT( tmp_called_instance_76 );
    tmp_args_element_name_46 = const_float_0_1;
    tmp_args_element_name_47 = var__testDupNameDoLaters;

    CHECK_OBJECT( tmp_args_element_name_47 );
    tmp_args_element_name_48 = const_str_plain_testDupNameDoLater;
    frame_function->m_frame.f_lineno = 1119;
    {
        PyObject *call_args[] = { tmp_args_element_name_46, tmp_args_element_name_47, tmp_args_element_name_48 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_76, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1119;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_77 = var_tm;

    CHECK_OBJECT( tmp_called_instance_77 );
    frame_function->m_frame.f_lineno = 1120;
    tmp_len_arg_23 = CALL_METHOD_NO_ARGS( tmp_called_instance_77, const_str_plain_getDoLaters );
    if ( tmp_len_arg_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1120;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_37 = BUILTIN_LEN( tmp_len_arg_23 );
    Py_DECREF( tmp_len_arg_23 );
    if ( tmp_compare_left_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1120;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_37 = const_int_pos_2;
    tmp_cmp_Eq_34 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_37, tmp_compare_right_37 );
    if ( tmp_cmp_Eq_34 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_37 );

        exception_lineno = 1120;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_37 );
    if ( tmp_cmp_Eq_34 == 1 )
    {
        goto branch_no_39;
    }
    else
    {
        goto branch_yes_39;
    }
    branch_yes_39:;
    tmp_raise_type_38 = PyExc_AssertionError;
    exception_type = tmp_raise_type_38;
    Py_INCREF( tmp_raise_type_38 );
    exception_lineno = 1120;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_39:;
    tmp_called_instance_78 = var_tm;

    CHECK_OBJECT( tmp_called_instance_78 );
    frame_function->m_frame.f_lineno = 1121;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_78, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testDupNameDoLater_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1121;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_79 = var_tm;

    CHECK_OBJECT( tmp_called_instance_79 );
    frame_function->m_frame.f_lineno = 1122;
    tmp_len_arg_24 = CALL_METHOD_NO_ARGS( tmp_called_instance_79, const_str_plain_getDoLaters );
    if ( tmp_len_arg_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_38 = BUILTIN_LEN( tmp_len_arg_24 );
    Py_DECREF( tmp_len_arg_24 );
    if ( tmp_compare_left_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1122;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_38 = const_int_0;
    tmp_cmp_Eq_35 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_38, tmp_compare_right_38 );
    if ( tmp_cmp_Eq_35 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_38 );

        exception_lineno = 1122;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_38 );
    if ( tmp_cmp_Eq_35 == 1 )
    {
        goto branch_no_40;
    }
    else
    {
        goto branch_yes_40;
    }
    branch_yes_40:;
    tmp_raise_type_39 = PyExc_AssertionError;
    exception_type = tmp_raise_type_39;
    Py_INCREF( tmp_raise_type_39 );
    exception_lineno = 1122;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_40:;
    Py_XDECREF( var__testDupNameDoLaters );
    var__testDupNameDoLaters = NULL;

    tmp_called_instance_80 = var_tm;

    CHECK_OBJECT( tmp_called_instance_80 );
    frame_function->m_frame.f_lineno = 1124;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_80, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1124;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_64 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove(  );
    assert( var__testDupNameDoLatersRemove == NULL );
    var__testDupNameDoLatersRemove = tmp_assign_source_64;

    tmp_called_instance_81 = var_tm;

    CHECK_OBJECT( tmp_called_instance_81 );
    tmp_args_element_name_49 = const_float_0_1;
    tmp_args_element_name_50 = var__testDupNameDoLatersRemove;

    CHECK_OBJECT( tmp_args_element_name_50 );
    tmp_args_element_name_51 = const_str_plain_testDupNameDoLaterRemove;
    frame_function->m_frame.f_lineno = 1130;
    {
        PyObject *call_args[] = { tmp_args_element_name_49, tmp_args_element_name_50, tmp_args_element_name_51 };
        tmp_assign_source_65 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_81, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_assign_source_65 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1130;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dl1 == NULL );
    var_dl1 = tmp_assign_source_65;

    tmp_called_instance_82 = var_tm;

    CHECK_OBJECT( tmp_called_instance_82 );
    tmp_args_element_name_52 = const_float_0_1;
    tmp_args_element_name_53 = var__testDupNameDoLatersRemove;

    CHECK_OBJECT( tmp_args_element_name_53 );
    tmp_args_element_name_54 = const_str_plain_testDupNameDoLaterRemove;
    frame_function->m_frame.f_lineno = 1131;
    {
        PyObject *call_args[] = { tmp_args_element_name_52, tmp_args_element_name_53, tmp_args_element_name_54 };
        tmp_assign_source_66 = CALL_METHOD_WITH_ARGS3( tmp_called_instance_82, const_str_plain_doMethodLater, call_args );
    }

    if ( tmp_assign_source_66 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1131;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_dl2 == NULL );
    var_dl2 = tmp_assign_source_66;

    tmp_called_instance_83 = var_tm;

    CHECK_OBJECT( tmp_called_instance_83 );
    frame_function->m_frame.f_lineno = 1132;
    tmp_len_arg_25 = CALL_METHOD_NO_ARGS( tmp_called_instance_83, const_str_plain_getDoLaters );
    if ( tmp_len_arg_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1132;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_39 = BUILTIN_LEN( tmp_len_arg_25 );
    Py_DECREF( tmp_len_arg_25 );
    if ( tmp_compare_left_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1132;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_39 = const_int_pos_2;
    tmp_cmp_Eq_36 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_39, tmp_compare_right_39 );
    if ( tmp_cmp_Eq_36 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_39 );

        exception_lineno = 1132;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_39 );
    if ( tmp_cmp_Eq_36 == 1 )
    {
        goto branch_no_41;
    }
    else
    {
        goto branch_yes_41;
    }
    branch_yes_41:;
    tmp_raise_type_40 = PyExc_AssertionError;
    exception_type = tmp_raise_type_40;
    Py_INCREF( tmp_raise_type_40 );
    exception_lineno = 1132;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_41:;
    tmp_called_instance_84 = var_dl2;

    CHECK_OBJECT( tmp_called_instance_84 );
    frame_function->m_frame.f_lineno = 1133;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_84, const_str_plain_remove );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1133;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_85 = var_tm;

    CHECK_OBJECT( tmp_called_instance_85 );
    frame_function->m_frame.f_lineno = 1134;
    tmp_len_arg_26 = CALL_METHOD_NO_ARGS( tmp_called_instance_85, const_str_plain_getDoLaters );
    if ( tmp_len_arg_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1134;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_40 = BUILTIN_LEN( tmp_len_arg_26 );
    Py_DECREF( tmp_len_arg_26 );
    if ( tmp_compare_left_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1134;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_40 = const_int_pos_1;
    tmp_cmp_Eq_37 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_40, tmp_compare_right_40 );
    if ( tmp_cmp_Eq_37 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_40 );

        exception_lineno = 1134;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_40 );
    if ( tmp_cmp_Eq_37 == 1 )
    {
        goto branch_no_42;
    }
    else
    {
        goto branch_yes_42;
    }
    branch_yes_42:;
    tmp_raise_type_41 = PyExc_AssertionError;
    exception_type = tmp_raise_type_41;
    Py_INCREF( tmp_raise_type_41 );
    exception_lineno = 1134;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_42:;
    tmp_called_instance_86 = var_dl1;

    CHECK_OBJECT( tmp_called_instance_86 );
    frame_function->m_frame.f_lineno = 1135;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_86, const_str_plain_remove );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1135;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_87 = var_tm;

    CHECK_OBJECT( tmp_called_instance_87 );
    frame_function->m_frame.f_lineno = 1136;
    tmp_len_arg_27 = CALL_METHOD_NO_ARGS( tmp_called_instance_87, const_str_plain_getDoLaters );
    if ( tmp_len_arg_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1136;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_41 = BUILTIN_LEN( tmp_len_arg_27 );
    Py_DECREF( tmp_len_arg_27 );
    if ( tmp_compare_left_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1136;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_41 = const_int_0;
    tmp_cmp_Eq_38 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_41, tmp_compare_right_41 );
    if ( tmp_cmp_Eq_38 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_41 );

        exception_lineno = 1136;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_41 );
    if ( tmp_cmp_Eq_38 == 1 )
    {
        goto branch_no_43;
    }
    else
    {
        goto branch_yes_43;
    }
    branch_yes_43:;
    tmp_raise_type_42 = PyExc_AssertionError;
    exception_type = tmp_raise_type_42;
    Py_INCREF( tmp_raise_type_42 );
    exception_lineno = 1136;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_43:;
    Py_XDECREF( var__testDupNameDoLatersRemove );
    var__testDupNameDoLatersRemove = NULL;

    tmp_called_instance_88 = var_tm;

    CHECK_OBJECT( tmp_called_instance_88 );
    frame_function->m_frame.f_lineno = 1139;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_88, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1139;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_67 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed(  );
    assert( var__testGetTasksNamed == NULL );
    var__testGetTasksNamed = tmp_assign_source_67;

    tmp_called_instance_89 = var_tm;

    CHECK_OBJECT( tmp_called_instance_89 );
    frame_function->m_frame.f_lineno = 1144;
    tmp_len_arg_28 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_89, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_len_arg_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1144;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_42 = BUILTIN_LEN( tmp_len_arg_28 );
    Py_DECREF( tmp_len_arg_28 );
    if ( tmp_compare_left_42 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1144;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_42 = const_int_0;
    tmp_cmp_Eq_39 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_42, tmp_compare_right_42 );
    if ( tmp_cmp_Eq_39 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_42 );

        exception_lineno = 1144;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_42 );
    if ( tmp_cmp_Eq_39 == 1 )
    {
        goto branch_no_44;
    }
    else
    {
        goto branch_yes_44;
    }
    branch_yes_44:;
    tmp_raise_type_43 = PyExc_AssertionError;
    exception_type = tmp_raise_type_43;
    Py_INCREF( tmp_raise_type_43 );
    exception_lineno = 1144;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_44:;
    tmp_called_instance_90 = var_tm;

    CHECK_OBJECT( tmp_called_instance_90 );
    tmp_args_element_name_55 = var__testGetTasksNamed;

    CHECK_OBJECT( tmp_args_element_name_55 );
    tmp_args_element_name_56 = const_str_plain_testGetTasksNamed;
    frame_function->m_frame.f_lineno = 1145;
    {
        PyObject *call_args[] = { tmp_args_element_name_55, tmp_args_element_name_56 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_90, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1145;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_91 = var_tm;

    CHECK_OBJECT( tmp_called_instance_91 );
    frame_function->m_frame.f_lineno = 1146;
    tmp_len_arg_29 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_91, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_len_arg_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_43 = BUILTIN_LEN( tmp_len_arg_29 );
    Py_DECREF( tmp_len_arg_29 );
    if ( tmp_compare_left_43 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1146;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_43 = const_int_pos_1;
    tmp_cmp_Eq_40 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_43, tmp_compare_right_43 );
    if ( tmp_cmp_Eq_40 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_43 );

        exception_lineno = 1146;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_43 );
    if ( tmp_cmp_Eq_40 == 1 )
    {
        goto branch_no_45;
    }
    else
    {
        goto branch_yes_45;
    }
    branch_yes_45:;
    tmp_raise_type_44 = PyExc_AssertionError;
    exception_type = tmp_raise_type_44;
    Py_INCREF( tmp_raise_type_44 );
    exception_lineno = 1146;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_45:;
    tmp_called_instance_92 = var_tm;

    CHECK_OBJECT( tmp_called_instance_92 );
    frame_function->m_frame.f_lineno = 1147;
    tmp_subscribed_name_11 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_92, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_subscribed_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_subscript_name_11 = const_int_0;
    tmp_source_name_24 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_11, tmp_subscript_name_11 );
    Py_DECREF( tmp_subscribed_name_11 );
    if ( tmp_source_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_44 = LOOKUP_ATTRIBUTE( tmp_source_name_24, const_str_plain_name );
    Py_DECREF( tmp_source_name_24 );
    if ( tmp_compare_left_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1147;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_44 = const_str_plain_testGetTasksNamed;
    tmp_cmp_Eq_41 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_44, tmp_compare_right_44 );
    if ( tmp_cmp_Eq_41 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_44 );

        exception_lineno = 1147;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_44 );
    if ( tmp_cmp_Eq_41 == 1 )
    {
        goto branch_no_46;
    }
    else
    {
        goto branch_yes_46;
    }
    branch_yes_46:;
    tmp_raise_type_45 = PyExc_AssertionError;
    exception_type = tmp_raise_type_45;
    Py_INCREF( tmp_raise_type_45 );
    exception_lineno = 1147;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_46:;
    tmp_called_instance_93 = var_tm;

    CHECK_OBJECT( tmp_called_instance_93 );
    tmp_args_element_name_57 = var__testGetTasksNamed;

    CHECK_OBJECT( tmp_args_element_name_57 );
    tmp_args_element_name_58 = const_str_plain_testGetTasksNamed;
    frame_function->m_frame.f_lineno = 1148;
    {
        PyObject *call_args[] = { tmp_args_element_name_57, tmp_args_element_name_58 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_93, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1148;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_94 = var_tm;

    CHECK_OBJECT( tmp_called_instance_94 );
    tmp_args_element_name_59 = var__testGetTasksNamed;

    CHECK_OBJECT( tmp_args_element_name_59 );
    tmp_args_element_name_60 = const_str_plain_testGetTasksNamed;
    frame_function->m_frame.f_lineno = 1149;
    {
        PyObject *call_args[] = { tmp_args_element_name_59, tmp_args_element_name_60 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_94, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1149;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_95 = var_tm;

    CHECK_OBJECT( tmp_called_instance_95 );
    frame_function->m_frame.f_lineno = 1150;
    tmp_len_arg_30 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_95, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_len_arg_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1150;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_45 = BUILTIN_LEN( tmp_len_arg_30 );
    Py_DECREF( tmp_len_arg_30 );
    if ( tmp_compare_left_45 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1150;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_45 = const_int_pos_3;
    tmp_cmp_Eq_42 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_45, tmp_compare_right_45 );
    if ( tmp_cmp_Eq_42 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_45 );

        exception_lineno = 1150;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_45 );
    if ( tmp_cmp_Eq_42 == 1 )
    {
        goto branch_no_47;
    }
    else
    {
        goto branch_yes_47;
    }
    branch_yes_47:;
    tmp_raise_type_46 = PyExc_AssertionError;
    exception_type = tmp_raise_type_46;
    Py_INCREF( tmp_raise_type_46 );
    exception_lineno = 1150;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_47:;
    tmp_called_instance_96 = var_tm;

    CHECK_OBJECT( tmp_called_instance_96 );
    frame_function->m_frame.f_lineno = 1151;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_96, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1151;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_97 = var_tm;

    CHECK_OBJECT( tmp_called_instance_97 );
    frame_function->m_frame.f_lineno = 1152;
    tmp_len_arg_31 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_97, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testGetTasksNamed_tuple, 0 ) );

    if ( tmp_len_arg_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_46 = BUILTIN_LEN( tmp_len_arg_31 );
    Py_DECREF( tmp_len_arg_31 );
    if ( tmp_compare_left_46 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1152;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_46 = const_int_0;
    tmp_cmp_Eq_43 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_46, tmp_compare_right_46 );
    if ( tmp_cmp_Eq_43 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_46 );

        exception_lineno = 1152;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_46 );
    if ( tmp_cmp_Eq_43 == 1 )
    {
        goto branch_no_48;
    }
    else
    {
        goto branch_yes_48;
    }
    branch_yes_48:;
    tmp_raise_type_47 = PyExc_AssertionError;
    exception_type = tmp_raise_type_47;
    Py_INCREF( tmp_raise_type_47 );
    exception_lineno = 1152;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_48:;
    Py_XDECREF( var__testGetTasksNamed );
    var__testGetTasksNamed = NULL;

    tmp_called_instance_98 = var_tm;

    CHECK_OBJECT( tmp_called_instance_98 );
    frame_function->m_frame.f_lineno = 1154;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_98, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1154;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_68 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching(  );
    assert( var__testRemoveTasksMatching == NULL );
    var__testRemoveTasksMatching = tmp_assign_source_68;

    tmp_called_instance_99 = var_tm;

    CHECK_OBJECT( tmp_called_instance_99 );
    tmp_args_element_name_61 = var__testRemoveTasksMatching;

    CHECK_OBJECT( tmp_args_element_name_61 );
    tmp_args_element_name_62 = const_str_plain_testRemoveTasksMatching;
    frame_function->m_frame.f_lineno = 1159;
    {
        PyObject *call_args[] = { tmp_args_element_name_61, tmp_args_element_name_62 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_99, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1159;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_100 = var_tm;

    CHECK_OBJECT( tmp_called_instance_100 );
    frame_function->m_frame.f_lineno = 1160;
    tmp_len_arg_32 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_100, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching_tuple, 0 ) );

    if ( tmp_len_arg_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_47 = BUILTIN_LEN( tmp_len_arg_32 );
    Py_DECREF( tmp_len_arg_32 );
    if ( tmp_compare_left_47 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1160;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_47 = const_int_pos_1;
    tmp_cmp_Eq_44 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_47, tmp_compare_right_47 );
    if ( tmp_cmp_Eq_44 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_47 );

        exception_lineno = 1160;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_47 );
    if ( tmp_cmp_Eq_44 == 1 )
    {
        goto branch_no_49;
    }
    else
    {
        goto branch_yes_49;
    }
    branch_yes_49:;
    tmp_raise_type_48 = PyExc_AssertionError;
    exception_type = tmp_raise_type_48;
    Py_INCREF( tmp_raise_type_48 );
    exception_lineno = 1160;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_49:;
    tmp_called_instance_101 = var_tm;

    CHECK_OBJECT( tmp_called_instance_101 );
    frame_function->m_frame.f_lineno = 1161;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_101, const_str_plain_removeTasksMatching, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1161;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_102 = var_tm;

    CHECK_OBJECT( tmp_called_instance_102 );
    frame_function->m_frame.f_lineno = 1162;
    tmp_len_arg_33 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_102, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching_tuple, 0 ) );

    if ( tmp_len_arg_33 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_48 = BUILTIN_LEN( tmp_len_arg_33 );
    Py_DECREF( tmp_len_arg_33 );
    if ( tmp_compare_left_48 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1162;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_48 = const_int_0;
    tmp_cmp_Eq_45 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_48, tmp_compare_right_48 );
    if ( tmp_cmp_Eq_45 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_48 );

        exception_lineno = 1162;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_48 );
    if ( tmp_cmp_Eq_45 == 1 )
    {
        goto branch_no_50;
    }
    else
    {
        goto branch_yes_50;
    }
    branch_yes_50:;
    tmp_raise_type_49 = PyExc_AssertionError;
    exception_type = tmp_raise_type_49;
    Py_INCREF( tmp_raise_type_49 );
    exception_lineno = 1162;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_50:;
    tmp_called_instance_103 = var_tm;

    CHECK_OBJECT( tmp_called_instance_103 );
    tmp_args_element_name_63 = var__testRemoveTasksMatching;

    CHECK_OBJECT( tmp_args_element_name_63 );
    tmp_args_element_name_64 = const_str_plain_testRemoveTasksMatching1;
    frame_function->m_frame.f_lineno = 1163;
    {
        PyObject *call_args[] = { tmp_args_element_name_63, tmp_args_element_name_64 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_103, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1163;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_104 = var_tm;

    CHECK_OBJECT( tmp_called_instance_104 );
    tmp_args_element_name_65 = var__testRemoveTasksMatching;

    CHECK_OBJECT( tmp_args_element_name_65 );
    tmp_args_element_name_66 = const_str_plain_testRemoveTasksMatching2;
    frame_function->m_frame.f_lineno = 1164;
    {
        PyObject *call_args[] = { tmp_args_element_name_65, tmp_args_element_name_66 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_104, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1164;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_105 = var_tm;

    CHECK_OBJECT( tmp_called_instance_105 );
    frame_function->m_frame.f_lineno = 1165;
    tmp_len_arg_34 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_105, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1_tuple, 0 ) );

    if ( tmp_len_arg_34 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1165;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_49 = BUILTIN_LEN( tmp_len_arg_34 );
    Py_DECREF( tmp_len_arg_34 );
    if ( tmp_compare_left_49 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1165;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_49 = const_int_pos_1;
    tmp_cmp_Eq_46 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_49, tmp_compare_right_49 );
    if ( tmp_cmp_Eq_46 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_49 );

        exception_lineno = 1165;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_49 );
    if ( tmp_cmp_Eq_46 == 1 )
    {
        goto branch_no_51;
    }
    else
    {
        goto branch_yes_51;
    }
    branch_yes_51:;
    tmp_raise_type_50 = PyExc_AssertionError;
    exception_type = tmp_raise_type_50;
    Py_INCREF( tmp_raise_type_50 );
    exception_lineno = 1165;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_51:;
    tmp_called_instance_106 = var_tm;

    CHECK_OBJECT( tmp_called_instance_106 );
    frame_function->m_frame.f_lineno = 1166;
    tmp_len_arg_35 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_106, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2_tuple, 0 ) );

    if ( tmp_len_arg_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1166;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_50 = BUILTIN_LEN( tmp_len_arg_35 );
    Py_DECREF( tmp_len_arg_35 );
    if ( tmp_compare_left_50 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1166;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_50 = const_int_pos_1;
    tmp_cmp_Eq_47 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_50, tmp_compare_right_50 );
    if ( tmp_cmp_Eq_47 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_50 );

        exception_lineno = 1166;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_50 );
    if ( tmp_cmp_Eq_47 == 1 )
    {
        goto branch_no_52;
    }
    else
    {
        goto branch_yes_52;
    }
    branch_yes_52:;
    tmp_raise_type_51 = PyExc_AssertionError;
    exception_type = tmp_raise_type_51;
    Py_INCREF( tmp_raise_type_51 );
    exception_lineno = 1166;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_52:;
    tmp_called_instance_107 = var_tm;

    CHECK_OBJECT( tmp_called_instance_107 );
    frame_function->m_frame.f_lineno = 1167;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_107, const_str_plain_removeTasksMatching, &PyTuple_GET_ITEM( const_tuple_str_digest_3fcb20a2b10f78ed50997ba96a9cd3bf_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1167;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_108 = var_tm;

    CHECK_OBJECT( tmp_called_instance_108 );
    frame_function->m_frame.f_lineno = 1168;
    tmp_len_arg_36 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_108, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1_tuple, 0 ) );

    if ( tmp_len_arg_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_51 = BUILTIN_LEN( tmp_len_arg_36 );
    Py_DECREF( tmp_len_arg_36 );
    if ( tmp_compare_left_51 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1168;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_51 = const_int_0;
    tmp_cmp_Eq_48 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_51, tmp_compare_right_51 );
    if ( tmp_cmp_Eq_48 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_51 );

        exception_lineno = 1168;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_51 );
    if ( tmp_cmp_Eq_48 == 1 )
    {
        goto branch_no_53;
    }
    else
    {
        goto branch_yes_53;
    }
    branch_yes_53:;
    tmp_raise_type_52 = PyExc_AssertionError;
    exception_type = tmp_raise_type_52;
    Py_INCREF( tmp_raise_type_52 );
    exception_lineno = 1168;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_53:;
    tmp_called_instance_109 = var_tm;

    CHECK_OBJECT( tmp_called_instance_109 );
    frame_function->m_frame.f_lineno = 1169;
    tmp_len_arg_37 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_109, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2_tuple, 0 ) );

    if ( tmp_len_arg_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1169;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_52 = BUILTIN_LEN( tmp_len_arg_37 );
    Py_DECREF( tmp_len_arg_37 );
    if ( tmp_compare_left_52 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1169;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_52 = const_int_0;
    tmp_cmp_Eq_49 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_52, tmp_compare_right_52 );
    if ( tmp_cmp_Eq_49 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_52 );

        exception_lineno = 1169;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_52 );
    if ( tmp_cmp_Eq_49 == 1 )
    {
        goto branch_no_54;
    }
    else
    {
        goto branch_yes_54;
    }
    branch_yes_54:;
    tmp_raise_type_53 = PyExc_AssertionError;
    exception_type = tmp_raise_type_53;
    Py_INCREF( tmp_raise_type_53 );
    exception_lineno = 1169;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_54:;
    tmp_called_instance_110 = var_tm;

    CHECK_OBJECT( tmp_called_instance_110 );
    tmp_args_element_name_67 = var__testRemoveTasksMatching;

    CHECK_OBJECT( tmp_args_element_name_67 );
    tmp_args_element_name_68 = const_str_plain_testRemoveTasksMatching1a;
    frame_function->m_frame.f_lineno = 1170;
    {
        PyObject *call_args[] = { tmp_args_element_name_67, tmp_args_element_name_68 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_110, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1170;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_111 = var_tm;

    CHECK_OBJECT( tmp_called_instance_111 );
    tmp_args_element_name_69 = var__testRemoveTasksMatching;

    CHECK_OBJECT( tmp_args_element_name_69 );
    tmp_args_element_name_70 = const_str_plain_testRemoveTasksMatching2a;
    frame_function->m_frame.f_lineno = 1171;
    {
        PyObject *call_args[] = { tmp_args_element_name_69, tmp_args_element_name_70 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_111, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1171;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_112 = var_tm;

    CHECK_OBJECT( tmp_called_instance_112 );
    frame_function->m_frame.f_lineno = 1172;
    tmp_len_arg_38 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_112, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1a_tuple, 0 ) );

    if ( tmp_len_arg_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_53 = BUILTIN_LEN( tmp_len_arg_38 );
    Py_DECREF( tmp_len_arg_38 );
    if ( tmp_compare_left_53 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1172;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_53 = const_int_pos_1;
    tmp_cmp_Eq_50 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_53, tmp_compare_right_53 );
    if ( tmp_cmp_Eq_50 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_53 );

        exception_lineno = 1172;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_53 );
    if ( tmp_cmp_Eq_50 == 1 )
    {
        goto branch_no_55;
    }
    else
    {
        goto branch_yes_55;
    }
    branch_yes_55:;
    tmp_raise_type_54 = PyExc_AssertionError;
    exception_type = tmp_raise_type_54;
    Py_INCREF( tmp_raise_type_54 );
    exception_lineno = 1172;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_55:;
    tmp_called_instance_113 = var_tm;

    CHECK_OBJECT( tmp_called_instance_113 );
    frame_function->m_frame.f_lineno = 1173;
    tmp_len_arg_39 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_113, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2a_tuple, 0 ) );

    if ( tmp_len_arg_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_54 = BUILTIN_LEN( tmp_len_arg_39 );
    Py_DECREF( tmp_len_arg_39 );
    if ( tmp_compare_left_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1173;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_54 = const_int_pos_1;
    tmp_cmp_Eq_51 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_54, tmp_compare_right_54 );
    if ( tmp_cmp_Eq_51 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_54 );

        exception_lineno = 1173;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_54 );
    if ( tmp_cmp_Eq_51 == 1 )
    {
        goto branch_no_56;
    }
    else
    {
        goto branch_yes_56;
    }
    branch_yes_56:;
    tmp_raise_type_55 = PyExc_AssertionError;
    exception_type = tmp_raise_type_55;
    Py_INCREF( tmp_raise_type_55 );
    exception_lineno = 1173;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_56:;
    tmp_called_instance_114 = var_tm;

    CHECK_OBJECT( tmp_called_instance_114 );
    frame_function->m_frame.f_lineno = 1174;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_114, const_str_plain_removeTasksMatching, &PyTuple_GET_ITEM( const_tuple_str_digest_cab1cf07ff08dc0602ae6ddf96cd3c77_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1174;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_115 = var_tm;

    CHECK_OBJECT( tmp_called_instance_115 );
    frame_function->m_frame.f_lineno = 1175;
    tmp_len_arg_40 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_115, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching1a_tuple, 0 ) );

    if ( tmp_len_arg_40 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_55 = BUILTIN_LEN( tmp_len_arg_40 );
    Py_DECREF( tmp_len_arg_40 );
    if ( tmp_compare_left_55 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1175;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_55 = const_int_0;
    tmp_cmp_Eq_52 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_55, tmp_compare_right_55 );
    if ( tmp_cmp_Eq_52 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_55 );

        exception_lineno = 1175;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_55 );
    if ( tmp_cmp_Eq_52 == 1 )
    {
        goto branch_no_57;
    }
    else
    {
        goto branch_yes_57;
    }
    branch_yes_57:;
    tmp_raise_type_56 = PyExc_AssertionError;
    exception_type = tmp_raise_type_56;
    Py_INCREF( tmp_raise_type_56 );
    exception_lineno = 1175;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_57:;
    tmp_called_instance_116 = var_tm;

    CHECK_OBJECT( tmp_called_instance_116 );
    frame_function->m_frame.f_lineno = 1176;
    tmp_len_arg_41 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_116, const_str_plain_getTasksNamed, &PyTuple_GET_ITEM( const_tuple_str_plain_testRemoveTasksMatching2a_tuple, 0 ) );

    if ( tmp_len_arg_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_left_56 = BUILTIN_LEN( tmp_len_arg_41 );
    Py_DECREF( tmp_len_arg_41 );
    if ( tmp_compare_left_56 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1176;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_56 = const_int_0;
    tmp_cmp_Eq_53 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_56, tmp_compare_right_56 );
    if ( tmp_cmp_Eq_53 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_56 );

        exception_lineno = 1176;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_56 );
    if ( tmp_cmp_Eq_53 == 1 )
    {
        goto branch_no_58;
    }
    else
    {
        goto branch_yes_58;
    }
    branch_yes_58:;
    tmp_raise_type_57 = PyExc_AssertionError;
    exception_type = tmp_raise_type_57;
    Py_INCREF( tmp_raise_type_57 );
    exception_lineno = 1176;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_58:;
    Py_XDECREF( var__testRemoveTasksMatching );
    var__testRemoveTasksMatching = NULL;

    tmp_called_instance_117 = var_tm;

    CHECK_OBJECT( tmp_called_instance_117 );
    frame_function->m_frame.f_lineno = 1178;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_117, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1178;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_69 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_69;
        Py_DECREF( old );
    }

    tmp_defaults_24 = PyTuple_New( 1 );
    tmp_tuple_element_42 = var_l;

    CHECK_OBJECT( tmp_tuple_element_42 );
    Py_INCREF( tmp_tuple_element_42 );
    PyTuple_SET_ITEM( tmp_defaults_24, 0, tmp_tuple_element_42 );
    tmp_assign_source_70 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj( tmp_defaults_24 );
    assert( var__testTaskObj == NULL );
    var__testTaskObj = tmp_assign_source_70;

    tmp_called_name_27 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_called_name_27 == NULL ))
    {
        tmp_called_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_called_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 1185;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_71 = var__testTaskObj;

    CHECK_OBJECT( tmp_args_element_name_71 );
    frame_function->m_frame.f_lineno = 1185;
    {
        PyObject *call_args[] = { tmp_args_element_name_71 };
        tmp_assign_source_71 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_27, call_args );
    }

    if ( tmp_assign_source_71 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1185;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_t == NULL );
    var_t = tmp_assign_source_71;

    tmp_called_instance_118 = var_tm;

    CHECK_OBJECT( tmp_called_instance_118 );
    tmp_args_element_name_72 = var_t;

    CHECK_OBJECT( tmp_args_element_name_72 );
    tmp_args_element_name_73 = const_str_plain_testTaskObj;
    frame_function->m_frame.f_lineno = 1186;
    {
        PyObject *call_args[] = { tmp_args_element_name_72, tmp_args_element_name_73 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_118, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1186;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_119 = var_tm;

    CHECK_OBJECT( tmp_called_instance_119 );
    frame_function->m_frame.f_lineno = 1187;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_119, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1187;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_42 = var_l;

    CHECK_OBJECT( tmp_len_arg_42 );
    tmp_compare_left_57 = BUILTIN_LEN( tmp_len_arg_42 );
    assert( tmp_compare_left_57 != NULL );
    tmp_compare_right_57 = const_int_pos_1;
    tmp_cmp_Eq_54 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_57, tmp_compare_right_57 );
    if ( tmp_cmp_Eq_54 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_57 );

        exception_lineno = 1188;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_57 );
    if ( tmp_cmp_Eq_54 == 1 )
    {
        goto branch_no_59;
    }
    else
    {
        goto branch_yes_59;
    }
    branch_yes_59:;
    tmp_raise_type_58 = PyExc_AssertionError;
    exception_type = tmp_raise_type_58;
    Py_INCREF( tmp_raise_type_58 );
    exception_lineno = 1188;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_59:;
    tmp_called_instance_120 = var_tm;

    CHECK_OBJECT( tmp_called_instance_120 );
    frame_function->m_frame.f_lineno = 1189;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_120, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1189;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_43 = var_l;

    CHECK_OBJECT( tmp_len_arg_43 );
    tmp_compare_left_58 = BUILTIN_LEN( tmp_len_arg_43 );
    assert( tmp_compare_left_58 != NULL );
    tmp_compare_right_58 = const_int_pos_2;
    tmp_cmp_Eq_55 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_58, tmp_compare_right_58 );
    if ( tmp_cmp_Eq_55 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_58 );

        exception_lineno = 1190;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_58 );
    if ( tmp_cmp_Eq_55 == 1 )
    {
        goto branch_no_60;
    }
    else
    {
        goto branch_yes_60;
    }
    branch_yes_60:;
    tmp_raise_type_59 = PyExc_AssertionError;
    exception_type = tmp_raise_type_59;
    Py_INCREF( tmp_raise_type_59 );
    exception_lineno = 1190;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_60:;
    tmp_called_instance_121 = var_tm;

    CHECK_OBJECT( tmp_called_instance_121 );
    frame_function->m_frame.f_lineno = 1191;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_121, const_str_plain_remove, &PyTuple_GET_ITEM( const_tuple_str_plain_testTaskObj_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1191;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_122 = var_tm;

    CHECK_OBJECT( tmp_called_instance_122 );
    frame_function->m_frame.f_lineno = 1192;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_122, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1192;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_44 = var_l;

    CHECK_OBJECT( tmp_len_arg_44 );
    tmp_compare_left_59 = BUILTIN_LEN( tmp_len_arg_44 );
    assert( tmp_compare_left_59 != NULL );
    tmp_compare_right_59 = const_int_pos_2;
    tmp_cmp_Eq_56 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_59, tmp_compare_right_59 );
    if ( tmp_cmp_Eq_56 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_59 );

        exception_lineno = 1193;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_59 );
    if ( tmp_cmp_Eq_56 == 1 )
    {
        goto branch_no_61;
    }
    else
    {
        goto branch_yes_61;
    }
    branch_yes_61:;
    tmp_raise_type_60 = PyExc_AssertionError;
    exception_type = tmp_raise_type_60;
    Py_INCREF( tmp_raise_type_60 );
    exception_lineno = 1193;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_61:;
    Py_XDECREF( var__testTaskObj );
    var__testTaskObj = NULL;

    tmp_called_instance_123 = var_tm;

    CHECK_OBJECT( tmp_called_instance_123 );
    frame_function->m_frame.f_lineno = 1195;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_123, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1195;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_assign_source_72 = PyList_New( 0 );
    {
        PyObject *old = var_l;
        assert( old != NULL );
        var_l = tmp_assign_source_72;
        Py_DECREF( old );
    }

    tmp_defaults_25 = PyTuple_New( 1 );
    tmp_tuple_element_43 = var_l;

    CHECK_OBJECT( tmp_tuple_element_43 );
    Py_INCREF( tmp_tuple_element_43 );
    PyTuple_SET_ITEM( tmp_defaults_25, 0, tmp_tuple_element_43 );
    tmp_assign_source_73 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove( tmp_defaults_25 );
    assert( var__testTaskObjRemove == NULL );
    var__testTaskObjRemove = tmp_assign_source_73;

    tmp_called_name_28 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_called_name_28 == NULL ))
    {
        tmp_called_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_called_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 1202;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_74 = var__testTaskObjRemove;

    CHECK_OBJECT( tmp_args_element_name_74 );
    frame_function->m_frame.f_lineno = 1202;
    {
        PyObject *call_args[] = { tmp_args_element_name_74 };
        tmp_assign_source_74 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_28, call_args );
    }

    if ( tmp_assign_source_74 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1202;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_t;
        assert( old != NULL );
        var_t = tmp_assign_source_74;
        Py_DECREF( old );
    }

    tmp_called_instance_124 = var_tm;

    CHECK_OBJECT( tmp_called_instance_124 );
    tmp_args_element_name_75 = var_t;

    CHECK_OBJECT( tmp_args_element_name_75 );
    tmp_args_element_name_76 = const_str_plain_testTaskObjRemove;
    frame_function->m_frame.f_lineno = 1203;
    {
        PyObject *call_args[] = { tmp_args_element_name_75, tmp_args_element_name_76 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_124, const_str_plain_add, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1203;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_125 = var_tm;

    CHECK_OBJECT( tmp_called_instance_125 );
    frame_function->m_frame.f_lineno = 1204;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_125, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1204;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_45 = var_l;

    CHECK_OBJECT( tmp_len_arg_45 );
    tmp_compare_left_60 = BUILTIN_LEN( tmp_len_arg_45 );
    assert( tmp_compare_left_60 != NULL );
    tmp_compare_right_60 = const_int_pos_1;
    tmp_cmp_Eq_57 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_60, tmp_compare_right_60 );
    if ( tmp_cmp_Eq_57 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_60 );

        exception_lineno = 1205;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_60 );
    if ( tmp_cmp_Eq_57 == 1 )
    {
        goto branch_no_62;
    }
    else
    {
        goto branch_yes_62;
    }
    branch_yes_62:;
    tmp_raise_type_61 = PyExc_AssertionError;
    exception_type = tmp_raise_type_61;
    Py_INCREF( tmp_raise_type_61 );
    exception_lineno = 1205;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_62:;
    tmp_called_instance_126 = var_tm;

    CHECK_OBJECT( tmp_called_instance_126 );
    frame_function->m_frame.f_lineno = 1206;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_126, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1206;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_46 = var_l;

    CHECK_OBJECT( tmp_len_arg_46 );
    tmp_compare_left_61 = BUILTIN_LEN( tmp_len_arg_46 );
    assert( tmp_compare_left_61 != NULL );
    tmp_compare_right_61 = const_int_pos_2;
    tmp_cmp_Eq_58 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_61, tmp_compare_right_61 );
    if ( tmp_cmp_Eq_58 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_61 );

        exception_lineno = 1207;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_61 );
    if ( tmp_cmp_Eq_58 == 1 )
    {
        goto branch_no_63;
    }
    else
    {
        goto branch_yes_63;
    }
    branch_yes_63:;
    tmp_raise_type_62 = PyExc_AssertionError;
    exception_type = tmp_raise_type_62;
    Py_INCREF( tmp_raise_type_62 );
    exception_lineno = 1207;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_63:;
    tmp_called_instance_127 = var_t;

    CHECK_OBJECT( tmp_called_instance_127 );
    frame_function->m_frame.f_lineno = 1208;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_127, const_str_plain_remove );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1208;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_128 = var_tm;

    CHECK_OBJECT( tmp_called_instance_128 );
    frame_function->m_frame.f_lineno = 1209;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_128, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1209;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_47 = var_l;

    CHECK_OBJECT( tmp_len_arg_47 );
    tmp_compare_left_62 = BUILTIN_LEN( tmp_len_arg_47 );
    assert( tmp_compare_left_62 != NULL );
    tmp_compare_right_62 = const_int_pos_2;
    tmp_cmp_Eq_59 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_62, tmp_compare_right_62 );
    if ( tmp_cmp_Eq_59 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_62 );

        exception_lineno = 1210;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_62 );
    if ( tmp_cmp_Eq_59 == 1 )
    {
        goto branch_no_64;
    }
    else
    {
        goto branch_yes_64;
    }
    branch_yes_64:;
    tmp_raise_type_63 = PyExc_AssertionError;
    exception_type = tmp_raise_type_63;
    Py_INCREF( tmp_raise_type_63 );
    exception_lineno = 1210;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
    goto frame_exception_exit_1;
    branch_no_64:;
    CHECK_OBJECT( var_t );
    Py_DECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var__testTaskObjRemove );
    var__testTaskObjRemove = NULL;

    tmp_called_instance_129 = var_tm;

    CHECK_OBJECT( tmp_called_instance_129 );
    frame_function->m_frame.f_lineno = 1213;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_129, const_str_plain__checkMemLeaks );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1213;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    CHECK_OBJECT( var_l );
    Py_DECREF( var_l );
    var_l = NULL;

    tmp_called_instance_130 = var_tm;

    CHECK_OBJECT( tmp_called_instance_130 );
    frame_function->m_frame.f_lineno = 1250;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_130, const_str_plain_destroy );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1250;
        type_description = "ooooooooooooooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_tm, var_l, var__testDone, var__testRemoveByName, var__testDupNamedTasks, var__testCont, var__testContDone, var__testHasTaskNamed, var__testPri1, var__testPri2, var__testExtraArgs, var__testAppendTask, var__uponDeathFunc, var__testUponDeath, var__TaskOwner, var_to, var__testOwner, var_doLaterTests, var__testDoLater1, var__testDoLater2, var__monitorDoLater, var__testDoLaterPri1, var__testDoLaterPri2, var__monitorDoLaterPri, var__testDoLaterExtraArgs, var__monitorDoLaterExtraArgs, var__testDoLaterAppendTask, var__monitorDoLaterAppendTask, var__testUponDeathFunc, var__testDoLaterUponDeath, var__monitorDoLaterUponDeath, var__DoLaterOwner, var_doLaterOwner, var__testDoLaterOwner, var__monitorDoLaterOwner, var__testGetTasks, var__testGetDoLaters, var__testDupNameDoLaters, var__testDupNameDoLatersRemove, var_dl1, var_dl2, var__testGetTasksNamed, var__testRemoveTasksMatching, var__testTaskObj, var_t, var__testTaskObjRemove );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    CHECK_OBJECT( var_tm );
    Py_DECREF( var_tm );
    var_tm = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_dl1 );
    Py_DECREF( var_dl1 );
    var_dl1 = NULL;

    CHECK_OBJECT( (PyObject *)var_dl2 );
    Py_DECREF( var_dl2 );
    var_dl2 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_9 = exception_type;
    exception_keeper_value_9 = exception_value;
    exception_keeper_tb_9 = exception_tb;
    exception_keeper_lineno_9 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_tm );
    var_tm = NULL;

    Py_XDECREF( var_l );
    var_l = NULL;

    Py_XDECREF( var__testDone );
    var__testDone = NULL;

    Py_XDECREF( var__testRemoveByName );
    var__testRemoveByName = NULL;

    Py_XDECREF( var__testDupNamedTasks );
    var__testDupNamedTasks = NULL;

    Py_XDECREF( var__testCont );
    var__testCont = NULL;

    Py_XDECREF( var__testContDone );
    var__testContDone = NULL;

    Py_XDECREF( var__testHasTaskNamed );
    var__testHasTaskNamed = NULL;

    Py_XDECREF( var__testPri1 );
    var__testPri1 = NULL;

    Py_XDECREF( var__testPri2 );
    var__testPri2 = NULL;

    Py_XDECREF( var__testExtraArgs );
    var__testExtraArgs = NULL;

    Py_XDECREF( var__testAppendTask );
    var__testAppendTask = NULL;

    Py_XDECREF( var__uponDeathFunc );
    var__uponDeathFunc = NULL;

    Py_XDECREF( var__testUponDeath );
    var__testUponDeath = NULL;

    Py_XDECREF( var__TaskOwner );
    var__TaskOwner = NULL;

    Py_XDECREF( var_to );
    var_to = NULL;

    Py_XDECREF( var__testOwner );
    var__testOwner = NULL;

    Py_XDECREF( var_doLaterTests );
    var_doLaterTests = NULL;

    Py_XDECREF( var__testDoLater1 );
    var__testDoLater1 = NULL;

    Py_XDECREF( var__testDoLater2 );
    var__testDoLater2 = NULL;

    Py_XDECREF( var__monitorDoLater );
    var__monitorDoLater = NULL;

    Py_XDECREF( var__testDoLaterPri1 );
    var__testDoLaterPri1 = NULL;

    Py_XDECREF( var__testDoLaterPri2 );
    var__testDoLaterPri2 = NULL;

    Py_XDECREF( var__monitorDoLaterPri );
    var__monitorDoLaterPri = NULL;

    Py_XDECREF( var__testDoLaterExtraArgs );
    var__testDoLaterExtraArgs = NULL;

    Py_XDECREF( var__monitorDoLaterExtraArgs );
    var__monitorDoLaterExtraArgs = NULL;

    Py_XDECREF( var__testDoLaterAppendTask );
    var__testDoLaterAppendTask = NULL;

    Py_XDECREF( var__monitorDoLaterAppendTask );
    var__monitorDoLaterAppendTask = NULL;

    Py_XDECREF( var__testUponDeathFunc );
    var__testUponDeathFunc = NULL;

    Py_XDECREF( var__testDoLaterUponDeath );
    var__testDoLaterUponDeath = NULL;

    Py_XDECREF( var__monitorDoLaterUponDeath );
    var__monitorDoLaterUponDeath = NULL;

    Py_XDECREF( var__DoLaterOwner );
    var__DoLaterOwner = NULL;

    Py_XDECREF( var_doLaterOwner );
    var_doLaterOwner = NULL;

    Py_XDECREF( var__testDoLaterOwner );
    var__testDoLaterOwner = NULL;

    Py_XDECREF( var__monitorDoLaterOwner );
    var__monitorDoLaterOwner = NULL;

    Py_XDECREF( var__testGetTasks );
    var__testGetTasks = NULL;

    Py_XDECREF( var__testGetDoLaters );
    var__testGetDoLaters = NULL;

    Py_XDECREF( var__testDupNameDoLaters );
    var__testDupNameDoLaters = NULL;

    Py_XDECREF( var__testDupNameDoLatersRemove );
    var__testDupNameDoLatersRemove = NULL;

    Py_XDECREF( var_dl1 );
    var_dl1 = NULL;

    Py_XDECREF( var_dl2 );
    var_dl2 = NULL;

    Py_XDECREF( var__testGetTasksNamed );
    var__testGetTasksNamed = NULL;

    Py_XDECREF( var__testRemoveTasksMatching );
    var__testRemoveTasksMatching = NULL;

    Py_XDECREF( var__testTaskObj );
    var__testTaskObj = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    Py_XDECREF( var__testTaskObjRemove );
    var__testTaskObjRemove = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_9;
    exception_value = exception_keeper_value_9;
    exception_tb = exception_keeper_tb_9;
    exception_lineno = exception_keeper_lineno_9;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1ea7d4fc2654fedb2b66cb57aa54709c, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 777;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 777;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 778;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_67d72ea4a918b2129d3f98435dcb65cd, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 789;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b46508c12aab209175d0d732fde371d4, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_fbc82397480933af0120c9ef986ded6f, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 808;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 808;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 809;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_GtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_76f5520c3df4326fd3f341d21a27c157, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 822;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 822;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_len_arg_1 = par_l;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_pos_2;
    tmp_cmp_GtE_1 = RICH_COMPARE_BOOL_GE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_GtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 823;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_GtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_137d6f860c2949f6d61c047f69bd47e2, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 840;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e51415919b7d50e46577b8622cf2ec9b, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 851;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 851;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 852;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1d2f967c96ad8076cc0ec9af2d5bb030, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 854;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 854;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 855;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_arg2 = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e9004900ae0eb8708327b2ab1e90670b, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = PyList_New( 2 );
    tmp_list_element_1 = par_arg1;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_list_element_1 = par_arg2;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_1, 1, tmp_list_element_1 );
    frame_function->m_frame.f_lineno = 873;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 873;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done );

    if (unlikely( tmp_return_value == NULL ))
    {
        tmp_return_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_done );
    }

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "done" );
        exception_tb = NULL;

        exception_lineno = 874;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_arg1, par_arg2, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_arg2 = python_pars[ 1 ];
    PyObject *par_task = python_pars[ 2 ];
    PyObject *par_l = python_pars[ 3 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_892ec132c5506551417f702766d58fe6, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = PyList_New( 2 );
    tmp_list_element_1 = par_arg1;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_1, 0, tmp_list_element_1 );
    tmp_list_element_1 = par_arg2;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_1, 1, tmp_list_element_1 );
    frame_function->m_frame.f_lineno = 885;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_extend, call_args );
    }

    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 885;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 886;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_arg1, par_arg2, par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_arg2 );
    Py_DECREF( par_arg2 );
    par_arg2 = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7963539a5bd3966c06a5221f19ea23ad, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_l;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_name );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 897;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 897;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d679788b81855c7ebc4e9894c8aaa1cd, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_return_value = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done );

    if (unlikely( tmp_return_value == NULL ))
    {
        tmp_return_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_done );
    }

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "done" );
        exception_tb = NULL;

        exception_lineno = 899;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var__addTask = NULL;
    PyObject *var__clearTask = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_11eb635c2afc52a8139249187777a73c;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask(  );
    assert( var__addTask == NULL );
    var__addTask = tmp_assign_source_2;

    tmp_assign_source_3 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask(  );
    assert( var__clearTask == NULL );
    var__clearTask = tmp_assign_source_3;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var__addTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__addTask,
            var__addTask
        );

        assert( res == 0 );
    }

    if ( var__clearTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__clearTask,
            var__clearTask
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var__addTask );
    Py_DECREF( var__addTask );
    var__addTask = NULL;

    CHECK_OBJECT( (PyObject *)var__clearTask );
    Py_DECREF( var__clearTask );
    var__clearTask = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var__addTask );
    Py_DECREF( var__addTask );
    var__addTask = NULL;

    CHECK_OBJECT( (PyObject *)var__clearTask );
    Py_DECREF( var__clearTask );
    var__clearTask = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7ab2c37fdb059bac0f852c71d5c13938, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 911;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_addedTaskName, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 911;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8b092dd14ac9b4a35adb11385b6a62aa, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 913;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_clearedTaskName, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 913;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_60fcb9ff8444cc51b39ea5424bd7a9e5, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_return_value = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done );

    if (unlikely( tmp_return_value == NULL ))
    {
        tmp_return_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_done );
    }

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "done" );
        exception_tb = NULL;

        exception_lineno = 917;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a72779e213e20817d7aabe3d88118889, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 933;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 933;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3d220405f6fe0242418c371480db0f4c, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 935;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 935;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterTests = python_pars[ 3 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_aab3cda59294e744f97b45d1bcd1e9fb, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 937;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_03;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 937;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_compare_left_2 = par_l;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = LIST_COPY( const_list_int_pos_1_int_pos_2_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 938;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 938;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 939;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 940;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 941;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_6dd5ead85f2dceefcd3c0ad036f415b5, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 956;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 956;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_2f61258a47b5ec321de015af81d5c414, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 958;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_2_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 958;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2 );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2 );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterTests = python_pars[ 3 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_4c7ea89a803f23bfaa8c7f3830cfe0de, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 960;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_02;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 960;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_compare_left_2 = par_l;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = LIST_COPY( const_list_int_pos_1_int_pos_2_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 961;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 961;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 962;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 963;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 964;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b4c717e1db160798c92c590350bfd5f4, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_arg1;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 979;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 979;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_arg1, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterTests = python_pars[ 3 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_230a109e65a6d2e464a74c64fc9f1a4c, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 981;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_02;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 981;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_compare_left_2 = par_l;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = LIST_COPY( const_list_int_pos_3_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 982;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 982;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 983;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 983;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 983;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 984;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 985;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bb572334680fd07cd8affd7546c61848, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 998;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_str_plain_testDoLaterAppendTask;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 998;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 998;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_arg1;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 999;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 999;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_arg1, par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterTests = python_pars[ 3 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_6fcd83d5f03e1a39b59b835c61383bc9, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1001;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_02;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1001;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_compare_left_2 = par_l;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = LIST_COPY( const_list_int_pos_4_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 1002;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1002;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1003;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1003;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1003;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1004;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1005;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_e48d719b4002d925a003fb3b662eb651, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1019;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_str_plain_testDoLaterUponDeath;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1019;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1019;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oo";
    goto frame_exception_exit_1;
    branch_no_1:;
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 1020;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_int_pos_10_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1020;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_arg1 = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_41cc36c7ef3623473e92ac27130c8e1a, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_return_value = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done );

    if (unlikely( tmp_return_value == NULL ))
    {
        tmp_return_value = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_done );
    }

    if ( tmp_return_value == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "done" );
        exception_tb = NULL;

        exception_lineno = 1022;
        type_description = "oo";
        goto frame_exception_exit_1;
    }

    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_arg1, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_arg1 );
    Py_DECREF( par_arg1 );
    par_arg1 = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterTests = python_pars[ 3 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b2248f0954b89bf165de459ebd31caa7, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1024;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_02;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1024;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_compare_left_2 = par_l;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = LIST_COPY( const_list_int_pos_10_list );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_right_2 );

        exception_lineno = 1025;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1025;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "oooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1026;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1026;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1026;
        type_description = "oooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1027;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1028;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var__addTask = NULL;
    PyObject *var__clearTask = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_11eb635c2afc52a8139249187777a73c;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask(  );
    assert( var__addTask == NULL );
    var__addTask = tmp_assign_source_2;

    tmp_assign_source_3 = MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask(  );
    assert( var__clearTask == NULL );
    var__clearTask = tmp_assign_source_3;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var__addTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__addTask,
            var__addTask
        );

        assert( res == 0 );
    }

    if ( var__clearTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain__clearTask,
            var__clearTask
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var__addTask );
    Py_DECREF( var__addTask );
    var__addTask = NULL;

    CHECK_OBJECT( (PyObject *)var__clearTask );
    Py_DECREF( var__clearTask );
    var__clearTask = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var__addTask );
    Py_DECREF( var__addTask );
    var__addTask = NULL;

    CHECK_OBJECT( (PyObject *)var__clearTask );
    Py_DECREF( var__clearTask );
    var__clearTask = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_4aee6f72bccb9d5d2abd2a1ab86f3856, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1043;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_addedTaskName, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1043;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assattr_name_1;
    PyObject *tmp_assattr_target_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cee04e6a5e29a5435e6448a27a6c66f4, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_assattr_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_name );
    if ( tmp_assattr_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1045;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assattr_target_1 = par_self;

    CHECK_OBJECT( tmp_assattr_target_1 );
    tmp_result = SET_ATTRIBUTE( tmp_assattr_target_1, const_str_plain_clearedTaskName, tmp_assattr_name_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_assattr_name_1 );

        exception_lineno = 1045;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_assattr_name_1 );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_l = python_pars[ 0 ];
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_tm = python_pars[ 1 ];
    PyObject *par_l = python_pars[ 2 ];
    PyObject *par_doLaterOwner = python_pars[ 3 ];
    PyObject *par_doLaterTests = python_pars[ 4 ];
    PyObject *tmp_inplace_assign_subscr_1__target = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscript_1;
    int tmp_ass_subscript_res_1;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_assign_source_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_Gt_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_getattr_attr_1;
    PyObject *tmp_getattr_attr_2;
    PyObject *tmp_getattr_default_1;
    PyObject *tmp_getattr_default_2;
    PyObject *tmp_getattr_target_1;
    PyObject *tmp_getattr_target_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_raise_type_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d1888f560c6d4ffd7ce4ab5a0331dd2a, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_compare_left_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_time );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1052;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_float_0_02;
    tmp_cmp_Gt_1 = RICH_COMPARE_BOOL_GT( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Gt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 1052;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Gt_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_getattr_target_1 = par_doLaterOwner;

    CHECK_OBJECT( tmp_getattr_target_1 );
    tmp_getattr_attr_1 = const_str_plain_addedTaskName;
    tmp_getattr_default_1 = Py_None;
    tmp_compare_left_2 = BUILTIN_GETATTR( tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1 );
    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1053;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = const_str_plain_testDoLaterOwner;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1053;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_2;
    }
    else
    {
        goto branch_yes_2;
    }
    branch_yes_2:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1053;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooo";
    goto frame_exception_exit_1;
    branch_no_2:;
    tmp_getattr_target_2 = par_doLaterOwner;

    CHECK_OBJECT( tmp_getattr_target_2 );
    tmp_getattr_attr_2 = const_str_plain_clearedTaskName;
    tmp_getattr_default_2 = Py_None;
    tmp_compare_left_3 = BUILTIN_GETATTR( tmp_getattr_target_2, tmp_getattr_attr_2, tmp_getattr_default_2 );
    if ( tmp_compare_left_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1054;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_3 = const_str_plain_testDoLaterOwner;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_3 );

        exception_lineno = 1054;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_3 );
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_raise_type_2 = PyExc_AssertionError;
    exception_type = tmp_raise_type_2;
    Py_INCREF( tmp_raise_type_2 );
    exception_lineno = 1054;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooo";
    goto frame_exception_exit_1;
    branch_no_3:;
    tmp_assign_source_1 = par_doLaterTests;

    CHECK_OBJECT( tmp_assign_source_1 );
    assert( tmp_inplace_assign_subscr_1__target == NULL );
    Py_INCREF( tmp_assign_source_1 );
    tmp_inplace_assign_subscr_1__target = tmp_assign_source_1;

    // Tried code:
    tmp_subscribed_name_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_left_name_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_ass_subvalue_1 = BINARY_OPERATION( PyNumber_InPlaceSubtract, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_ass_subvalue_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_ass_subscribed_1 = tmp_inplace_assign_subscr_1__target;

    CHECK_OBJECT( tmp_ass_subscribed_1 );
    tmp_ass_subscript_1 = const_int_0;
    tmp_ass_subscript_res_1 = SET_SUBSCRIPT_CONST( tmp_ass_subscribed_1, tmp_ass_subscript_1, 0, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subvalue_1 );
    if ( tmp_ass_subscript_res_1 == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1055;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    CHECK_OBJECT( (PyObject *)tmp_inplace_assign_subscr_1__target );
    Py_DECREF( tmp_inplace_assign_subscr_1__target );
    tmp_inplace_assign_subscr_1__target = NULL;

    tmp_source_name_2 = par_task;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1056;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_source_name_3 = par_task;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1057;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_tm, par_l, par_doLaterOwner, par_doLaterTests );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterOwner );
    Py_DECREF( par_doLaterOwner );
    par_doLaterOwner = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_tm );
    Py_DECREF( par_tm );
    par_tm = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterOwner );
    Py_DECREF( par_doLaterOwner );
    par_doLaterOwner = NULL;

    CHECK_OBJECT( (PyObject *)par_doLaterTests );
    Py_DECREF( par_doLaterTests );
    par_doLaterTests = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_eaf5b156be7cffba63794344440c3daf, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1078;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto function_return_exit;

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_465c20828fb245d1da49cbac215c5a05, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1143;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7e5a4b05410fd288aa4d09eb027f088e, module_direct$task$Task, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1158;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ed58f74a2f8d002a5e08521a7ef83afd, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 1183;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1183;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1184;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_task = python_pars[ 0 ];
    PyObject *par_l = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_5a51d4d6a7824a4da72cbd4babb35c6e, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_l;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 1200;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_append, &PyTuple_GET_ITEM( const_tuple_none_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1200;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_cont );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1201;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_task, par_l );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    CHECK_OBJECT( (PyObject *)par_l );
    Py_DECREF( par_l );
    par_l = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$function_4_checkLeak( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *var_sys = NULL;
    PyObject *var_gc = NULL;
    PyObject *var_DirectObject = NULL;
    PyObject *var_TestClass = NULL;
    PyObject *var_obj = NULL;
    PyObject *var_startRefCount = NULL;
    PyObject *var_t = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_Eq_1;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_key_name_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_print_value;
    PyObject *tmp_raise_type_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_tuple_element_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_name_name_1 = const_str_plain_sys;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    assert( tmp_assign_source_1 != NULL );
    assert( var_sys == NULL );
    var_sys = tmp_assign_source_1;

    tmp_name_name_2 = const_str_plain_gc;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = Py_None;
    tmp_assign_source_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    assert( tmp_assign_source_2 != NULL );
    assert( var_gc == NULL );
    var_gc = tmp_assign_source_2;

    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_76f669d460a509794777b874913fc224, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = var_gc;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 1257;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_enable );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1257;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_name_name_3 = const_str_digest_3d04e07393c6560e489a0567631d62c2;
    tmp_globals_name_3 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_3 = Py_None;
    tmp_fromlist_name_3 = const_tuple_str_plain_DirectObject_tuple;
    frame_function->m_frame.f_lineno = 1258;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1258;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_DirectObject );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1258;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_DirectObject == NULL );
    var_DirectObject = tmp_assign_source_3;

    tmp_assign_source_4 = PyTuple_New( 1 );
    tmp_tuple_element_1 = var_DirectObject;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_assign_source_4, 0, tmp_tuple_element_1 );
    assert( tmp_class_creation_1__bases == NULL );
    tmp_class_creation_1__bases = tmp_assign_source_4;

    tmp_assign_source_5 = impl_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass( NULL );
    assert( tmp_assign_source_5 != NULL );
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_5;

    // Tried code:
    tmp_compare_left_1 = const_str_plain___metaclass__;
    tmp_compare_right_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_6 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_bases_name_1 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_bases_name_1 );
    tmp_assign_source_6 = SELECT_METACLASS( tmp_bases_name_1, GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_6;

    tmp_called_name_1 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = const_str_plain_TestClass;
    tmp_args_element_name_2 = tmp_class_creation_1__bases;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 1259;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_7 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1259;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_7;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    tmp_assign_source_8 = tmp_class_creation_1__class;

    CHECK_OBJECT( tmp_assign_source_8 );
    assert( var_TestClass == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_TestClass = tmp_assign_source_8;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__bases );
    Py_DECREF( tmp_class_creation_1__bases );
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_called_name_2 = var_TestClass;

    CHECK_OBJECT( tmp_called_name_2 );
    frame_function->m_frame.f_lineno = 1262;
    tmp_assign_source_9 = CALL_FUNCTION_NO_ARGS( tmp_called_name_2 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1262;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_obj == NULL );
    var_obj = tmp_assign_source_9;

    tmp_called_instance_2 = var_sys;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_4 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 1263;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_10 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1263;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_startRefCount == NULL );
    var_startRefCount = tmp_assign_source_10;

    tmp_left_name_1 = const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
    tmp_called_instance_3 = var_sys;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_5 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 1264;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_right_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1264;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1264;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_148d47d5c98a982616178302cd36806d;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1265;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_1 = var_obj;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addTask );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1266;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_2 = var_obj;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_args_element_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_doTask );
    if ( tmp_args_element_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 1266;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_7 = const_str_plain_test;
    frame_function->m_frame.f_lineno = 1266;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_11 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_6 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1266;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_t == NULL );
    var_t = tmp_assign_source_11;

    tmp_left_name_2 = const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
    tmp_called_instance_4 = var_sys;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_8 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_function->m_frame.f_lineno = 1267;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_right_name_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1267;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1267;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_3 = const_str_digest_32e1b3aeccfbfbe3d7709c786a996e40;
    tmp_called_instance_5 = var_t;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 1268;
    tmp_right_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getRefCount );
    if ( tmp_right_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1268;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1268;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_c547fa892b0cc5cd9e6d71e528dd8f39;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1269;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1269;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_6 = var_obj;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 1270;
    tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_removeTask, &PyTuple_GET_ITEM( const_tuple_str_plain_test_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_left_name_4 = const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
    tmp_called_instance_7 = var_sys;

    CHECK_OBJECT( tmp_called_instance_7 );
    tmp_args_element_name_9 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 1271;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_right_name_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_7, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_right_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = const_str_digest_32e1b3aeccfbfbe3d7709c786a996e40;
    tmp_called_instance_8 = var_t;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 1272;
    tmp_right_name_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getRefCount );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_86a25986da173b225b30ee3209499f63;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_9 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_taskMgr );

    if (unlikely( tmp_called_instance_9 == NULL ))
    {
        tmp_called_instance_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_taskMgr );
    }

    if ( tmp_called_instance_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "taskMgr" );
        exception_tb = NULL;

        exception_lineno = 1274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 1274;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_10 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_taskMgr );

    if (unlikely( tmp_called_instance_10 == NULL ))
    {
        tmp_called_instance_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_taskMgr );
    }

    if ( tmp_called_instance_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "taskMgr" );
        exception_tb = NULL;

        exception_lineno = 1275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 1275;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_11 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_taskMgr );

    if (unlikely( tmp_called_instance_11 == NULL ))
    {
        tmp_called_instance_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_taskMgr );
    }

    if ( tmp_called_instance_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "taskMgr" );
        exception_tb = NULL;

        exception_lineno = 1276;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 1276;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_step );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1276;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_left_name_6 = const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
    tmp_called_instance_12 = var_sys;

    CHECK_OBJECT( tmp_called_instance_12 );
    tmp_args_element_name_10 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 1277;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_right_name_6 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_12, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_right_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1277;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1277;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1277;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1277;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = const_str_digest_32e1b3aeccfbfbe3d7709c786a996e40;
    tmp_called_instance_13 = var_t;

    CHECK_OBJECT( tmp_called_instance_13 );
    frame_function->m_frame.f_lineno = 1278;
    tmp_right_name_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_13, const_str_plain_getRefCount );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1278;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_7, tmp_right_name_7 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1278;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1278;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1278;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_20c100e7e679deb5eb4415251fd9db0b;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1279;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_XDECREF( var_t );
    var_t = NULL;

    tmp_left_name_8 = const_str_digest_db9a7d7cbb9589c3bc938d7b858e4be5;
    tmp_called_instance_14 = var_sys;

    CHECK_OBJECT( tmp_called_instance_14 );
    tmp_args_element_name_11 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_function->m_frame.f_lineno = 1281;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_right_name_8 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_14, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1281;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_8, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1281;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 1281;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1281;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_15 = var_sys;

    CHECK_OBJECT( tmp_called_instance_15 );
    tmp_args_element_name_12 = var_obj;

    CHECK_OBJECT( tmp_args_element_name_12 );
    frame_function->m_frame.f_lineno = 1282;
    {
        PyObject *call_args[] = { tmp_args_element_name_12 };
        tmp_compare_left_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_15, const_str_plain_getrefcount, call_args );
    }

    if ( tmp_compare_left_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1282;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_2 = var_startRefCount;

    CHECK_OBJECT( tmp_compare_right_2 );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_2 );

        exception_lineno = 1282;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_2 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    tmp_raise_type_1 = PyExc_AssertionError;
    exception_type = tmp_raise_type_1;
    Py_INCREF( tmp_raise_type_1 );
    exception_lineno = 1282;
    RAISE_EXCEPTION_WITH_TYPE( &exception_type, &exception_value, &exception_tb );
    type_description = "ooooooo";
    goto frame_exception_exit_1;
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,var_sys, var_gc, var_DirectObject, var_TestClass, var_obj, var_startRefCount, var_t );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var_sys );
    Py_DECREF( var_sys );
    var_sys = NULL;

    CHECK_OBJECT( (PyObject *)var_gc );
    Py_DECREF( var_gc );
    var_gc = NULL;

    CHECK_OBJECT( (PyObject *)var_DirectObject );
    Py_DECREF( var_DirectObject );
    var_DirectObject = NULL;

    CHECK_OBJECT( (PyObject *)var_TestClass );
    Py_DECREF( var_TestClass );
    var_TestClass = NULL;

    CHECK_OBJECT( (PyObject *)var_obj );
    Py_DECREF( var_obj );
    var_obj = NULL;

    CHECK_OBJECT( (PyObject *)var_startRefCount );
    Py_DECREF( var_startRefCount );
    var_startRefCount = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)var_sys );
    Py_DECREF( var_sys );
    var_sys = NULL;

    CHECK_OBJECT( (PyObject *)var_gc );
    Py_DECREF( var_gc );
    var_gc = NULL;

    Py_XDECREF( var_DirectObject );
    var_DirectObject = NULL;

    Py_XDECREF( var_TestClass );
    var_TestClass = NULL;

    Py_XDECREF( var_obj );
    var_obj = NULL;

    Py_XDECREF( var_startRefCount );
    var_startRefCount = NULL;

    Py_XDECREF( var_t );
    var_t = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


NUITKA_LOCAL_MODULE PyObject *impl_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass( PyObject **python_pars )
{
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
    assert(!had_error); // Do not enter inlined functions with error set.
#endif

    // Local variable declarations.
    PyObject *var___module__ = NULL;
    PyObject *var_doTask = NULL;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_return_value;
    tmp_return_value = NULL;

    // Actual function code.
    tmp_assign_source_1 = const_str_digest_11eb635c2afc52a8139249187777a73c;
    assert( var___module__ == NULL );
    Py_INCREF( tmp_assign_source_1 );
    var___module__ = tmp_assign_source_1;

    tmp_assign_source_2 = MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask(  );
    assert( var_doTask == NULL );
    var_doTask = tmp_assign_source_2;

    // Tried code:
    tmp_return_value = PyDict_New();
    if ( var___module__ )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain___module__,
            var___module__
        );

        assert( res == 0 );
    }

    if ( var_doTask )
    {
        int res = PyDict_SetItem(
            tmp_return_value,
            const_str_plain_doTask,
            var_doTask
        );

        assert( res == 0 );
    }

    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var_doTask );
    Py_DECREF( var_doTask );
    var_doTask = NULL;

    goto function_return_exit;
    // End of try:
    CHECK_OBJECT( (PyObject *)var___module__ );
    Py_DECREF( var___module__ );
    var___module__ = NULL;

    CHECK_OBJECT( (PyObject *)var_doTask );
    Py_DECREF( var_doTask );
    var_doTask = NULL;


    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass );
    return NULL;

    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_task = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_861daf0b7437317856d7e310c7f2eda7, module_direct$task$Task, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = par_task;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_return_value = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_done );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 1261;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_task );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_task );
    Py_DECREF( par_task );
    par_task = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_10_setupTaskChain,
        const_str_plain_setupTaskChain,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b0511af086dd0631243d38f48437a299,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_339421c46c1eca739ff0b1eb64748494,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_11_hasTaskNamed,
        const_str_plain_hasTaskNamed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_860dbd981425fc7d6911219b7968a371,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_d7a179d50b60b4930c53f672c217befd,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_12_getTasksNamed,
        const_str_plain_getTasksNamed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_52b4ef6bb6cf369ffc641db2e5bed903,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_dc372ef8fb63a2f7ba56dd37d0d490c8,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_13_getTasksMatching,
        const_str_plain_getTasksMatching,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_088bf2142fffa6737970b898cd57c2ef,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_17d25158b9df61b35e5a5db332529ea5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_14_getAllTasks,
        const_str_plain_getAllTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_95ca09c6dabb993508688977ed1f28f8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_20b8e052796f453b6b98b57ee46dd337,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_15_getTasks,
        const_str_plain_getTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f012b734e998e4843f1c83a41b919e26,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_053c33621531947f586017f14d07df3d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_16_getDoLaters,
        const_str_plain_getDoLaters,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_160465e968dea0bb99ee34e50350b838,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_884d50a542657f8d9c97ec0b2197090f,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_17___makeTaskList,
        const_str_plain___makeTaskList,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_783b5de3b90c55d3d1dec390be52f8c3,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_18_doMethodLater,
        const_str_plain_doMethodLater,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_20362686021c7e20ed2fb06d919d0022,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_49566355c2bc2c37328e332e8eb3cbca,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_19_add( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_19_add,
        const_str_plain_add,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_26ff3b2c3e3551d25329e13e5138e1cb,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_c6e478a3e2e77af3f673a67ea513491a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_1___init__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_40a5f03b51982b2c81249b0ebbb114e8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_20___setupTask,
        const_str_plain___setupTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_189ada8fa1f5a86a1eee23463063c5a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_21_remove(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_21_remove,
        const_str_plain_remove,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_34fde79ef14e6d7b87a91b80e98450eb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_8955d2e335f253b150c2e20333ed3782,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_22_removeTasksMatching,
        const_str_plain_removeTasksMatching,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_259c61b4f9811ad8ccc96af43b96bd59,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_02cb46f2b0d2122337d6d7767f333fbf,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_23_step(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_23_step,
        const_str_plain_step,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_12aa142535b85eafe922a23f44924443,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_e223ebbecbbe1fc3d462b76aa6de6906,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_24_run,
        const_str_plain_run,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_893e0b32b6121f59fe207ad6d789310b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_7e047f0e10d78432228c9d9cbabb1012,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc( PyObject *defaults, struct Nuitka_CellObject *closure_self )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_24_run$$$function_1__profileFunc,
        const_str_plain__profileFunc,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_35ffccfa398837ded2bd5733c8d924d6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        1
    );

result->m_closure[0] = closure_self;
Py_INCREF( result->m_closure[0] );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_25__unpackIOError,
        const_str_plain__unpackIOError,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7cac45d21cdc2606c699c8d89e878305,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_26_stop(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_26_stop,
        const_str_plain_stop,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bfc43a007ad8797741d50f7fe2c022f5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_27___tryReplaceTaskMethod,
        const_str_plain___tryReplaceTaskMethod,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_15701462c26ef8d6ea9ee9534de654cd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_28_replaceMethod,
        const_str_plain_replaceMethod,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e702ecd4827fa652e6590e8682d95714,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_29_popupControls,
        const_str_plain_popupControls,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_437f87a7b8a2bfcc26a548c69f7a50ba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_2_finalInit,
        const_str_plain_finalInit,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_100b97301f56e3452f5e62ef4be52d02,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_30_getProfileSession,
        const_str_plain_getProfileSession,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_03b873bf40115ff2336d78b244fb9290,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_31_profileFrames,
        const_str_plain_profileFrames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_26392af6f6494f1c3c610fcf382e43f2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_32__doProfiledFrames,
        const_str_plain__doProfiledFrames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9be619cf3323295ce5c2d4d8e9c31008,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_33_getProfileFrames,
        const_str_plain_getProfileFrames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c3612d9631208f6153f2c2d841b34ccf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_34_getProfileFramesSV,
        const_str_plain_getProfileFramesSV,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2bc704666bbeaa4896b3f93bd0374366,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_35_setProfileFrames,
        const_str_plain_setProfileFrames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9e313032971706852e78187240f68f33,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_36_getProfileTasks,
        const_str_plain_getProfileTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_948d539c21e35b6bfc38f19eca691423,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_37_getProfileTasksSV,
        const_str_plain_getProfileTasksSV,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d36ce0e5dd46338a23c8346264516bfd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_38_setProfileTasks,
        const_str_plain_setProfileTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4f491396b898906b362b2120438c8d24,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_39_logTaskProfiles,
        const_str_plain_logTaskProfiles,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e6ca53e3331ac817da7097ab320f1107,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_3_destroy(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_3_destroy,
        const_str_plain_destroy,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_57a043910180f24d10c601e798c7cb9d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_40_flushTaskProfiles,
        const_str_plain_flushTaskProfiles,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_37970f8793037a4ddab592f241f4401c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_41__setProfileTask,
        const_str_plain__setProfileTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d9d7300b276c32d2aec3e898ec71f6a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_42__profileTask,
        const_str_plain__profileTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0fc3126900c7a9fcc9df582b4f7915e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_43__hasProfiledDesignatedTask,
        const_str_plain__hasProfiledDesignatedTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_55412ff8103be46f9405ae1c765f63e0,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_44__getLastTaskProfileSession,
        const_str_plain__getLastTaskProfileSession,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ad19eab5874f533bb4eb6b9c6695ecee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_45__getRandomTask,
        const_str_plain__getRandomTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d89537e80c1f8aecb4da5c734ce0930b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_46___repr__(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_46___repr__,
        const_str_plain___repr__,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_95ee551f0efc18daaf624e3b714b82c1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_47_doYield(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_47_doYield,
        const_str_plain_doYield,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0ad31bf2742231db2b8a89ff59d1b076,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_48__startTrackingMemLeaks,
        const_str_plain__startTrackingMemLeaks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3ae9f244b506bb49e08c0f1d5ccebab7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_49__stopTrackingMemLeaks,
        const_str_plain__stopTrackingMemLeaks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_32f1d0deba85ca3786afaeedb484ac28,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_4_setClock(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_4_setClock,
        const_str_plain_setClock,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_792970ddc7a8d0bdaa6eddaf7d3146a8,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_50__checkMemLeaks,
        const_str_plain__checkMemLeaks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_49f6beb29b76ae66b646db967d65099b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests,
        const_str_plain__runTests,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bc19b89aaa8ec43cf5aebdc7db613c7d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_1__addTask,
        const_str_plain__addTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7ab2c37fdb059bac0f852c71d5c13938,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_1__TaskOwner$$$function_2__clearTask,
        const_str_plain__clearTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8b092dd14ac9b4a35adb11385b6a62aa,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_1__addTask,
        const_str_plain__addTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4aee6f72bccb9d5d2abd2a1ab86f3856,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$class_2__DoLaterOwner$$$function_2__clearTask,
        const_str_plain__clearTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cee04e6a5e29a5435e6448a27a6c66f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_10__testAppendTask,
        const_str_plain__testAppendTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_892ec132c5506551417f702766d58fe6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_11__uponDeathFunc,
        const_str_plain__uponDeathFunc,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7963539a5bd3966c06a5221f19ea23ad,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_12__testUponDeath,
        const_str_plain__testUponDeath,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d679788b81855c7ebc4e9894c8aaa1cd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_13__testOwner,
        const_str_plain__testOwner,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_60fcb9ff8444cc51b39ea5424bd7a9e5,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_14__testDoLater1,
        const_str_plain__testDoLater1,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a72779e213e20817d7aabe3d88118889,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_15__testDoLater2,
        const_str_plain__testDoLater2,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3d220405f6fe0242418c371480db0f4c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_16__monitorDoLater,
        const_str_plain__monitorDoLater,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aab3cda59294e744f97b45d1bcd1e9fb,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_17__testDoLaterPri1,
        const_str_plain__testDoLaterPri1,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6dd5ead85f2dceefcd3c0ad036f415b5,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_18__testDoLaterPri2,
        const_str_plain__testDoLaterPri2,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2f61258a47b5ec321de015af81d5c414,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_19__monitorDoLaterPri,
        const_str_plain__monitorDoLaterPri,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_4c7ea89a803f23bfaa8c7f3830cfe0de,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_1__testDone,
        const_str_plain__testDone,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1ea7d4fc2654fedb2b66cb57aa54709c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_20__testDoLaterExtraArgs,
        const_str_plain__testDoLaterExtraArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b4c717e1db160798c92c590350bfd5f4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_21__monitorDoLaterExtraArgs,
        const_str_plain__monitorDoLaterExtraArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_230a109e65a6d2e464a74c64fc9f1a4c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_22__testDoLaterAppendTask,
        const_str_plain__testDoLaterAppendTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bb572334680fd07cd8affd7546c61848,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_23__monitorDoLaterAppendTask,
        const_str_plain__monitorDoLaterAppendTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6fcd83d5f03e1a39b59b835c61383bc9,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_24__testUponDeathFunc,
        const_str_plain__testUponDeathFunc,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e48d719b4002d925a003fb3b662eb651,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_25__testDoLaterUponDeath,
        const_str_plain__testDoLaterUponDeath,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_41cc36c7ef3623473e92ac27130c8e1a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_26__monitorDoLaterUponDeath,
        const_str_plain__monitorDoLaterUponDeath,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b2248f0954b89bf165de459ebd31caa7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_27__testDoLaterOwner,
        const_str_plain__testDoLaterOwner,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_aaa813e18a939b7e39a24b6807b60fbe,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_28__monitorDoLaterOwner,
        const_str_plain__monitorDoLaterOwner,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d1888f560c6d4ffd7ce4ab5a0331dd2a,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_29__testGetTasks,
        const_str_plain__testGetTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_eaf5b156be7cffba63794344440c3daf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_2__testRemoveByName,
        const_str_plain__testRemoveByName,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_67d72ea4a918b2129d3f98435dcb65cd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_30__testGetDoLaters,
        const_str_plain__testGetDoLaters,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_04264c5692dbff7b77dfac19dc287f42,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_31__testDupNameDoLaters,
        const_str_plain__testDupNameDoLaters,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_be4acd18b3e5013ee6352e8ca2cf5dcc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_32__testDupNameDoLatersRemove,
        const_str_plain__testDupNameDoLatersRemove,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_2605fcb73ceb206da13b1a960eb162fb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_33__testGetTasksNamed,
        const_str_plain__testGetTasksNamed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_465c20828fb245d1da49cbac215c5a05,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_34__testRemoveTasksMatching,
        const_str_plain__testRemoveTasksMatching,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7e5a4b05410fd288aa4d09eb027f088e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_35__testTaskObj,
        const_str_plain__testTaskObj,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ed58f74a2f8d002a5e08521a7ef83afd,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_36__testTaskObjRemove,
        const_str_plain__testTaskObjRemove,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5a51d4d6a7824a4da72cbd4babb35c6e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_3__testDupNamedTasks,
        const_str_plain__testDupNamedTasks,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b46508c12aab209175d0d732fde371d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_4__testCont,
        const_str_plain__testCont,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fbc82397480933af0120c9ef986ded6f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_5__testContDone,
        const_str_plain__testContDone,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_76f5520c3df4326fd3f341d21a27c157,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_6__testHasTaskNamed,
        const_str_plain__testHasTaskNamed,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_137d6f860c2949f6d61c047f69bd47e2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_7__testPri1,
        const_str_plain__testPri1,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e51415919b7d50e46577b8622cf2ec9b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_8__testPri2,
        const_str_plain__testPri2,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1d2f967c96ad8076cc0ec9af2d5bb030,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_51__runTests$$$function_9__testExtraArgs,
        const_str_plain__testExtraArgs,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_e9004900ae0eb8708327b2ab1e90670b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_5_lambda(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_5_lambda,
        const_str_angle_lambda,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8c34676ca982b726e4c254dfc7ce4764,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_6_invokeDefaultHandler,
        const_str_plain_invokeDefaultHandler,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_c2379bdea82fc3b87246bcfc906c98bf,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_7_keyboardInterruptHandler,
        const_str_plain_keyboardInterruptHandler,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_65bae77f21e88e99debd37895a7b8890,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_8_getCurrentTask,
        const_str_plain_getCurrentTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f80fe5d8c84d87c6fbd950532e6b3f57,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_162533328c73194d8dad01ad17ef1ee5,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$class_1_TaskManager$$$function_9_hasTaskChain,
        const_str_plain_hasTaskChain,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_02957f44bd44983c583328d986a2cd95,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_835923a846bcd1d3fbfc6194aef55753,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_1_print_exc_plus(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$function_1_print_exc_plus,
        const_str_plain_print_exc_plus,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_56381d496ef85badf723bb2a79ef166d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        const_str_digest_fdd30d29d49df04a06d4a80ef85c53fc,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_2_sequence(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$function_2_sequence,
        const_str_plain_sequence,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7ae96314f7fe1f82a8f9a5e87073157e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_3_loop(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$function_3_loop,
        const_str_plain_loop,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a8ee911f00c862b982565e929f2a6c58,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$function_4_checkLeak,
        const_str_plain_checkLeak,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_76f669d460a509794777b874913fc224,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$task$Task$$$function_4_checkLeak$$$class_1_TestClass$$$function_1_doTask,
        const_str_plain_doTask,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_861daf0b7437317856d7e310c7f2eda7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$task$Task,
        Py_None,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_direct$task$Task =
{
    PyModuleDef_HEAD_INIT,
    "direct.task.Task",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

#if PYTHON_VERSION >= 300
extern PyObject *metapath_based_loader;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( direct$task$Task )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_direct$task$Task );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("direct.task.Task: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("direct.task.Task: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initdirect$task$Task" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_direct$task$Task = Py_InitModule4(
        "direct.task.Task",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No __doc__ is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    module_direct$task$Task = PyModule_Create( &mdef_direct$task$Task );
#endif

    moduledict_direct$task$Task = (PyDictObject *)((PyModuleObject *)module_direct$task$Task)->md_dict;

    CHECK_OBJECT( module_direct$task$Task );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_11eb635c2afc52a8139249187777a73c, module_direct$task$Task );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    PyObject *module_dict = PyModule_GetDict( module_direct$task$Task );

    if ( PyDict_GetItem( module_dict, const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

#ifndef __NUITKA_NO_ASSERT__
        int res =
#endif
            PyDict_SetItem( module_dict, const_str_plain___builtins__, value );

        assert( res == 0 );
    }

#if PYTHON_VERSION >= 330
    PyDict_SetItem( module_dict, const_str_plain___loader__, metapath_based_loader );
#endif

    // Temp variables if any
    PyObject *tmp_class_creation_1__class_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__class = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_ass_subscribed_1;
    PyObject *tmp_ass_subscribed_2;
    PyObject *tmp_ass_subscribed_3;
    PyObject *tmp_ass_subscribed_4;
    PyObject *tmp_ass_subscribed_5;
    PyObject *tmp_ass_subscribed_6;
    PyObject *tmp_ass_subscribed_7;
    PyObject *tmp_ass_subscribed_8;
    PyObject *tmp_ass_subscript_1;
    PyObject *tmp_ass_subscript_2;
    PyObject *tmp_ass_subscript_3;
    PyObject *tmp_ass_subscript_4;
    PyObject *tmp_ass_subscript_5;
    PyObject *tmp_ass_subscript_6;
    PyObject *tmp_ass_subscript_7;
    PyObject *tmp_ass_subscript_8;
    PyObject *tmp_ass_subvalue_1;
    PyObject *tmp_ass_subvalue_2;
    PyObject *tmp_ass_subvalue_3;
    PyObject *tmp_ass_subvalue_4;
    PyObject *tmp_ass_subvalue_5;
    PyObject *tmp_ass_subvalue_6;
    PyObject *tmp_ass_subvalue_7;
    PyObject *tmp_ass_subvalue_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_bases_name_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    int tmp_cmp_In_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_dict_name_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_fromlist_name_3;
    PyObject *tmp_fromlist_name_4;
    PyObject *tmp_fromlist_name_5;
    PyObject *tmp_fromlist_name_6;
    PyObject *tmp_fromlist_name_7;
    PyObject *tmp_fromlist_name_8;
    PyObject *tmp_fromlist_name_9;
    PyObject *tmp_fromlist_name_10;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_globals_name_3;
    PyObject *tmp_globals_name_4;
    PyObject *tmp_globals_name_5;
    PyObject *tmp_globals_name_6;
    PyObject *tmp_globals_name_7;
    PyObject *tmp_globals_name_8;
    PyObject *tmp_globals_name_9;
    PyObject *tmp_globals_name_10;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_import_name_from_3;
    PyObject *tmp_key_name_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_locals_name_3;
    PyObject *tmp_locals_name_4;
    PyObject *tmp_locals_name_5;
    PyObject *tmp_locals_name_6;
    PyObject *tmp_locals_name_7;
    PyObject *tmp_locals_name_8;
    PyObject *tmp_locals_name_9;
    PyObject *tmp_locals_name_10;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_name_name_3;
    PyObject *tmp_name_name_4;
    PyObject *tmp_name_name_5;
    PyObject *tmp_name_name_6;
    PyObject *tmp_name_name_7;
    PyObject *tmp_name_name_8;
    PyObject *tmp_name_name_9;
    PyObject *tmp_name_name_10;
    bool tmp_result;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_star_imported_1;
    PyObject *tmp_star_imported_2;
    PyObject *tmp_star_imported_3;
    struct Nuitka_FrameObject *frame_module;


    // Module code.
    tmp_assign_source_1 = const_str_digest_293919c35bfb52b109247dc353594438;
    UPDATE_STRING_DICT0( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    tmp_assign_source_3 = LIST_COPY( const_list_38455ee7e920419e997654e9f66bb83b_list );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_3 );
    // Frame without reuse.
    frame_module = MAKE_MODULE_FRAME( codeobj_5887760a6bdb8b06dae2fa16a7f0c572, module_direct$task$Task );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_module );
    assert( Py_REFCNT( frame_module ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_digest_485ce81cec1a1f31081339bcf501b5fc;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_1 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_fromlist_name_1 = const_tuple_str_chr_42_tuple;
    frame_module->m_frame.f_lineno = 9;
    tmp_star_imported_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_star_imported_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto frame_exception_exit_1;
    }
    tmp_result = IMPORT_MODULE_STAR( module_direct$task$Task, true, tmp_star_imported_1 );
    Py_DECREF( tmp_star_imported_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 9;

        goto frame_exception_exit_1;
    }
    tmp_name_name_2 = const_str_digest_c7934e5040220a373c561f5656379884;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_ExceptionVarDump_tuple;
    frame_module->m_frame.f_lineno = 10;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 10;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_ExceptionVarDump );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 10;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_ExceptionVarDump, tmp_assign_source_4 );
    tmp_name_name_3 = const_str_digest_1ec94dde2d7bfdc5166ada89a737ba93;
    tmp_globals_name_3 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_3 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_fromlist_name_3 = const_tuple_str_chr_42_tuple;
    frame_module->m_frame.f_lineno = 11;
    tmp_star_imported_2 = IMPORT_MODULE4( tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3 );
    if ( tmp_star_imported_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    tmp_result = IMPORT_MODULE_STAR( module_direct$task$Task, true, tmp_star_imported_2 );
    Py_DECREF( tmp_star_imported_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    tmp_name_name_4 = const_str_digest_3dd28ae5a4057083590ecdb59e504cf8;
    tmp_globals_name_4 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_4 = Py_None;
    tmp_fromlist_name_4 = const_tuple_str_plain_messenger_tuple;
    frame_module->m_frame.f_lineno = 12;
    tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_5 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_messenger );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_messenger, tmp_assign_source_5 );
    tmp_name_name_5 = const_str_plain_types;
    tmp_globals_name_5 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_5 = Py_None;
    tmp_fromlist_name_5 = Py_None;
    frame_module->m_frame.f_lineno = 13;
    tmp_assign_source_6 = IMPORT_MODULE4( tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 13;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_types, tmp_assign_source_6 );
    tmp_name_name_6 = const_str_plain_random;
    tmp_globals_name_6 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_6 = Py_None;
    tmp_fromlist_name_6 = Py_None;
    frame_module->m_frame.f_lineno = 14;
    tmp_assign_source_7 = IMPORT_MODULE4( tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 14;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_random, tmp_assign_source_7 );
    tmp_name_name_7 = const_str_plain_importlib;
    tmp_globals_name_7 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_7 = Py_None;
    tmp_fromlist_name_7 = Py_None;
    frame_module->m_frame.f_lineno = 15;
    tmp_assign_source_8 = IMPORT_MODULE4( tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 15;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_importlib, tmp_assign_source_8 );
    tmp_name_name_8 = const_str_plain_signal;
    tmp_globals_name_8 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_8 = Py_None;
    tmp_fromlist_name_8 = Py_None;
    frame_module->m_frame.f_lineno = 18;
    tmp_assign_source_9 = IMPORT_MODULE4( tmp_name_name_8, tmp_globals_name_8, tmp_locals_name_8, tmp_fromlist_name_8 );
    assert( tmp_assign_source_9 != NULL );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_signal, tmp_assign_source_9 );
    tmp_name_name_9 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_9 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_9 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_fromlist_name_9 = const_tuple_str_chr_42_tuple;
    frame_module->m_frame.f_lineno = 22;
    tmp_star_imported_3 = IMPORT_MODULE4( tmp_name_name_9, tmp_globals_name_9, tmp_locals_name_9, tmp_fromlist_name_9 );
    if ( tmp_star_imported_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;

        goto frame_exception_exit_1;
    }
    tmp_result = IMPORT_MODULE_STAR( module_direct$task$Task, true, tmp_star_imported_3 );
    Py_DECREF( tmp_star_imported_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 22;

        goto frame_exception_exit_1;
    }
    tmp_name_name_10 = const_str_digest_2abb2b71e1c784ac5cdc21dd54796019;
    tmp_globals_name_10 = ((PyModuleObject *)module_direct$task$Task)->md_dict;
    tmp_locals_name_10 = Py_None;
    tmp_fromlist_name_10 = const_tuple_str_plain_HTTPChannel_extensions_tuple;
    frame_module->m_frame.f_lineno = 23;
    tmp_import_name_from_3 = IMPORT_MODULE4( tmp_name_name_10, tmp_globals_name_10, tmp_locals_name_10, tmp_fromlist_name_10 );
    if ( tmp_import_name_from_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_10 = IMPORT_NAME( tmp_import_name_from_3, const_str_plain_HTTPChannel_extensions );
    Py_DECREF( tmp_import_name_from_3 );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 23;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_HTTPChannel_extensions, tmp_assign_source_10 );
    tmp_assign_source_11 = MAKE_FUNCTION_direct$task$Task$$$function_1_print_exc_plus(  );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_print_exc_plus, tmp_assign_source_11 );
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 65;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_12 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_DSDone );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done, tmp_assign_source_12 );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 66;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_13 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_DSCont );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 66;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_cont, tmp_assign_source_13 );
    tmp_source_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_source_name_3 == NULL ))
    {
        tmp_source_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_source_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 67;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_14 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_DSAgain );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_again, tmp_assign_source_14 );
    tmp_source_name_4 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_source_name_4 == NULL ))
    {
        tmp_source_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_source_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 68;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_15 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_DSPickup );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_pickup, tmp_assign_source_15 );
    tmp_source_name_5 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTask );

    if (unlikely( tmp_source_name_5 == NULL ))
    {
        tmp_source_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTask );
    }

    if ( tmp_source_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTask" );
        exception_tb = NULL;

        exception_lineno = 69;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_16 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_DSExit );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 69;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_exit, tmp_assign_source_16 );
    tmp_assign_source_17 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_PythonTask );

    if (unlikely( tmp_assign_source_17 == NULL ))
    {
        tmp_assign_source_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_PythonTask );
    }

    if ( tmp_assign_source_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "PythonTask" );
        exception_tb = NULL;

        exception_lineno = 72;

        goto frame_exception_exit_1;
    }

    UPDATE_STRING_DICT0( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task, tmp_assign_source_17 );
    tmp_ass_subvalue_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_done );

    if (unlikely( tmp_ass_subvalue_1 == NULL ))
    {
        tmp_ass_subvalue_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_done );
    }

    if ( tmp_ass_subvalue_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "done" );
        exception_tb = NULL;

        exception_lineno = 77;

        goto frame_exception_exit_1;
    }

    tmp_source_name_6 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_6 == NULL ))
    {
        tmp_source_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 77;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_1 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 77;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_1 = const_str_plain_done;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1 );
    Py_DECREF( tmp_ass_subscribed_1 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 77;

        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_cont );

    if (unlikely( tmp_ass_subvalue_2 == NULL ))
    {
        tmp_ass_subvalue_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_cont );
    }

    if ( tmp_ass_subvalue_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "cont" );
        exception_tb = NULL;

        exception_lineno = 78;

        goto frame_exception_exit_1;
    }

    tmp_source_name_7 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_7 == NULL ))
    {
        tmp_source_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 78;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_2 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_2 = const_str_plain_cont;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2 );
    Py_DECREF( tmp_ass_subscribed_2 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;

        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_again );

    if (unlikely( tmp_ass_subvalue_3 == NULL ))
    {
        tmp_ass_subvalue_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_again );
    }

    if ( tmp_ass_subvalue_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "again" );
        exception_tb = NULL;

        exception_lineno = 79;

        goto frame_exception_exit_1;
    }

    tmp_source_name_8 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_8 == NULL ))
    {
        tmp_source_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 79;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_3 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 79;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_3 = const_str_plain_again;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_3, tmp_ass_subscript_3, tmp_ass_subvalue_3 );
    Py_DECREF( tmp_ass_subscribed_3 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 79;

        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_4 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_pickup );

    if (unlikely( tmp_ass_subvalue_4 == NULL ))
    {
        tmp_ass_subvalue_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_pickup );
    }

    if ( tmp_ass_subvalue_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "pickup" );
        exception_tb = NULL;

        exception_lineno = 80;

        goto frame_exception_exit_1;
    }

    tmp_source_name_9 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_9 == NULL ))
    {
        tmp_source_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 80;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_4 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_4 = const_str_plain_pickup;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_4, tmp_ass_subscript_4, tmp_ass_subvalue_4 );
    Py_DECREF( tmp_ass_subscribed_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 80;

        goto frame_exception_exit_1;
    }
    tmp_ass_subvalue_5 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_exit );

    if (unlikely( tmp_ass_subvalue_5 == NULL ))
    {
        tmp_ass_subvalue_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_exit );
    }

    if ( tmp_ass_subvalue_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "exit" );
        exception_tb = NULL;

        exception_lineno = 81;

        goto frame_exception_exit_1;
    }

    tmp_source_name_10 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_10 == NULL ))
    {
        tmp_source_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 81;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_5 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_5 = const_str_plain_exit;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_5, tmp_ass_subscript_5, tmp_ass_subvalue_5 );
    Py_DECREF( tmp_ass_subscribed_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 81;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_18 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_AsyncTaskPause );

    if (unlikely( tmp_assign_source_18 == NULL ))
    {
        tmp_assign_source_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_AsyncTaskPause );
    }

    if ( tmp_assign_source_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "AsyncTaskPause" );
        exception_tb = NULL;

        exception_lineno = 84;

        goto frame_exception_exit_1;
    }

    UPDATE_STRING_DICT0( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_pause, tmp_assign_source_18 );
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_staticmethod );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_pause );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_pause );
    }

    if ( tmp_args_element_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "pause" );
        exception_tb = NULL;

        exception_lineno = 85;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 85;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_ass_subvalue_6 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    if ( tmp_ass_subvalue_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;

        goto frame_exception_exit_1;
    }
    tmp_source_name_11 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_11 == NULL ))
    {
        tmp_source_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_11 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_6 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 85;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_6 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_6 );

        exception_lineno = 85;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_6 = const_str_plain_pause;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_6, tmp_ass_subscript_6, tmp_ass_subvalue_6 );
    Py_DECREF( tmp_ass_subscribed_6 );
    Py_DECREF( tmp_ass_subvalue_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_19 = MAKE_FUNCTION_direct$task$Task$$$function_2_sequence(  );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_sequence, tmp_assign_source_19 );
    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_staticmethod );
    assert( tmp_called_name_2 != NULL );
    tmp_args_element_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_sequence );

    if (unlikely( tmp_args_element_name_2 == NULL ))
    {
        tmp_args_element_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_sequence );
    }

    if ( tmp_args_element_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "sequence" );
        exception_tb = NULL;

        exception_lineno = 92;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 92;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_ass_subvalue_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_ass_subvalue_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto frame_exception_exit_1;
    }
    tmp_source_name_12 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_12 == NULL ))
    {
        tmp_source_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_12 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_7 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 92;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_7 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_7 );

        exception_lineno = 92;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_7 = const_str_plain_sequence;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_7, tmp_ass_subscript_7, tmp_ass_subvalue_7 );
    Py_DECREF( tmp_ass_subscribed_7 );
    Py_DECREF( tmp_ass_subvalue_7 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 92;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_20 = MAKE_FUNCTION_direct$task$Task$$$function_3_loop(  );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_loop, tmp_assign_source_20 );
    tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_staticmethod );
    assert( tmp_called_name_3 != NULL );
    tmp_args_element_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_loop );

    if (unlikely( tmp_args_element_name_3 == NULL ))
    {
        tmp_args_element_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_loop );
    }

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "loop" );
        exception_tb = NULL;

        exception_lineno = 100;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 100;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_ass_subvalue_8 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    if ( tmp_ass_subvalue_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 100;

        goto frame_exception_exit_1;
    }
    tmp_source_name_13 = GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_Task );

    if (unlikely( tmp_source_name_13 == NULL ))
    {
        tmp_source_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Task );
    }

    if ( tmp_source_name_13 == NULL )
    {
        Py_DECREF( tmp_ass_subvalue_8 );
        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Task" );
        exception_tb = NULL;

        exception_lineno = 100;

        goto frame_exception_exit_1;
    }

    tmp_ass_subscribed_8 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_DtoolClassDict );
    if ( tmp_ass_subscribed_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_ass_subvalue_8 );

        exception_lineno = 100;

        goto frame_exception_exit_1;
    }
    tmp_ass_subscript_8 = const_str_plain_loop;
    tmp_result = SET_SUBSCRIPT( tmp_ass_subscribed_8, tmp_ass_subscript_8, tmp_ass_subvalue_8 );
    Py_DECREF( tmp_ass_subscribed_8 );
    Py_DECREF( tmp_ass_subvalue_8 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 100;

        goto frame_exception_exit_1;
    }
    // Tried code:
    tmp_assign_source_21 = impl_direct$task$Task$$$class_1_TaskManager( NULL );
    if ( tmp_assign_source_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;

        goto try_except_handler_1;
    }
    assert( tmp_class_creation_1__class_dict == NULL );
    tmp_class_creation_1__class_dict = tmp_assign_source_21;

    tmp_compare_left_1 = const_str_plain___metaclass__;
    tmp_compare_right_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_In_1 = PySequence_Contains( tmp_compare_right_1, tmp_compare_left_1 );
    assert( !(tmp_cmp_In_1 == -1) );
    if ( tmp_cmp_In_1 == 1 )
    {
        goto condexpr_true_1;
    }
    else
    {
        goto condexpr_false_1;
    }
    condexpr_true_1:;
    tmp_dict_name_1 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_dict_name_1 );
    tmp_key_name_1 = const_str_plain___metaclass__;
    tmp_assign_source_22 = DICT_GET_ITEM( tmp_dict_name_1, tmp_key_name_1 );
    if ( tmp_assign_source_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;

        goto try_except_handler_1;
    }
    goto condexpr_end_1;
    condexpr_false_1:;
    tmp_bases_name_1 = const_tuple_empty;
    tmp_assign_source_22 = SELECT_METACLASS( tmp_bases_name_1, GET_STRING_DICT_VALUE( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain___metaclass__ ) );
    condexpr_end_1:;
    assert( tmp_class_creation_1__metaclass == NULL );
    tmp_class_creation_1__metaclass = tmp_assign_source_22;

    tmp_called_name_4 = tmp_class_creation_1__metaclass;

    CHECK_OBJECT( tmp_called_name_4 );
    tmp_args_element_name_4 = const_str_plain_TaskManager;
    tmp_args_element_name_5 = const_tuple_empty;
    tmp_args_element_name_6 = tmp_class_creation_1__class_dict;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_module->m_frame.f_lineno = 102;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_23 = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 102;

        goto try_except_handler_1;
    }
    assert( tmp_class_creation_1__class == NULL );
    tmp_class_creation_1__class = tmp_assign_source_23;

    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    Py_XDECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif
    popFrameStack();

    assertFrameObject( frame_module );

    goto frame_no_exception_1;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_module, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_module->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_module, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_1:;
    tmp_assign_source_24 = tmp_class_creation_1__class;

    CHECK_OBJECT( tmp_assign_source_24 );
    UPDATE_STRING_DICT0( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_TaskManager, tmp_assign_source_24 );
    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class );
    Py_DECREF( tmp_class_creation_1__class );
    tmp_class_creation_1__class = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__class_dict );
    Py_DECREF( tmp_class_creation_1__class_dict );
    tmp_class_creation_1__class_dict = NULL;

    CHECK_OBJECT( (PyObject *)tmp_class_creation_1__metaclass );
    Py_DECREF( tmp_class_creation_1__metaclass );
    tmp_class_creation_1__metaclass = NULL;

    tmp_assign_source_25 = MAKE_FUNCTION_direct$task$Task$$$function_4_checkLeak(  );
    UPDATE_STRING_DICT1( moduledict_direct$task$Task, (Nuitka_StringObject *)const_str_plain_checkLeak, tmp_assign_source_25 );

    return MOD_RETURN_VALUE( module_direct$task$Task );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
