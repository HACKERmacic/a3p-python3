/* Generated code for Python source for module 'direct.extensions_native.NodePath_extensions'
 * created by Nuitka version 0.5.26
 *
 * This code is in part copyright 2017 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The _module_direct$extensions_native$NodePath_extensions is a Python object pointer of module type. */

/* Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_direct$extensions_native$NodePath_extensions;
PyDictObject *moduledict_direct$extensions_native$NodePath_extensions;

/* The module constants used, if any. */
static PyObject *const_str_digest_8e72c82b5d9083fb94a573ca3ea6c2fe;
static PyObject *const_str_digest_e4b151998270e43899ddbb5f99045dbe;
static PyObject *const_str_digest_06971424f50e889da5ec9adae51853c6;
extern PyObject *const_str_plain_getChildren;
extern PyObject *const_tuple_str_plain_self_str_plain_other_tuple;
extern PyObject *const_str_plain_LerpPosInterval;
static PyObject *const_str_plain_getIntoCollideMask;
static PyObject *const_str_plain_collNodePath;
static PyObject *const_str_plain_attachCollisionSegment;
extern PyObject *const_str_plain_setHpr;
static PyObject *const_str_digest_fda6811bf39fdc1057e50f4fadb295e9;
static PyObject *const_str_digest_136d8c8696b9665bea7cef47470e2afb;
static PyObject *const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple;
extern PyObject *const_str_plain_win;
extern PyObject *const_str_plain_direct;
static PyObject *const_str_plain_LMLowest;
static PyObject *const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple;
static PyObject *const_str_plain_showCS;
static PyObject *const_tuple_str_plain_self_str_plain_ancestors_tuple;
static PyObject *const_str_plain_getWord;
extern PyObject *const_float_1_0;
static PyObject *const_str_plain_showAllDescendants;
extern PyObject *const_str_plain_node;
extern PyObject *const_str_plain_stack;
extern PyObject *const_str_plain_CollisionNode;
extern PyObject *const_str_plain_args;
static PyObject *const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple;
static PyObject *const_str_digest_e5a70be140fb2f14027ecfb7aa572fac;
static PyObject *const_str_plain_iPosHprScale;
static PyObject *const_str_plain_lsNames;
static PyObject *const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple;
static PyObject *const_str_digest_e0dbf252c0255ebe72277da1e8b32358;
static PyObject *const_str_digest_97007f6b72f106c60d0886544555df19;
static PyObject *const_str_digest_4141e963730526886a4b6a002fdcd779;
static PyObject *const_str_digest_e917277f6cb7db604adcd995cbb75173;
static PyObject *const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple;
static PyObject *const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple;
extern PyObject *const_str_plain_shear;
extern PyObject *const_tuple_int_pos_1_int_pos_1_int_pos_1_tuple;
static PyObject *const_str_digest_8539abab90e32d39166e1ee2cfc4d229;
static PyObject *const_str_digest_cb55be559bd21b2bb4f7207654f14aea;
static PyObject *const_str_plain_posQuatInterval;
extern PyObject *const_str_plain_LerpScaleInterval;
static PyObject *const_str_plain_hprScaleInterval;
static PyObject *const_str_plain_oy;
static PyObject *const_str_plain_oz;
static PyObject *const_str_plain_hasHpr;
static PyObject *const_str_plain_dy;
static PyObject *const_str_plain_dx;
extern PyObject *const_str_plain_find;
extern PyObject *const_str_plain_getName;
static PyObject *const_str_digest_34ada3e127fd4d1d9399238e854e0384;
static PyObject *const_str_plain_colorInterval;
extern PyObject *const_str_plain_send;
extern PyObject *const_str_plain_nodePath;
extern PyObject *const_float_0_75;
static PyObject *const_str_plain_fmtStr;
static PyObject *const_str_plain_subdivideCollisions;
extern PyObject *const_str_plain_removeNode;
static PyObject *const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple;
extern PyObject *const_str_plain_getType;
static PyObject *const_str_plain_colNp;
extern PyObject *const_str_plain_LerpQuatScaleInterval;
static PyObject *const_tuple_str_plain_MultitexReducer_tuple;
extern PyObject *const_str_plain_newNode;
static PyObject *const_str_plain_getNumPaths;
static PyObject *const_str_digest_73fa360419110f5e7e11bd2f92e1c0ad;
static PyObject *const_str_digest_5475c93c31866a42dfb5b7fbdfa9607b;
static PyObject *const_str_digest_1b278c87e5956d0815aacacaa6122dce;
extern PyObject *const_str_plain_reverse;
static PyObject *const_str_digest_503cbb628f4ae47a725b7c360e49319f;
static PyObject *const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple;
static PyObject *const_str_plain_getKey;
static PyObject *const_str_digest_97d172f6b9adf5324941d1e6dd22a0d3;
static PyObject *const_str_digest_49ae60eddca40526491e8bdd07022c60;
static PyObject *const_tuple_str_digest_3fb30edff6bdd123d0f703659311cfbc_tuple;
static PyObject *const_str_plain_setLodMode;
extern PyObject *const_str_plain_LerpPosHprInterval;
static PyObject *const_str_plain_attachCollisionSphere;
static PyObject *const_str_plain_place;
extern PyObject *const_str_plain_LerpQuatInterval;
extern PyObject *const_str_plain_getPos;
static PyObject *const_tuple_str_plain_CollisionSegment_tuple;
extern PyObject *const_str_plain_kw;
static PyObject *const_str_digest_095507e151ec3e28c10d55b825eb29fc;
static PyObject *const_str_plain_collNode;
static PyObject *const_str_digest_bc0e80cd2cccb41242a91323ec48d3fa;
extern PyObject *const_str_plain_clear;
static PyObject *const_str_digest_20a2483b2157cbd98f585f6b4e968f97;
static PyObject *const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple;
static PyObject *const_str_plain_SceneGraphExplorer;
static PyObject *const_tuple_none_int_pos_2_tuple;
static PyObject *const_str_plain_solid;
static PyObject *const_str_plain_sga2;
static PyObject *const_str_digest_992342804c63488bb7dc99bf40bab416;
static PyObject *const_tuple_str_plain_Vec3_tuple;
static PyObject *const_str_plain_printHpr;
static PyObject *const_str_plain_getNumLodNodes;
static PyObject *const_str_digest_2aaa28b3d493cec16afb02e4ee05025c;
extern PyObject *const_str_plain_hpr;
static PyObject *const_str_digest_76da864eb1584fe789e5ec7b9c456e6a;
static PyObject *const_tuple_57312349eaa3be47c249779d3d87b682_tuple;
static PyObject *const_str_plain_stateFrom;
static PyObject *const_str_digest_b2b98b498f6c9bc6671ffae896e8f53b;
static PyObject *const_str_plain_scaleInterval;
extern PyObject *const_str_plain_getTransform;
static PyObject *const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple;
static PyObject *const_str_plain_colNps;
extern PyObject *const_str_plain_getHpr;
extern PyObject *const_str_digest_a9f9a21e276932d061c34fdf077216a6;
static PyObject *const_str_plain_Slider;
static PyObject *const_str_plain_colorScaleInterval;
static PyObject *const_str_digest_c3e7ebff48fc83a1a43b8f8eedbad5fb;
static PyObject *const_tuple_str_space_tuple;
static PyObject *const_str_plain_getAncestors;
static PyObject *const_str_plain_quatInterval;
static PyObject *const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple;
static PyObject *const_tuple_none_none_int_0_int_0_none_tuple;
static PyObject *const_str_digest_9b9d92dce635694dfeae541eca84ac72;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_3bff77c337e9ced759045bfa6af9fd7a;
static PyObject *const_str_plain_CollisionSegment;
static PyObject *const_str_digest_20cc24bb99251993826a0b06bd8fb28e;
static PyObject *const_str_digest_9b1387bcbe22a7a3a9dfe8973569fbd2;
static PyObject *const_str_plain_lsNamesRecurse;
static PyObject *const_str_plain_hideCS;
static PyObject *const_str_plain_Placer;
static PyObject *const_str_digest_9636692118d6ae60d387de5cf6ee2550;
extern PyObject *const_str_plain_setIntoCollideMask;
extern PyObject *const_str_plain_LerpPosQuatInterval;
extern PyObject *const_str_plain_extension_native_helpers;
static PyObject *const_str_digest_e43f9e9dfaa37742a036468e70e7d9ad;
static PyObject *const_str_plain_posQuatScaleInterval;
static PyObject *const_tuple_a435b88495307eb9936b0082ce374ad6_tuple;
extern PyObject *const_str_plain_startTk;
extern PyObject *const_str_plain_max;
extern PyObject *const_str_plain___file__;
static PyObject *const_str_plain_solidTree;
static PyObject *const_str_digest_ee238700af53818c4ed331ccfcb75d41;
static PyObject *const_str_digest_dc8ebf821d0ec8a379e0623265c69bad;
static PyObject *const_str_plain_intoCollide;
static PyObject *const_str_digest_053e5e3bfa671cc09bbbfe2a7d1da46c;
static PyObject *const_tuple_none_int_pos_2_int_0_tuple;
static PyObject *const_str_plain_fromCollide;
static PyObject *const_str_plain_printScale;
extern PyObject *const_str_plain_setPosHpr;
extern PyObject *const_str_chr_125;
static PyObject *const_str_digest_bd96532d176388ff9d8ae80995aefb1a;
static PyObject *const_str_plain_r_subdivideCollisions;
static PyObject *const_dict_55b580ba8802a2d7adcd3895d0c5b8d9;
static PyObject *const_str_plain_printPos;
extern PyObject *const_str_plain_NodePath_extensions;
extern PyObject *const_str_plain_name;
extern PyObject *const_str_plain_outputString;
static PyObject *const_str_plain_indentString;
extern PyObject *const_str_plain_scale;
static PyObject *const_str_plain_coll;
extern PyObject *const_str_plain_Vec3;
extern PyObject *const_tuple_int_0_int_0_int_0_tuple;
static PyObject *const_str_digest_7562d3a4d5354201304f36f42e3a0f01;
extern PyObject *const_str_plain_np;
static PyObject *const_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5;
extern PyObject *const_str_plain_LerpShearInterval;
static PyObject *const_str_plain_cn;
extern PyObject *const_str_plain_cb;
static PyObject *const_str_plain_cx;
static PyObject *const_str_plain_ancestry;
static PyObject *const_str_plain_cz;
static PyObject *const_str_digest_2fbcad0fe537265b904c373a7885697a;
extern PyObject *const_str_plain_LerpPosHprScaleInterval;
extern PyObject *const_str_plain_stash;
static PyObject *const_str_plain_getUniformScale;
extern PyObject *const_str_plain_startDirect;
static PyObject *const_str_digest_2f9b549ac2e6176a73d3747b50505803;
static PyObject *const_str_plain_getSolid;
extern PyObject *const_tuple_int_pos_1_tuple;
extern PyObject *const_str_plain_transform;
static PyObject *const_str_digest_e1d499a078ec1d220d93fb06f682d214;
static PyObject *const_str_digest_0dfcaf48daceb4bbbd511004ff22d2e1;
static PyObject *const_str_plain_parentNode;
extern PyObject *const_str_plain_target;
static PyObject *const_str_digest_61b9ebff752ab039660c3b1eb14c85ba;
static PyObject *const_str_plain_posHprScaleShearInterval;
static PyObject *const_str_digest_7996907301bec4877f4d020cf3f44696;
static PyObject *const_str_plain_iScale;
extern PyObject *const_str_plain_pos;
extern PyObject *const_str_plain_pop;
extern PyObject *const_str_newline;
extern PyObject *const_str_plain_detachNode;
static PyObject *const_str_digest_7008f8eb1ab08ab901bff06d4f36aa5c;
extern PyObject *const_str_plain_LerpHprInterval;
static PyObject *const_str_digest_ab62dd0d26391f0d1f3fa85284b2e0ca;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e;
static PyObject *const_tuple_505bb195ca4da0f448d5830740c25309_tuple;
static PyObject *const_str_digest_afc53e5a5c9626f0b132417ffd0373cd;
static PyObject *const_str_plain_numSolids;
static PyObject *const_str_digest_77e9c17b462a3d9a8f3d88de94cab242;
static PyObject *const_str_plain_mr;
static PyObject *const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple;
static PyObject *const_str_plain_sga;
static PyObject *const_str_digest_97e8dda8bf2e2fec759c98598bae2ac3;
static PyObject *const_str_digest_1534cb090b59d6ea78e080c0a531f66c;
static PyObject *const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple;
static PyObject *const_str_digest_f40118032477fce3c42a75520e50ad50;
static PyObject *const_str_plain_printPosHprScale;
static PyObject *const_tuple_str_plain_self_str_plain_sib_tuple;
extern PyObject *const_str_plain_CollisionSphere;
static PyObject *const_str_plain_getNumDescendants;
extern PyObject *const_str_plain_self;
static PyObject *const_str_plain_printPosHpr;
static PyObject *const_str_plain_setUseGeom;
static PyObject *const_str_plain_r_constructCollisionTree;
static PyObject *const_str_digest_c32947a023738e64a068931829c2cbe7;
extern PyObject *const_str_plain_setScale;
static PyObject *const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple;
static PyObject *const_str_plain_getNumSolids;
static PyObject *const_str_plain_setAllowTexMat;
static PyObject *const_str_plain_dz;
extern PyObject *const_str_plain_min;
static PyObject *const_str_digest_bbe0d8d2767726e357eab3b3c0fd9bd1;
static PyObject *const_str_digest_2d6f8042b6a48948b99a4fe55a6dd148;
static PyObject *const_str_plain_formatString;
static PyObject *const_str_plain_getChildrenAsList;
extern PyObject *const_str_plain_LerpPosHprScaleShearInterval;
static PyObject *const_str_plain_allowTexMat;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_flatten;
static PyObject *const_str_plain_analyze;
extern PyObject *const_str_plain_select;
extern PyObject *const_str_plain_attachNewNode;
static PyObject *const_str_digest_91640840388c643d3b01f90ede98717d;
extern PyObject *const_str_plain_setPos;
extern PyObject *const_str_plain_findAllMatches;
static PyObject *const_tuple_str_plain_CollisionRay_tuple;
extern PyObject *const_str_plain_setTarget;
extern PyObject *const_int_pos_2;
static PyObject *const_str_plain_hideSiblings;
extern PyObject *const_int_pos_1;
static PyObject *const_tuple_str_plain_LerpInterval_tuple;
static PyObject *const_str_plain_rgbPanel;
extern PyObject *const_str_plain_isHidden;
static PyObject *const_str_plain_scan;
static PyObject *const_tuple_str_plain_CollisionSphere_tuple;
static PyObject *const_str_plain_solids;
static PyObject *const_tuple_str_plain_self_str_plain_child_tuple;
static PyObject *const_str_digest_f43d5851181b239a5955f5f4ab670845;
static PyObject *const_str_plain_posHprScaleInterval;
static PyObject *const_str_digest_a8d65c3d3b507677d22784985ff6542a;
extern PyObject *const_str_plain_CollisionRay;
extern PyObject *const_str_plain_child;
static PyObject *const_str_digest_3538967cd056504ea8299e4ed627b926;
static PyObject *const_str_digest_53bc5171cf67f03e6360b218341ac9ed;
extern PyObject *const_str_plain_id;
static PyObject *const_str_plain_hprInterval;
extern PyObject *const_str_plain_show;
static PyObject *const_tuple_str_digest_e5a70be140fb2f14027ecfb7aa572fac_tuple;
static PyObject *const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple;
extern PyObject *const_str_plain_extend;
static PyObject *const_str_plain_LMHighest;
extern PyObject *const_str_plain_hide;
static PyObject *const_str_digest_699a545b77b3e4ba76f4fb1ce6853c36;
extern PyObject *const_str_plain_setFromCollideMask;
static PyObject *const_str_digest_bac08fb81251f0d3f6fdb9de54f05162;
static PyObject *const_str_plain_shearInterval;
extern PyObject *const_str_plain_i;
static PyObject *const_str_plain_cy;
extern PyObject *const_str_plain_f;
static PyObject *const_str_plain_explore;
static PyObject *const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple;
static PyObject *const_str_digest_cfa2cf27cc4cdd2bfc990e4e09a3399e;
extern PyObject *const_str_plain_p;
extern PyObject *const_str_plain_r;
static PyObject *const_str_digest_841c073c60a7d5f21d68b18948e7bd8a;
static PyObject *const_str_plain_MultitexReducer;
extern PyObject *const_str_plain_getScale;
static PyObject *const_str_plain_posHprInterval;
extern PyObject *const_str_plain_item;
static PyObject *const_str_digest_ba00b854e68e3d31836ee7259fad44c3;
extern PyObject *const_str_plain_LerpPosQuatScaleInterval;
static PyObject *const_str_plain_hasScale;
static PyObject *const_str_plain_otherString;
static PyObject *const_str_digest_11c3b44c13cb5260233013d95d9d6fee;
extern PyObject *const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
extern PyObject *const_str_plain_setPosHprScale;
static PyObject *const_str_digest_47194625d05e416bab876dcaaafddec7;
static PyObject *const_str_plain_fRecursive;
static PyObject *const_str_plain_pPrintString;
extern PyObject *const_int_0;
static PyObject *const_tuple_str_digest_5475c93c31866a42dfb5b7fbdfa9607b_tuple;
extern PyObject *const_str_plain_LerpColorScaleInterval;
extern PyObject *const_str_plain_messenger;
static PyObject *const_str_plain_sib;
static PyObject *const_str_digest_3022a4824a2c2fe8c6d287d38d814227;
extern PyObject *const_str_plain_Dtool_funcToMethod;
extern PyObject *const_str_plain_addNode;
static PyObject *const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
extern PyObject *const_str_plain_append;
static PyObject *const_tuple_6f4376fb5b34d101d91f65a28e4174f6_tuple;
static PyObject *const_str_plain_printTransform;
extern PyObject *const_str_digest_b8872718382dd39ffa4013e303d20ce5;
static PyObject *const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple;
extern PyObject *const_str_plain_import_module;
static PyObject *const_str_digest_eeb948922be95abd991ff245125db928;
static PyObject *const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple;
static PyObject *const_str_plain_bz;
extern PyObject *const_str_digest_4314234708fbc134069947f7a4708b23;
extern PyObject *const_str_plain_LerpPosQuatScaleShearInterval;
static PyObject *const_str_plain_npc;
extern PyObject *const_dict_empty;
static PyObject *const_str_plain_toggleVis;
static PyObject *const_str_digest_8d4812dee8f3081b71f85da68e87d9e1;
static PyObject *const_str_digest_60e8ae5173922e540ddfbff28401f039;
static PyObject *const_dict_82438769d4f7f66d5a77a06a04bb40a6;
static PyObject *const_str_plain_getShear;
static PyObject *const_str_plain_printChildren;
extern PyObject *const_tuple_str_plain_Dtool_funcToMethod_tuple;
static PyObject *const_str_digest_3fb30edff6bdd123d0f703659311cfbc;
static PyObject *const_str_digest_0c5b0d596a8151bd1f5bf644e10998b9;
extern PyObject *const_str_plain_isEmpty;
static PyObject *const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple;
static PyObject *const_str_plain_numSolidsInLeaves;
static PyObject *const_str_plain_hasPos;
static PyObject *const_tuple_240603124997e998fec04bb6b6161143_tuple;
static PyObject *const_str_digest_32ad1e41899e662e0ba1996bff7d0a9a;
static PyObject *const_str_plain_by;
static PyObject *const_str_plain_bx;
extern PyObject *const_str_plain_remove;
static PyObject *const_str_digest_c53ef752a249b2e5a51aa448d57d70d2;
extern PyObject *const_str_plain_almostEqual;
static PyObject *const_str_plain_preRemoveNodePath;
static PyObject *const_tuple_str_plain_CollisionNode_tuple;
static PyObject *const_str_plain_quatScaleInterval;
static PyObject *const_tuple_c73386e0476eb45878e9a64725822b1e_tuple;
static PyObject *const_str_digest_fc6651ce2bf4c50e0dded358cfe6a5b8;
static PyObject *const_str_plain_showSiblings;
extern PyObject *const_tuple_int_0_tuple;
static PyObject *const_str_plain_iPosHpr;
extern PyObject *const_str_plain_LerpInterval;
static PyObject *const_str_plain_removeNonCollisions;
static PyObject *const_str_plain_deselect;
static PyObject *const_str_digest_9bd659cd284b4488953883e670875e15;
static PyObject *const_str_digest_1073b23d348cc8d2dede364119d1b818;
static PyObject *const_str_digest_89cbe1136d45e998389d6c3f912bf0b9;
static PyObject *const_str_digest_6518dbc5ec2d6f64384b8ab8ad5c320d;
static PyObject *const_str_plain_posQuatScaleShearInterval;
extern PyObject *const_str_plain_list;
static PyObject *const_str_plain_reverseLsNames;
static PyObject *const_str_plain_pPrintValues;
static PyObject *const_str_digest_5f9809dd4faa2e5c0ee4af9b5bc06f02;
static PyObject *const_str_plain_colName;
static PyObject *const_str_plain_attachCollisionRay;
static PyObject *const_str_plain_useGeom;
extern PyObject *const_float_1_25;
extern PyObject *const_str_plain_base;
static PyObject *const_str_plain_az;
static PyObject *const_str_plain_ax;
static PyObject *const_str_plain_ay;
static PyObject *const_str_digest_b958960f2fd236679ce319e586eeacf0;
static PyObject *const_str_digest_ca942f1abb1ab9e034d34109a7865404;
extern PyObject *const_str_plain_getZ;
extern PyObject *const_str_plain_getY;
extern PyObject *const_str_plain_getX;
extern PyObject *const_str_plain_LerpColorInterval;
static PyObject *const_str_digest_f9d1ea5b90058e527abc9ac18d067545;
extern PyObject *const_str_plain_other;
static PyObject *const_tuple_str_plain_SceneGraphAnalyzer_tuple;
extern PyObject *const_tuple_str_plain_NodePath_tuple;
static PyObject *const_str_plain_isolate;
static PyObject *const_str_digest_309d8f9a2a8b5f431567fe03852b19cd;
extern PyObject *const_str_plain_LerpHprScaleInterval;
static PyObject *const_str_plain_getAncestry;
static PyObject *const_str_plain_removeChildren;
static PyObject *const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple;
extern PyObject *const_str_space;
static PyObject *const_str_plain_iHpr;
static PyObject *const_str_digest_746f609ec37af2b9cd6674c0823bc3f7;
extern PyObject *const_str_plain_getParent;
extern PyObject *const_str_plain_mask;
static PyObject *const_str_digest_be8949587e5eb5966c8063479c553455;
extern PyObject *const_str_plain_fWantTk;
static PyObject *const_tuple_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e_tuple;
extern PyObject *const_str_plain___doc__;
extern PyObject *const_str_plain_sd;
static PyObject *const_str_plain_iPos;
extern PyObject *const_str_plain_detach;
static PyObject *const_str_digest_12c5328130517918ca9d49f0622ada30;
static PyObject *const_str_plain_ox;
static PyObject *const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple;
static PyObject *const_str_plain_SceneGraphAnalyzer;
extern PyObject *const_str_empty;
extern PyObject *const_str_plain_addSolid;
static PyObject *const_str_plain_posInterval;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_ancestors;
static PyObject *const_str_digest_accc6d7f594b841fd4ec537441b97824;
extern PyObject *const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
extern PyObject *const_str_plain_importlib;
static PyObject *const_str_plain_getCollisionOrigin;
static PyObject *const_str_plain_hasUniformScale;
static PyObject *const_str_digest_8e6ec66a21e36095d352cc99eb873978;
extern PyObject *const_str_plain_NodePath;
extern PyObject *const_str_plain_root;
static PyObject *const_str_plain_flattenMultitex;
static PyObject *module_filename_obj;

static bool constants_created = false;

static void createModuleConstants( void )
{
    const_str_digest_8e72c82b5d9083fb94a573ca3ea6c2fe = UNSTREAM_STRING( &constant_bin[ 44699 ], 7, 0 );
    const_str_digest_e4b151998270e43899ddbb5f99045dbe = UNSTREAM_STRING( &constant_bin[ 44706 ], 15, 0 );
    const_str_digest_06971424f50e889da5ec9adae51853c6 = UNSTREAM_STRING( &constant_bin[ 44721 ], 49, 0 );
    const_str_plain_getIntoCollideMask = UNSTREAM_STRING( &constant_bin[ 44770 ], 18, 1 );
    const_str_plain_collNodePath = UNSTREAM_STRING( &constant_bin[ 44788 ], 12, 1 );
    const_str_plain_attachCollisionSegment = UNSTREAM_STRING( &constant_bin[ 1898 ], 22, 1 );
    const_str_digest_fda6811bf39fdc1057e50f4fadb295e9 = UNSTREAM_STRING( &constant_bin[ 44800 ], 15, 0 );
    const_str_digest_136d8c8696b9665bea7cef47470e2afb = UNSTREAM_STRING( &constant_bin[ 44815 ], 32, 0 );
    const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_solidTree = UNSTREAM_STRING( &constant_bin[ 44847 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 1, const_str_plain_solidTree ); Py_INCREF( const_str_plain_solidTree );
    const_str_plain_parentNode = UNSTREAM_STRING( &constant_bin[ 44856 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 2, const_str_plain_parentNode ); Py_INCREF( const_str_plain_parentNode );
    const_str_plain_colName = UNSTREAM_STRING( &constant_bin[ 44866 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 3, const_str_plain_colName ); Py_INCREF( const_str_plain_colName );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 4, const_str_plain_item ); Py_INCREF( const_str_plain_item );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 5, const_str_plain_newNode ); Py_INCREF( const_str_plain_newNode );
    const_str_plain_cn = UNSTREAM_STRING( &constant_bin[ 2333 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 6, const_str_plain_cn ); Py_INCREF( const_str_plain_cn );
    const_str_plain_solid = UNSTREAM_STRING( &constant_bin[ 44847 ], 5, 1 );
    PyTuple_SET_ITEM( const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 7, const_str_plain_solid ); Py_INCREF( const_str_plain_solid );
    const_str_plain_LMLowest = UNSTREAM_STRING( &constant_bin[ 44873 ], 8, 1 );
    const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_SceneGraphAnalyzer = UNSTREAM_STRING( &constant_bin[ 44881 ], 18, 1 );
    PyTuple_SET_ITEM( const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple, 1, const_str_plain_SceneGraphAnalyzer ); Py_INCREF( const_str_plain_SceneGraphAnalyzer );
    const_str_plain_sga = UNSTREAM_STRING( &constant_bin[ 44899 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple, 2, const_str_plain_sga ); Py_INCREF( const_str_plain_sga );
    const_str_plain_sga2 = UNSTREAM_STRING( &constant_bin[ 44902 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple, 3, const_str_plain_sga2 ); Py_INCREF( const_str_plain_sga2 );
    const_str_plain_showCS = UNSTREAM_STRING( &constant_bin[ 1228 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_ancestors_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ancestors_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_ancestors = UNSTREAM_STRING( &constant_bin[ 44906 ], 9, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_ancestors_tuple, 1, const_str_plain_ancestors ); Py_INCREF( const_str_plain_ancestors );
    const_str_plain_getWord = UNSTREAM_STRING( &constant_bin[ 44915 ], 7, 1 );
    const_str_plain_showAllDescendants = UNSTREAM_STRING( &constant_bin[ 477 ], 18, 1 );
    const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_cx = UNSTREAM_STRING( &constant_bin[ 42794 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 2, const_str_plain_cx ); Py_INCREF( const_str_plain_cx );
    const_str_plain_cy = UNSTREAM_STRING( &constant_bin[ 44922 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 3, const_str_plain_cy ); Py_INCREF( const_str_plain_cy );
    const_str_plain_cz = UNSTREAM_STRING( &constant_bin[ 44924 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 4, const_str_plain_cz ); Py_INCREF( const_str_plain_cz );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 5, const_str_plain_r ); Py_INCREF( const_str_plain_r );
    const_str_plain_fromCollide = UNSTREAM_STRING( &constant_bin[ 44926 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 6, const_str_plain_fromCollide ); Py_INCREF( const_str_plain_fromCollide );
    const_str_plain_intoCollide = UNSTREAM_STRING( &constant_bin[ 44937 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 7, const_str_plain_intoCollide ); Py_INCREF( const_str_plain_intoCollide );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 8, const_str_plain_CollisionSphere ); Py_INCREF( const_str_plain_CollisionSphere );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 9, const_str_plain_CollisionNode ); Py_INCREF( const_str_plain_CollisionNode );
    const_str_plain_coll = UNSTREAM_STRING( &constant_bin[ 44788 ], 4, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 10, const_str_plain_coll ); Py_INCREF( const_str_plain_coll );
    const_str_plain_collNode = UNSTREAM_STRING( &constant_bin[ 44788 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 11, const_str_plain_collNode ); Py_INCREF( const_str_plain_collNode );
    PyTuple_SET_ITEM( const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 12, const_str_plain_collNodePath ); Py_INCREF( const_str_plain_collNodePath );
    const_str_digest_e5a70be140fb2f14027ecfb7aa572fac = UNSTREAM_STRING( &constant_bin[ 44948 ], 35, 0 );
    const_str_plain_iPosHprScale = UNSTREAM_STRING( &constant_bin[ 1050 ], 12, 1 );
    const_str_plain_lsNames = UNSTREAM_STRING( &constant_bin[ 574 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple, 1, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple, 2, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_e0dbf252c0255ebe72277da1e8b32358 = UNSTREAM_STRING( &constant_bin[ 44983 ], 49, 0 );
    const_str_digest_97007f6b72f106c60d0886544555df19 = UNSTREAM_STRING( &constant_bin[ 45032 ], 11, 0 );
    const_str_digest_4141e963730526886a4b6a002fdcd779 = UNSTREAM_STRING( &constant_bin[ 45043 ], 49, 0 );
    const_str_digest_e917277f6cb7db604adcd995cbb75173 = UNSTREAM_STRING( &constant_bin[ 45092 ], 88, 0 );
    const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple = PyTuple_New( 1 );
    const_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5 = UNSTREAM_STRING( &constant_bin[ 45180 ], 17, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple, 0, const_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5 ); Py_INCREF( const_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5 );
    const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    const_str_plain_formatString = UNSTREAM_STRING( &constant_bin[ 45197 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 3, const_str_plain_formatString ); Py_INCREF( const_str_plain_formatString );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 4, const_str_plain_hpr ); Py_INCREF( const_str_plain_hpr );
    const_str_plain_otherString = UNSTREAM_STRING( &constant_bin[ 45209 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 5, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_str_digest_8539abab90e32d39166e1ee2cfc4d229 = UNSTREAM_STRING( &constant_bin[ 45220 ], 10, 0 );
    const_str_digest_cb55be559bd21b2bb4f7207654f14aea = UNSTREAM_STRING( &constant_bin[ 45230 ], 8, 0 );
    const_str_plain_posQuatInterval = UNSTREAM_STRING( &constant_bin[ 1490 ], 15, 1 );
    const_str_plain_hprScaleInterval = UNSTREAM_STRING( &constant_bin[ 1527 ], 16, 1 );
    const_str_plain_oy = UNSTREAM_STRING( &constant_bin[ 43974 ], 2, 1 );
    const_str_plain_oz = UNSTREAM_STRING( &constant_bin[ 45238 ], 2, 1 );
    const_str_plain_hasHpr = UNSTREAM_STRING( &constant_bin[ 45240 ], 6, 1 );
    const_str_plain_dy = UNSTREAM_STRING( &constant_bin[ 10196 ], 2, 1 );
    const_str_plain_dx = UNSTREAM_STRING( &constant_bin[ 45246 ], 2, 1 );
    const_str_digest_34ada3e127fd4d1d9399238e854e0384 = UNSTREAM_STRING( &constant_bin[ 45248 ], 47, 0 );
    const_str_plain_colorInterval = UNSTREAM_STRING( &constant_bin[ 1780 ], 13, 1 );
    const_str_plain_fmtStr = UNSTREAM_STRING( &constant_bin[ 45295 ], 6, 1 );
    const_str_plain_subdivideCollisions = UNSTREAM_STRING( &constant_bin[ 2099 ], 19, 1 );
    const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, const_str_plain_args ); Py_INCREF( const_str_plain_args );
    PyTuple_SET_ITEM( const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 2, const_str_plain_kw ); Py_INCREF( const_str_plain_kw );
    PyTuple_SET_ITEM( const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 3, const_str_plain_LerpInterval ); Py_INCREF( const_str_plain_LerpInterval );
    const_str_plain_colNp = UNSTREAM_STRING( &constant_bin[ 45301 ], 5, 1 );
    const_tuple_str_plain_MultitexReducer_tuple = PyTuple_New( 1 );
    const_str_plain_MultitexReducer = UNSTREAM_STRING( &constant_bin[ 45306 ], 15, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_MultitexReducer_tuple, 0, const_str_plain_MultitexReducer ); Py_INCREF( const_str_plain_MultitexReducer );
    const_str_plain_getNumPaths = UNSTREAM_STRING( &constant_bin[ 45321 ], 11, 1 );
    const_str_digest_73fa360419110f5e7e11bd2f92e1c0ad = UNSTREAM_STRING( &constant_bin[ 45332 ], 11, 0 );
    const_str_digest_5475c93c31866a42dfb5b7fbdfa9607b = UNSTREAM_STRING( &constant_bin[ 45343 ], 22, 0 );
    const_str_digest_1b278c87e5956d0815aacacaa6122dce = UNSTREAM_STRING( &constant_bin[ 45365 ], 17, 0 );
    const_str_digest_503cbb628f4ae47a725b7c360e49319f = UNSTREAM_STRING( &constant_bin[ 45382 ], 34, 0 );
    const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple = PyTuple_New( 4 );
    PyTuple_SET_ITEM( const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple, 1, const_str_plain_cb ); Py_INCREF( const_str_plain_cb );
    PyTuple_SET_ITEM( const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple, 2, const_str_plain_importlib ); Py_INCREF( const_str_plain_importlib );
    const_str_plain_Slider = UNSTREAM_STRING( &constant_bin[ 45416 ], 6, 1 );
    PyTuple_SET_ITEM( const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple, 3, const_str_plain_Slider ); Py_INCREF( const_str_plain_Slider );
    const_str_plain_getKey = UNSTREAM_STRING( &constant_bin[ 45422 ], 6, 1 );
    const_str_digest_97d172f6b9adf5324941d1e6dd22a0d3 = UNSTREAM_STRING( &constant_bin[ 45428 ], 44, 0 );
    const_str_digest_49ae60eddca40526491e8bdd07022c60 = UNSTREAM_STRING( &constant_bin[ 45472 ], 92, 0 );
    const_tuple_str_digest_3fb30edff6bdd123d0f703659311cfbc_tuple = PyTuple_New( 1 );
    const_str_digest_3fb30edff6bdd123d0f703659311cfbc = UNSTREAM_STRING( &constant_bin[ 45564 ], 23, 0 );
    PyTuple_SET_ITEM( const_tuple_str_digest_3fb30edff6bdd123d0f703659311cfbc_tuple, 0, const_str_digest_3fb30edff6bdd123d0f703659311cfbc ); Py_INCREF( const_str_digest_3fb30edff6bdd123d0f703659311cfbc );
    const_str_plain_setLodMode = UNSTREAM_STRING( &constant_bin[ 45587 ], 10, 1 );
    const_str_plain_attachCollisionSphere = UNSTREAM_STRING( &constant_bin[ 1855 ], 21, 1 );
    const_str_plain_place = UNSTREAM_STRING( &constant_bin[ 1084 ], 5, 1 );
    const_tuple_str_plain_CollisionSegment_tuple = PyTuple_New( 1 );
    const_str_plain_CollisionSegment = UNSTREAM_STRING( &constant_bin[ 1904 ], 16, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CollisionSegment_tuple, 0, const_str_plain_CollisionSegment ); Py_INCREF( const_str_plain_CollisionSegment );
    const_str_digest_095507e151ec3e28c10d55b825eb29fc = UNSTREAM_STRING( &constant_bin[ 45597 ], 34, 0 );
    const_str_digest_bc0e80cd2cccb41242a91323ec48d3fa = UNSTREAM_STRING( &constant_bin[ 45631 ], 42, 0 );
    const_str_digest_20a2483b2157cbd98f585f6b4e968f97 = UNSTREAM_STRING( &constant_bin[ 45673 ], 61, 0 );
    const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 3, const_str_plain_formatString ); Py_INCREF( const_str_plain_formatString );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 4, const_str_plain_pos ); Py_INCREF( const_str_plain_pos );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 5, const_str_plain_hpr ); Py_INCREF( const_str_plain_hpr );
    PyTuple_SET_ITEM( const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 6, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_str_plain_SceneGraphExplorer = UNSTREAM_STRING( &constant_bin[ 44965 ], 18, 1 );
    const_tuple_none_int_pos_2_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2_tuple, 1, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    const_str_digest_992342804c63488bb7dc99bf40bab416 = UNSTREAM_STRING( &constant_bin[ 45734 ], 40, 0 );
    const_tuple_str_plain_Vec3_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_Vec3_tuple, 0, const_str_plain_Vec3 ); Py_INCREF( const_str_plain_Vec3 );
    const_str_plain_printHpr = UNSTREAM_STRING( &constant_bin[ 772 ], 8, 1 );
    const_str_plain_getNumLodNodes = UNSTREAM_STRING( &constant_bin[ 45774 ], 14, 1 );
    const_str_digest_2aaa28b3d493cec16afb02e4ee05025c = UNSTREAM_STRING( &constant_bin[ 45788 ], 45, 0 );
    const_str_digest_76da864eb1584fe789e5ec7b9c456e6a = UNSTREAM_STRING( &constant_bin[ 45833 ], 66, 0 );
    const_tuple_57312349eaa3be47c249779d3d87b682_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 3, const_str_plain_formatString ); Py_INCREF( const_str_plain_formatString );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 4, const_str_plain_pos ); Py_INCREF( const_str_plain_pos );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 5, const_str_plain_hpr ); Py_INCREF( const_str_plain_hpr );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 6, const_str_plain_scale ); Py_INCREF( const_str_plain_scale );
    PyTuple_SET_ITEM( const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 7, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_str_plain_stateFrom = UNSTREAM_STRING( &constant_bin[ 45899 ], 9, 1 );
    const_str_digest_b2b98b498f6c9bc6671ffae896e8f53b = UNSTREAM_STRING( &constant_bin[ 45908 ], 52, 0 );
    const_str_plain_scaleInterval = UNSTREAM_STRING( &constant_bin[ 1384 ], 13, 1 );
    const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 1, const_str_plain_ancestors ); Py_INCREF( const_str_plain_ancestors );
    const_str_plain_ancestry = UNSTREAM_STRING( &constant_bin[ 45960 ], 8, 1 );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 2, const_str_plain_ancestry ); Py_INCREF( const_str_plain_ancestry );
    const_str_plain_indentString = UNSTREAM_STRING( &constant_bin[ 45968 ], 12, 1 );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 3, const_str_plain_indentString ); Py_INCREF( const_str_plain_indentString );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 4, const_str_plain_nodePath ); Py_INCREF( const_str_plain_nodePath );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 5, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 6, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_colNps = UNSTREAM_STRING( &constant_bin[ 45980 ], 6, 1 );
    const_str_plain_colorScaleInterval = UNSTREAM_STRING( &constant_bin[ 1815 ], 18, 1 );
    const_str_digest_c3e7ebff48fc83a1a43b8f8eedbad5fb = UNSTREAM_STRING( &constant_bin[ 45986 ], 53, 0 );
    const_tuple_str_space_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_space_tuple, 0, const_str_space ); Py_INCREF( const_str_space );
    const_str_plain_getAncestors = UNSTREAM_STRING( &constant_bin[ 46039 ], 12, 1 );
    const_str_plain_quatInterval = UNSTREAM_STRING( &constant_bin[ 1350 ], 12, 1 );
    const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 3, const_str_plain_formatString ); Py_INCREF( const_str_plain_formatString );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 4, const_str_plain_scale ); Py_INCREF( const_str_plain_scale );
    PyTuple_SET_ITEM( const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 5, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_tuple_none_none_int_0_int_0_none_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_none_none_int_0_int_0_none_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_int_0_int_0_none_tuple, 1, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_none_int_0_int_0_none_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_none_none_int_0_int_0_none_tuple, 3, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_none_none_int_0_int_0_none_tuple, 4, Py_None ); Py_INCREF( Py_None );
    const_str_digest_9b9d92dce635694dfeae541eca84ac72 = UNSTREAM_STRING( &constant_bin[ 46051 ], 291, 0 );
    const_str_digest_3bff77c337e9ced759045bfa6af9fd7a = UNSTREAM_STRING( &constant_bin[ 46342 ], 52, 0 );
    const_str_digest_20cc24bb99251993826a0b06bd8fb28e = UNSTREAM_STRING( &constant_bin[ 46394 ], 7, 0 );
    const_str_digest_9b1387bcbe22a7a3a9dfe8973569fbd2 = UNSTREAM_STRING( &constant_bin[ 46401 ], 47, 0 );
    const_str_plain_lsNamesRecurse = UNSTREAM_STRING( &constant_bin[ 603 ], 14, 1 );
    const_str_plain_hideCS = UNSTREAM_STRING( &constant_bin[ 1256 ], 6, 1 );
    const_str_plain_Placer = UNSTREAM_STRING( &constant_bin[ 45359 ], 6, 1 );
    const_str_digest_9636692118d6ae60d387de5cf6ee2550 = UNSTREAM_STRING( &constant_bin[ 46448 ], 67, 0 );
    const_str_digest_e43f9e9dfaa37742a036468e70e7d9ad = UNSTREAM_STRING( &constant_bin[ 46515 ], 187, 0 );
    const_str_plain_posQuatScaleInterval = UNSTREAM_STRING( &constant_bin[ 1645 ], 20, 1 );
    const_tuple_a435b88495307eb9936b0082ce374ad6_tuple = PyTuple_New( 8 );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 1, const_str_plain_stateFrom ); Py_INCREF( const_str_plain_stateFrom );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 2, const_str_plain_target ); Py_INCREF( const_str_plain_target );
    const_str_plain_useGeom = UNSTREAM_STRING( &constant_bin[ 46702 ], 7, 1 );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 3, const_str_plain_useGeom ); Py_INCREF( const_str_plain_useGeom );
    const_str_plain_allowTexMat = UNSTREAM_STRING( &constant_bin[ 46709 ], 11, 1 );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 4, const_str_plain_allowTexMat ); Py_INCREF( const_str_plain_allowTexMat );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 5, const_str_plain_win ); Py_INCREF( const_str_plain_win );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 6, const_str_plain_MultitexReducer ); Py_INCREF( const_str_plain_MultitexReducer );
    const_str_plain_mr = UNSTREAM_STRING( &constant_bin[ 46720 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 7, const_str_plain_mr ); Py_INCREF( const_str_plain_mr );
    const_str_digest_ee238700af53818c4ed331ccfcb75d41 = UNSTREAM_STRING( &constant_bin[ 24774 ], 3, 0 );
    const_str_digest_dc8ebf821d0ec8a379e0623265c69bad = UNSTREAM_STRING( &constant_bin[ 46722 ], 89, 0 );
    const_str_digest_053e5e3bfa671cc09bbbfe2a7d1da46c = UNSTREAM_STRING( &constant_bin[ 46811 ], 30, 0 );
    const_tuple_none_int_pos_2_int_0_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2_int_0_tuple, 0, Py_None ); Py_INCREF( Py_None );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2_int_0_tuple, 1, const_int_pos_2 ); Py_INCREF( const_int_pos_2 );
    PyTuple_SET_ITEM( const_tuple_none_int_pos_2_int_0_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_plain_printScale = UNSTREAM_STRING( &constant_bin[ 802 ], 10, 1 );
    const_str_digest_bd96532d176388ff9d8ae80995aefb1a = UNSTREAM_STRING( &constant_bin[ 46841 ], 30, 0 );
    const_str_plain_r_subdivideCollisions = UNSTREAM_STRING( &constant_bin[ 2140 ], 21, 1 );
    const_dict_55b580ba8802a2d7adcd3895d0c5b8d9 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_55b580ba8802a2d7adcd3895d0c5b8d9, const_str_plain_fWantTk, const_int_0 );
    assert( PyDict_Size( const_dict_55b580ba8802a2d7adcd3895d0c5b8d9 ) == 1 );
    const_str_plain_printPos = UNSTREAM_STRING( &constant_bin[ 742 ], 8, 1 );
    const_str_digest_7562d3a4d5354201304f36f42e3a0f01 = UNSTREAM_STRING( &constant_bin[ 46871 ], 7, 0 );
    const_str_digest_2fbcad0fe537265b904c373a7885697a = UNSTREAM_STRING( &constant_bin[ 46878 ], 13, 0 );
    const_str_plain_getUniformScale = UNSTREAM_STRING( &constant_bin[ 46891 ], 15, 1 );
    const_str_digest_2f9b549ac2e6176a73d3747b50505803 = UNSTREAM_STRING( &constant_bin[ 46906 ], 42, 0 );
    const_str_plain_getSolid = UNSTREAM_STRING( &constant_bin[ 46948 ], 8, 1 );
    const_str_digest_e1d499a078ec1d220d93fb06f682d214 = UNSTREAM_STRING( &constant_bin[ 46956 ], 54, 0 );
    const_str_digest_0dfcaf48daceb4bbbd511004ff22d2e1 = UNSTREAM_STRING( &constant_bin[ 47010 ], 15, 0 );
    const_str_digest_61b9ebff752ab039660c3b1eb14c85ba = UNSTREAM_STRING( &constant_bin[ 47025 ], 74, 0 );
    const_str_plain_posHprScaleShearInterval = UNSTREAM_STRING( &constant_bin[ 1687 ], 24, 1 );
    const_str_digest_7996907301bec4877f4d020cf3f44696 = UNSTREAM_STRING( &constant_bin[ 47099 ], 17, 0 );
    const_str_plain_iScale = UNSTREAM_STRING( &constant_bin[ 993 ], 6, 1 );
    const_str_digest_7008f8eb1ab08ab901bff06d4f36aa5c = UNSTREAM_STRING( &constant_bin[ 47116 ], 51, 0 );
    const_str_digest_ab62dd0d26391f0d1f3fa85284b2e0ca = UNSTREAM_STRING( &constant_bin[ 47167 ], 16, 0 );
    const_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e = UNSTREAM_STRING( &constant_bin[ 11359 ], 2, 0 );
    const_tuple_505bb195ca4da0f448d5830740c25309_tuple = PyTuple_New( 13 );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    const_str_plain_fRecursive = UNSTREAM_STRING( &constant_bin[ 47183 ], 10, 1 );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 3, const_str_plain_fRecursive ); Py_INCREF( const_str_plain_fRecursive );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 4, const_str_plain_Vec3 ); Py_INCREF( const_str_plain_Vec3 );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 5, const_str_plain_fmtStr ); Py_INCREF( const_str_plain_fmtStr );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 6, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 7, const_str_plain_transform ); Py_INCREF( const_str_plain_transform );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 8, const_str_plain_pos ); Py_INCREF( const_str_plain_pos );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 9, const_str_plain_outputString ); Py_INCREF( const_str_plain_outputString );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 10, const_str_plain_hpr ); Py_INCREF( const_str_plain_hpr );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 11, const_str_plain_scale ); Py_INCREF( const_str_plain_scale );
    PyTuple_SET_ITEM( const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 12, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    const_str_digest_afc53e5a5c9626f0b132417ffd0373cd = UNSTREAM_STRING( &constant_bin[ 47193 ], 44, 0 );
    const_str_plain_numSolids = UNSTREAM_STRING( &constant_bin[ 47237 ], 9, 1 );
    const_str_digest_77e9c17b462a3d9a8f3d88de94cab242 = UNSTREAM_STRING( &constant_bin[ 47246 ], 8, 0 );
    const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 1, const_str_plain_indentString ); Py_INCREF( const_str_plain_indentString );
    PyTuple_SET_ITEM( const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 2, const_str_plain_nodePath ); Py_INCREF( const_str_plain_nodePath );
    PyTuple_SET_ITEM( const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 3, const_str_plain_type ); Py_INCREF( const_str_plain_type );
    PyTuple_SET_ITEM( const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 4, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_digest_97e8dda8bf2e2fec759c98598bae2ac3 = UNSTREAM_STRING( &constant_bin[ 47254 ], 47, 0 );
    const_str_digest_1534cb090b59d6ea78e080c0a531f66c = UNSTREAM_STRING( &constant_bin[ 47301 ], 50, 0 );
    const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple = PyTuple_New( 15 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    const_str_plain_ax = UNSTREAM_STRING( &constant_bin[ 42288 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 2, const_str_plain_ax ); Py_INCREF( const_str_plain_ax );
    const_str_plain_ay = UNSTREAM_STRING( &constant_bin[ 34 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 3, const_str_plain_ay ); Py_INCREF( const_str_plain_ay );
    const_str_plain_az = UNSTREAM_STRING( &constant_bin[ 47351 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 4, const_str_plain_az ); Py_INCREF( const_str_plain_az );
    const_str_plain_bx = UNSTREAM_STRING( &constant_bin[ 47353 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 5, const_str_plain_bx ); Py_INCREF( const_str_plain_bx );
    const_str_plain_by = UNSTREAM_STRING( &constant_bin[ 8480 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 6, const_str_plain_by ); Py_INCREF( const_str_plain_by );
    const_str_plain_bz = UNSTREAM_STRING( &constant_bin[ 47355 ], 2, 1 );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 7, const_str_plain_bz ); Py_INCREF( const_str_plain_bz );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 8, const_str_plain_fromCollide ); Py_INCREF( const_str_plain_fromCollide );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 9, const_str_plain_intoCollide ); Py_INCREF( const_str_plain_intoCollide );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 10, const_str_plain_CollisionSegment ); Py_INCREF( const_str_plain_CollisionSegment );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 11, const_str_plain_CollisionNode ); Py_INCREF( const_str_plain_CollisionNode );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 12, const_str_plain_coll ); Py_INCREF( const_str_plain_coll );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 13, const_str_plain_collNode ); Py_INCREF( const_str_plain_collNode );
    PyTuple_SET_ITEM( const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 14, const_str_plain_collNodePath ); Py_INCREF( const_str_plain_collNodePath );
    const_str_digest_f40118032477fce3c42a75520e50ad50 = UNSTREAM_STRING( &constant_bin[ 47357 ], 17, 0 );
    const_str_plain_printPosHprScale = UNSTREAM_STRING( &constant_bin[ 867 ], 16, 1 );
    const_tuple_str_plain_self_str_plain_sib_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_sib_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    const_str_plain_sib = UNSTREAM_STRING( &constant_bin[ 12962 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_sib_tuple, 1, const_str_plain_sib ); Py_INCREF( const_str_plain_sib );
    const_str_plain_getNumDescendants = UNSTREAM_STRING( &constant_bin[ 2019 ], 17, 1 );
    const_str_plain_printPosHpr = UNSTREAM_STRING( &constant_bin[ 834 ], 11, 1 );
    const_str_plain_setUseGeom = UNSTREAM_STRING( &constant_bin[ 47374 ], 10, 1 );
    const_str_plain_r_constructCollisionTree = UNSTREAM_STRING( &constant_bin[ 2183 ], 24, 1 );
    const_str_digest_c32947a023738e64a068931829c2cbe7 = UNSTREAM_STRING( &constant_bin[ 47384 ], 87, 0 );
    const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple, 1, const_str_plain_stack ); Py_INCREF( const_str_plain_stack );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple, 2, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    const_str_plain_getNumSolids = UNSTREAM_STRING( &constant_bin[ 47471 ], 12, 1 );
    const_str_plain_setAllowTexMat = UNSTREAM_STRING( &constant_bin[ 47483 ], 14, 1 );
    const_str_plain_dz = UNSTREAM_STRING( &constant_bin[ 47497 ], 2, 1 );
    const_str_digest_bbe0d8d2767726e357eab3b3c0fd9bd1 = UNSTREAM_STRING( &constant_bin[ 47499 ], 72, 0 );
    const_str_digest_2d6f8042b6a48948b99a4fe55a6dd148 = UNSTREAM_STRING( &constant_bin[ 47571 ], 89, 0 );
    const_str_plain_getChildrenAsList = UNSTREAM_STRING( &constant_bin[ 268 ], 17, 1 );
    const_str_plain_flatten = UNSTREAM_STRING( &constant_bin[ 1982 ], 7, 1 );
    const_str_plain_analyze = UNSTREAM_STRING( &constant_bin[ 2229 ], 7, 1 );
    const_str_digest_91640840388c643d3b01f90ede98717d = UNSTREAM_STRING( &constant_bin[ 47660 ], 48, 0 );
    const_tuple_str_plain_CollisionRay_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CollisionRay_tuple, 0, const_str_plain_CollisionRay ); Py_INCREF( const_str_plain_CollisionRay );
    const_str_plain_hideSiblings = UNSTREAM_STRING( &constant_bin[ 443 ], 12, 1 );
    const_tuple_str_plain_LerpInterval_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_LerpInterval_tuple, 0, const_str_plain_LerpInterval ); Py_INCREF( const_str_plain_LerpInterval );
    const_str_plain_rgbPanel = UNSTREAM_STRING( &constant_bin[ 1140 ], 8, 1 );
    const_str_plain_scan = UNSTREAM_STRING( &constant_bin[ 47708 ], 4, 1 );
    const_tuple_str_plain_CollisionSphere_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CollisionSphere_tuple, 0, const_str_plain_CollisionSphere ); Py_INCREF( const_str_plain_CollisionSphere );
    const_str_plain_solids = UNSTREAM_STRING( &constant_bin[ 46100 ], 6, 1 );
    const_tuple_str_plain_self_str_plain_child_tuple = PyTuple_New( 2 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_child_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_child_tuple, 1, const_str_plain_child ); Py_INCREF( const_str_plain_child );
    const_str_digest_f43d5851181b239a5955f5f4ab670845 = UNSTREAM_STRING( &constant_bin[ 47712 ], 297, 0 );
    const_str_plain_posHprScaleInterval = UNSTREAM_STRING( &constant_bin[ 1604 ], 19, 1 );
    const_str_digest_a8d65c3d3b507677d22784985ff6542a = UNSTREAM_STRING( &constant_bin[ 48009 ], 21, 0 );
    const_str_digest_3538967cd056504ea8299e4ed627b926 = UNSTREAM_STRING( &constant_bin[ 48030 ], 53, 0 );
    const_str_digest_53bc5171cf67f03e6360b218341ac9ed = UNSTREAM_STRING( &constant_bin[ 48083 ], 89, 0 );
    const_str_plain_hprInterval = UNSTREAM_STRING( &constant_bin[ 1317 ], 11, 1 );
    const_tuple_str_digest_e5a70be140fb2f14027ecfb7aa572fac_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_e5a70be140fb2f14027ecfb7aa572fac_tuple, 0, const_str_digest_e5a70be140fb2f14027ecfb7aa572fac ); Py_INCREF( const_str_digest_e5a70be140fb2f14027ecfb7aa572fac );
    const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple = PyTuple_New( 5 );
    PyTuple_SET_ITEM( const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 1, const_str_plain_mask ); Py_INCREF( const_str_plain_mask );
    const_str_plain_npc = UNSTREAM_STRING( &constant_bin[ 48172 ], 3, 1 );
    PyTuple_SET_ITEM( const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 2, const_str_plain_npc ); Py_INCREF( const_str_plain_npc );
    PyTuple_SET_ITEM( const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 3, const_str_plain_p ); Py_INCREF( const_str_plain_p );
    PyTuple_SET_ITEM( const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 4, const_str_plain_np ); Py_INCREF( const_str_plain_np );
    const_str_plain_LMHighest = UNSTREAM_STRING( &constant_bin[ 48175 ], 9, 1 );
    const_str_digest_699a545b77b3e4ba76f4fb1ce6853c36 = UNSTREAM_STRING( &constant_bin[ 48184 ], 23, 0 );
    const_str_digest_bac08fb81251f0d3f6fdb9de54f05162 = UNSTREAM_STRING( &constant_bin[ 48207 ], 69, 0 );
    const_str_plain_shearInterval = UNSTREAM_STRING( &constant_bin[ 1419 ], 13, 1 );
    const_str_plain_explore = UNSTREAM_STRING( &constant_bin[ 1111 ], 7, 1 );
    const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple, 1, const_str_plain_importlib ); Py_INCREF( const_str_plain_importlib );
    PyTuple_SET_ITEM( const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple, 2, const_str_plain_Placer ); Py_INCREF( const_str_plain_Placer );
    const_str_digest_cfa2cf27cc4cdd2bfc990e4e09a3399e = UNSTREAM_STRING( &constant_bin[ 48276 ], 45, 0 );
    const_str_digest_841c073c60a7d5f21d68b18948e7bd8a = UNSTREAM_STRING( &constant_bin[ 48321 ], 36, 0 );
    const_str_plain_posHprInterval = UNSTREAM_STRING( &constant_bin[ 1454 ], 14, 1 );
    const_str_digest_ba00b854e68e3d31836ee7259fad44c3 = UNSTREAM_STRING( &constant_bin[ 48357 ], 47, 0 );
    const_str_plain_hasScale = UNSTREAM_STRING( &constant_bin[ 48404 ], 8, 1 );
    const_str_digest_11c3b44c13cb5260233013d95d9d6fee = UNSTREAM_STRING( &constant_bin[ 48412 ], 47, 0 );
    const_str_digest_47194625d05e416bab876dcaaafddec7 = UNSTREAM_STRING( &constant_bin[ 48459 ], 283, 0 );
    const_str_plain_pPrintString = UNSTREAM_STRING( &constant_bin[ 708 ], 12, 1 );
    const_tuple_str_digest_5475c93c31866a42dfb5b7fbdfa9607b_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_5475c93c31866a42dfb5b7fbdfa9607b_tuple, 0, const_str_digest_5475c93c31866a42dfb5b7fbdfa9607b ); Py_INCREF( const_str_digest_5475c93c31866a42dfb5b7fbdfa9607b );
    const_str_digest_3022a4824a2c2fe8c6d287d38d814227 = UNSTREAM_STRING( &constant_bin[ 48742 ], 37, 0 );
    const_str_digest_34ed79348cb98bde09a3c57c5890eed0 = UNSTREAM_STRING( &constant_bin[ 8127 ], 2, 0 );
    const_tuple_6f4376fb5b34d101d91f65a28e4174f6_tuple = PyMarshal_ReadObjectFromString( (char *)&constant_bin[ 48779 ], 388 );
    const_str_plain_printTransform = UNSTREAM_STRING( &constant_bin[ 905 ], 14, 1 );
    const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 0, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 3, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 4, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 5, const_int_0 ); Py_INCREF( const_int_0 );
    const_str_digest_eeb948922be95abd991ff245125db928 = UNSTREAM_STRING( &constant_bin[ 49167 ], 15, 0 );
    const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple = PyTuple_New( 3 );
    PyTuple_SET_ITEM( const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple, 1, const_str_plain_importlib ); Py_INCREF( const_str_plain_importlib );
    PyTuple_SET_ITEM( const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple, 2, const_str_plain_SceneGraphExplorer ); Py_INCREF( const_str_plain_SceneGraphExplorer );
    const_str_plain_toggleVis = UNSTREAM_STRING( &constant_bin[ 378 ], 9, 1 );
    const_str_digest_8d4812dee8f3081b71f85da68e87d9e1 = UNSTREAM_STRING( &constant_bin[ 49182 ], 21, 0 );
    const_str_digest_60e8ae5173922e540ddfbff28401f039 = UNSTREAM_STRING( &constant_bin[ 49203 ], 81, 0 );
    const_dict_82438769d4f7f66d5a77a06a04bb40a6 = _PyDict_NewPresized( 1 );
    PyDict_SetItem( const_dict_82438769d4f7f66d5a77a06a04bb40a6, const_str_plain_fWantTk, const_int_pos_1 );
    assert( PyDict_Size( const_dict_82438769d4f7f66d5a77a06a04bb40a6 ) == 1 );
    const_str_plain_getShear = UNSTREAM_STRING( &constant_bin[ 49284 ], 8, 1 );
    const_str_plain_printChildren = UNSTREAM_STRING( &constant_bin[ 307 ], 13, 1 );
    const_str_digest_0c5b0d596a8151bd1f5bf644e10998b9 = UNSTREAM_STRING( &constant_bin[ 49292 ], 45, 0 );
    const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple = PyTuple_New( 6 );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 2, const_str_plain_sd ); Py_INCREF( const_str_plain_sd );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 3, const_str_plain_formatString ); Py_INCREF( const_str_plain_formatString );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 4, const_str_plain_pos ); Py_INCREF( const_str_plain_pos );
    PyTuple_SET_ITEM( const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 5, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_str_plain_numSolidsInLeaves = UNSTREAM_STRING( &constant_bin[ 48809 ], 17, 1 );
    const_str_plain_hasPos = UNSTREAM_STRING( &constant_bin[ 49337 ], 6, 1 );
    const_tuple_240603124997e998fec04bb6b6161143_tuple = PyTuple_New( 10 );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 1, const_str_plain_numSolidsInLeaves ); Py_INCREF( const_str_plain_numSolidsInLeaves );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 2, const_str_plain_colNps ); Py_INCREF( const_str_plain_colNps );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 3, const_str_plain_colNp ); Py_INCREF( const_str_plain_colNp );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 4, const_str_plain_node ); Py_INCREF( const_str_plain_node );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 5, const_str_plain_numSolids ); Py_INCREF( const_str_plain_numSolids );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 6, const_str_plain_solids ); Py_INCREF( const_str_plain_solids );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 7, const_str_plain_i ); Py_INCREF( const_str_plain_i );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 8, const_str_plain_solidTree ); Py_INCREF( const_str_plain_solidTree );
    PyTuple_SET_ITEM( const_tuple_240603124997e998fec04bb6b6161143_tuple, 9, const_str_plain_root ); Py_INCREF( const_str_plain_root );
    const_str_digest_32ad1e41899e662e0ba1996bff7d0a9a = UNSTREAM_STRING( &constant_bin[ 49343 ], 49, 0 );
    const_str_digest_c53ef752a249b2e5a51aa448d57d70d2 = UNSTREAM_STRING( &constant_bin[ 49392 ], 6, 0 );
    const_str_plain_preRemoveNodePath = UNSTREAM_STRING( &constant_bin[ 49398 ], 17, 1 );
    const_tuple_str_plain_CollisionNode_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_CollisionNode_tuple, 0, const_str_plain_CollisionNode ); Py_INCREF( const_str_plain_CollisionNode );
    const_str_plain_quatScaleInterval = UNSTREAM_STRING( &constant_bin[ 1565 ], 17, 1 );
    const_tuple_c73386e0476eb45878e9a64725822b1e_tuple = PyTuple_New( 9 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 0, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 1, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 2, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 3, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 4, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 5, const_int_0 ); Py_INCREF( const_int_0 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 6, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 7, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    PyTuple_SET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 8, const_int_pos_1 ); Py_INCREF( const_int_pos_1 );
    const_str_digest_fc6651ce2bf4c50e0dded358cfe6a5b8 = UNSTREAM_STRING( &constant_bin[ 49415 ], 38, 0 );
    const_str_plain_showSiblings = UNSTREAM_STRING( &constant_bin[ 409 ], 12, 1 );
    const_str_plain_iPosHpr = UNSTREAM_STRING( &constant_bin[ 1021 ], 7, 1 );
    const_str_plain_removeNonCollisions = UNSTREAM_STRING( &constant_bin[ 2058 ], 19, 1 );
    const_str_plain_deselect = UNSTREAM_STRING( &constant_bin[ 1198 ], 8, 1 );
    const_str_digest_9bd659cd284b4488953883e670875e15 = UNSTREAM_STRING( &constant_bin[ 49453 ], 11, 0 );
    const_str_digest_1073b23d348cc8d2dede364119d1b818 = UNSTREAM_STRING( &constant_bin[ 49464 ], 52, 0 );
    const_str_digest_89cbe1136d45e998389d6c3f912bf0b9 = UNSTREAM_STRING( &constant_bin[ 49516 ], 42, 0 );
    const_str_digest_6518dbc5ec2d6f64384b8ab8ad5c320d = UNSTREAM_STRING( &constant_bin[ 49558 ], 70, 0 );
    const_str_plain_posQuatScaleShearInterval = UNSTREAM_STRING( &constant_bin[ 1733 ], 25, 1 );
    const_str_plain_reverseLsNames = UNSTREAM_STRING( &constant_bin[ 639 ], 14, 1 );
    const_str_plain_pPrintValues = UNSTREAM_STRING( &constant_bin[ 49628 ], 12, 1 );
    const_str_digest_5f9809dd4faa2e5c0ee4af9b5bc06f02 = UNSTREAM_STRING( &constant_bin[ 49640 ], 53, 0 );
    const_str_plain_attachCollisionRay = UNSTREAM_STRING( &constant_bin[ 1942 ], 18, 1 );
    const_str_digest_b958960f2fd236679ce319e586eeacf0 = UNSTREAM_STRING( &constant_bin[ 49693 ], 45, 0 );
    const_str_digest_ca942f1abb1ab9e034d34109a7865404 = UNSTREAM_STRING( &constant_bin[ 49738 ], 62, 0 );
    const_str_digest_f9d1ea5b90058e527abc9ac18d067545 = UNSTREAM_STRING( &constant_bin[ 49800 ], 33, 0 );
    const_tuple_str_plain_SceneGraphAnalyzer_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_plain_SceneGraphAnalyzer_tuple, 0, const_str_plain_SceneGraphAnalyzer ); Py_INCREF( const_str_plain_SceneGraphAnalyzer );
    const_str_plain_isolate = UNSTREAM_STRING( &constant_bin[ 517 ], 7, 1 );
    const_str_digest_309d8f9a2a8b5f431567fe03852b19cd = UNSTREAM_STRING( &constant_bin[ 49833 ], 17, 0 );
    const_str_plain_getAncestry = UNSTREAM_STRING( &constant_bin[ 675 ], 11, 1 );
    const_str_plain_removeChildren = UNSTREAM_STRING( &constant_bin[ 342 ], 14, 1 );
    const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple = PyTuple_New( 7 );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 1, const_str_plain_other ); Py_INCREF( const_str_plain_other );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 2, const_str_plain_pos ); Py_INCREF( const_str_plain_pos );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 3, const_str_plain_hpr ); Py_INCREF( const_str_plain_hpr );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 4, const_str_plain_scale ); Py_INCREF( const_str_plain_scale );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 5, const_str_plain_shear ); Py_INCREF( const_str_plain_shear );
    PyTuple_SET_ITEM( const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 6, const_str_plain_otherString ); Py_INCREF( const_str_plain_otherString );
    const_str_plain_iHpr = UNSTREAM_STRING( &constant_bin[ 967 ], 4, 1 );
    const_str_digest_746f609ec37af2b9cd6674c0823bc3f7 = UNSTREAM_STRING( &constant_bin[ 49850 ], 38, 0 );
    const_str_digest_be8949587e5eb5966c8063479c553455 = UNSTREAM_STRING( &constant_bin[ 49888 ], 9, 0 );
    const_tuple_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e_tuple = PyTuple_New( 1 );
    PyTuple_SET_ITEM( const_tuple_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e_tuple, 0, const_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e ); Py_INCREF( const_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e );
    const_str_plain_iPos = UNSTREAM_STRING( &constant_bin[ 941 ], 4, 1 );
    const_str_digest_12c5328130517918ca9d49f0622ada30 = UNSTREAM_STRING( &constant_bin[ 49897 ], 43, 0 );
    const_str_plain_ox = UNSTREAM_STRING( &constant_bin[ 49940 ], 2, 1 );
    const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple = PyTuple_New( 15 );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 0, const_str_plain_self ); Py_INCREF( const_str_plain_self );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 1, const_str_plain_name ); Py_INCREF( const_str_plain_name );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 2, const_str_plain_ox ); Py_INCREF( const_str_plain_ox );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 3, const_str_plain_oy ); Py_INCREF( const_str_plain_oy );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 4, const_str_plain_oz ); Py_INCREF( const_str_plain_oz );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 5, const_str_plain_dx ); Py_INCREF( const_str_plain_dx );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 6, const_str_plain_dy ); Py_INCREF( const_str_plain_dy );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 7, const_str_plain_dz ); Py_INCREF( const_str_plain_dz );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 8, const_str_plain_fromCollide ); Py_INCREF( const_str_plain_fromCollide );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 9, const_str_plain_intoCollide ); Py_INCREF( const_str_plain_intoCollide );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 10, const_str_plain_CollisionRay ); Py_INCREF( const_str_plain_CollisionRay );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 11, const_str_plain_CollisionNode ); Py_INCREF( const_str_plain_CollisionNode );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 12, const_str_plain_coll ); Py_INCREF( const_str_plain_coll );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 13, const_str_plain_collNode ); Py_INCREF( const_str_plain_collNode );
    PyTuple_SET_ITEM( const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 14, const_str_plain_collNodePath ); Py_INCREF( const_str_plain_collNodePath );
    const_str_plain_posInterval = UNSTREAM_STRING( &constant_bin[ 1284 ], 11, 1 );
    const_str_digest_accc6d7f594b841fd4ec537441b97824 = UNSTREAM_STRING( &constant_bin[ 46956 ], 45, 0 );
    const_str_plain_getCollisionOrigin = UNSTREAM_STRING( &constant_bin[ 49942 ], 18, 1 );
    const_str_plain_hasUniformScale = UNSTREAM_STRING( &constant_bin[ 49960 ], 15, 1 );
    const_str_digest_8e6ec66a21e36095d352cc99eb873978 = UNSTREAM_STRING( &constant_bin[ 49975 ], 67, 0 );
    const_str_plain_flattenMultitex = UNSTREAM_STRING( &constant_bin[ 1982 ], 15, 1 );

    constants_created = true;
}

#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_direct$extensions_native$NodePath_extensions( void )
{
    // The module may not have been used at all.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_05b3e2c7f4df2ecef731cec0e57dcc27;
static PyCodeObject *codeobj_f03b83bec65b720707e68bb9d9f7f928;
static PyCodeObject *codeobj_6cefa3a641e11cce6d9dafaf21255680;
static PyCodeObject *codeobj_f6b6e768e97eea8a9d9fd1daf5a5ec04;
static PyCodeObject *codeobj_24d26537227966edb813d67da7e6e214;
static PyCodeObject *codeobj_612efba40b41720fd5ff60f9276db0ce;
static PyCodeObject *codeobj_f50a0450676289b0423260c876009e5f;
static PyCodeObject *codeobj_30e9339eb9718b0bf4ed92e21e17830d;
static PyCodeObject *codeobj_3bc046785039d0c763921969e5abbeb6;
static PyCodeObject *codeobj_1ec8b1703c5ca7d38b5327cb40adc36e;
static PyCodeObject *codeobj_37d493be231c5010b970ce6276e19603;
static PyCodeObject *codeobj_f20eb553132f70591ac6f09348b76083;
static PyCodeObject *codeobj_dacf8d19a45379c1a042d986d0d4159e;
static PyCodeObject *codeobj_a6e51965cda121fb0a19a2726a47a80d;
static PyCodeObject *codeobj_818cda0c76c6effe914b73b37dcaa240;
static PyCodeObject *codeobj_1546005869a33e57d250c5dc2ce5e9d4;
static PyCodeObject *codeobj_8d4fad2be4e746683e779efc097e6fc6;
static PyCodeObject *codeobj_f8ad8c4d96a1525ce95fbd90ff9951a5;
static PyCodeObject *codeobj_0edc8cacec2283d0259b8c1790b2dac6;
static PyCodeObject *codeobj_7cfe05b9583b06a64e13e7f4a487bdcd;
static PyCodeObject *codeobj_21e5ffbcd83dc3719251a0cc773c4b50;
static PyCodeObject *codeobj_67bdd3356210f8c54f0ce6b2e15719fa;
static PyCodeObject *codeobj_a4a38329bd458a66a6517c3d4782c57a;
static PyCodeObject *codeobj_7c2672539834dd2957cc8a68f41352f1;
static PyCodeObject *codeobj_06a81b72c525dae2f442cc0d66794129;
static PyCodeObject *codeobj_90b5ab8872ab2916e5c87911d8e91f5e;
static PyCodeObject *codeobj_fde9287990a9dab12fd41e019193bedc;
static PyCodeObject *codeobj_ede5eb5c9d547319ad6296a3834aaee2;
static PyCodeObject *codeobj_52d0034855259c50ed78ce646321cc12;
static PyCodeObject *codeobj_ddeedc3bb3e3990af1babf16721bf63c;
static PyCodeObject *codeobj_3d5f2dee7311a69e6ac751e09d7f0f87;
static PyCodeObject *codeobj_f697788ed0cf64090cd6a1600b9becbd;
static PyCodeObject *codeobj_943e96b997a504a7c8581c23be1fa155;
static PyCodeObject *codeobj_8df4f0be86cc851730731fffe3959e9e;
static PyCodeObject *codeobj_64748f9472a2446221cb502039bde3fd;
static PyCodeObject *codeobj_1bb6f852641846ecaa47b620831c0e05;
static PyCodeObject *codeobj_9555320a3f201bb9e8eb1d3aedb3d9e3;
static PyCodeObject *codeobj_ae46e0796f95e234fd8d8691701c5c85;
static PyCodeObject *codeobj_bdabf02f866f906167831c0ba99843d4;
static PyCodeObject *codeobj_72050c740292be6322a3a502126e5e39;
static PyCodeObject *codeobj_1085e04a622479f3d892fba051817853;
static PyCodeObject *codeobj_b66f7e35466ba9337d7dc7e685ead2c7;
static PyCodeObject *codeobj_64986c494f8638acc30b7202cc9d095d;
static PyCodeObject *codeobj_93c57184fdf27ec01488b63785c45257;
static PyCodeObject *codeobj_d9bf6af6c22e015411ad6e2cc98db101;
static PyCodeObject *codeobj_0f643037e6b0a7646115bb655f2d42a1;
static PyCodeObject *codeobj_06a9537ad26ca8b502d78bcb41a911c9;
static PyCodeObject *codeobj_8d5c5ffe3ac136b2bc27338308c8905d;
static PyCodeObject *codeobj_b9b9d7c571a64c8ab56168796d8dcb06;
static PyCodeObject *codeobj_b8dc973a59a525b1d5937ff2ee8b8804;
static PyCodeObject *codeobj_8b01c6b7b0f1a362254e7c72179e70ce;
static PyCodeObject *codeobj_251981d21f0e7ac6a88d29596b2ff1e1;
static PyCodeObject *codeobj_b401191088d960f3ac2fd4aface3a609;
static PyCodeObject *codeobj_3b4e490f7fd3a498f95e88a94688294d;
static PyCodeObject *codeobj_1a445f66eca44998dcb0d5b061eb3036;
static PyCodeObject *codeobj_a82129c14635955c01cfb361d8ca205c;
static PyCodeObject *codeobj_cdca1d9a6df747a6cccd7c5aa1482adb;
static PyCodeObject *codeobj_5e756e83abbf94b405c26bfd697e4eea;
static PyCodeObject *codeobj_ba6cd53fc9b355e90dc863a2acc4d9f1;

static void createModuleCodeObjects(void)
{
    module_filename_obj = MAKE_RELATIVE_PATH( const_str_digest_34ada3e127fd4d1d9399238e854e0384 );
    codeobj_05b3e2c7f4df2ecef731cec0e57dcc27 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_NodePath_extensions, 1, const_tuple_empty, 0, CO_NOFREE );
    codeobj_f03b83bec65b720707e68bb9d9f7f928 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_analyze, 810, const_tuple_bbf28893c64c50b413a9fa68a8dbe0d9_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_6cefa3a641e11cce6d9dafaf21255680 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_attachCollisionRay, 624, const_tuple_74d2a3d49080defcb93a36484def1c9c_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f6b6e768e97eea8a9d9fd1daf5a5ec04 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_attachCollisionSegment, 610, const_tuple_f747ade240b9ce5f2ddcb3e21baccb8e_tuple, 10, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_24d26537227966edb813d67da7e6e214 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_attachCollisionSphere, 596, const_tuple_a343140eeb46a57967d2b2766e4ef3d0_tuple, 8, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_612efba40b41720fd5ff60f9276db0ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_colorInterval, 582, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_f50a0450676289b0423260c876009e5f = MAKE_CODEOBJ( module_filename_obj, const_str_plain_colorScaleInterval, 589, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_30e9339eb9718b0bf4ed92e21e17830d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_deselect, 448, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3bc046785039d0c763921969e5abbeb6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_explore, 419, const_tuple_c873fdb01da2aee57535a258e4f6deeb_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1ec8b1703c5ca7d38b5327cb40adc36e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_flattenMultitex, 638, const_tuple_a435b88495307eb9936b0082ce374ad6_tuple, 6, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_37d493be231c5010b970ce6276e19603 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getAncestry, 156, const_tuple_str_plain_self_str_plain_ancestors_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_f20eb553132f70591ac6f09348b76083 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getChildrenAsList, 23, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_dacf8d19a45379c1a042d986d0d4159e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_getNumDescendants, 658, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a6e51965cda121fb0a19a2726a47a80d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hideCS, 473, const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_818cda0c76c6effe914b73b37dcaa240 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hideSiblings, 72, const_tuple_str_plain_self_str_plain_sib_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1546005869a33e57d250c5dc2ce5e9d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hprInterval, 498, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_8d4fad2be4e746683e779efc097e6fc6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_hprScaleInterval, 540, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_f8ad8c4d96a1525ce95fbd90ff9951a5 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iHpr, 363, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0edc8cacec2283d0259b8c1790b2dac6 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iPos, 352, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7cfe05b9583b06a64e13e7f4a487bdcd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iPosHpr, 385, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_21e5ffbcd83dc3719251a0cc773c4b50 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iPosHprScale, 396, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_67bdd3356210f8c54f0ce6b2e15719fa = MAKE_CODEOBJ( module_filename_obj, const_str_plain_iScale, 374, const_tuple_str_plain_self_str_plain_other_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a4a38329bd458a66a6517c3d4782c57a = MAKE_CODEOBJ( module_filename_obj, const_str_plain_id, 15, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_7c2672539834dd2957cc8a68f41352f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_isolate, 92, const_tuple_str_plain_self_str_plain_sib_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_06a81b72c525dae2f442cc0d66794129 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_lsNames, 115, const_tuple_str_plain_self_str_plain_type_str_plain_name_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_90b5ab8872ab2916e5c87911d8e91f5e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_lsNamesRecurse, 129, const_tuple_f866bbff2e56308e29e0fa8925b5b49b_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_fde9287990a9dab12fd41e019193bedc = MAKE_CODEOBJ( module_filename_obj, const_str_plain_pPrintString, 167, const_tuple_43d6f48dfcca1cd1e63999dc96c0e4cc_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ede5eb5c9d547319ad6296a3834aaee2 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_place, 408, const_tuple_str_plain_self_str_plain_importlib_str_plain_Placer_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_52d0034855259c50ed78ce646321cc12 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posHprInterval, 526, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_ddeedc3bb3e3990af1babf16721bf63c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posHprScaleInterval, 554, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_3d5f2dee7311a69e6ac751e09d7f0f87 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posHprScaleShearInterval, 568, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_f697788ed0cf64090cd6a1600b9becbd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posInterval, 491, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_943e96b997a504a7c8581c23be1fa155 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posQuatInterval, 533, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_8df4f0be86cc851730731fffe3959e9e = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posQuatScaleInterval, 561, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_64748f9472a2446221cb502039bde3fd = MAKE_CODEOBJ( module_filename_obj, const_str_plain_posQuatScaleShearInterval, 575, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_1bb6f852641846ecaa47b620831c0e05 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printChildren, 32, const_tuple_str_plain_self_str_plain_child_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_9555320a3f201bb9e8eb1d3aedb3d9e3 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printHpr, 220, const_tuple_281af6d9049c8609e06c0fc0fd189209_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ae46e0796f95e234fd8d8691701c5c85 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printPos, 201, const_tuple_a9d9fe687ef5eb6a49faf1cc9b1cd200_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_bdabf02f866f906167831c0ba99843d4 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printPosHpr, 258, const_tuple_1351236f881a51dfb8c39f6ed0d8a27a_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_72050c740292be6322a3a502126e5e39 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printPosHprScale, 282, const_tuple_57312349eaa3be47c249779d3d87b682_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_1085e04a622479f3d892fba051817853 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printScale, 239, const_tuple_27f50033bd7f2eef4237c2167c2ca2d4_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b66f7e35466ba9337d7dc7e685ead2c7 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_printTransform, 312, const_tuple_505bb195ca4da0f448d5830740c25309_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_64986c494f8638acc30b7202cc9d095d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_quatInterval, 505, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_93c57184fdf27ec01488b63785c45257 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_quatScaleInterval, 547, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_d9bf6af6c22e015411ad6e2cc98db101 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_r_constructCollisionTree, 791, const_tuple_436a796891a2adad89e8bc2df2bc7f9c_tuple, 4, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_0f643037e6b0a7646115bb655f2d42a1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_r_subdivideCollisions, 701, const_tuple_6f4376fb5b34d101d91f65a28e4174f6_tuple, 3, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_06a9537ad26ca8b502d78bcb41a911c9 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_remove, 103, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8d5c5ffe3ac136b2bc27338308c8905d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeChildren, 41, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b9b9d7c571a64c8ab56168796d8dcb06 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_removeNonCollisions, 663, const_tuple_str_plain_self_str_plain_stack_str_plain_np_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_b8dc973a59a525b1d5937ff2ee8b8804 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_reverseLsNames, 141, const_tuple_9d1e56c72b1195025ceb40a612a051d3_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_8b01c6b7b0f1a362254e7c72179e70ce = MAKE_CODEOBJ( module_filename_obj, const_str_plain_rgbPanel, 430, const_tuple_91b46fd868f6a89bff8f5abcca72d4b7_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_251981d21f0e7ac6a88d29596b2ff1e1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_scaleInterval, 512, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_b401191088d960f3ac2fd4aface3a609 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_select, 441, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_3b4e490f7fd3a498f95e88a94688294d = MAKE_CODEOBJ( module_filename_obj, const_str_plain_shearInterval, 519, const_tuple_a0f4ffb6dbc14ca9bd2ee0909015eb72_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARARGS | CO_VARKEYWORDS | CO_NOFREE );
    codeobj_1a445f66eca44998dcb0d5b061eb3036 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_showAllDescendants, 82, const_tuple_str_plain_self_str_plain_child_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_a82129c14635955c01cfb361d8ca205c = MAKE_CODEOBJ( module_filename_obj, const_str_plain_showCS, 455, const_tuple_d64dfdb9b95a25568d0185520916c66c_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_cdca1d9a6df747a6cccd7c5aa1482adb = MAKE_CODEOBJ( module_filename_obj, const_str_plain_showSiblings, 62, const_tuple_str_plain_self_str_plain_sib_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_5e756e83abbf94b405c26bfd697e4eea = MAKE_CODEOBJ( module_filename_obj, const_str_plain_subdivideCollisions, 678, const_tuple_240603124997e998fec04bb6b6161143_tuple, 2, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
    codeobj_ba6cd53fc9b355e90dc863a2acc4d9f1 = MAKE_CODEOBJ( module_filename_obj, const_str_plain_toggleVis, 49, const_tuple_str_plain_self_tuple, 1, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE );
}

// The module function declarations.
NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( PyObject **python_pars );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_10_remove(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_11_lsNames(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_14_getAncestry(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_15_pPrintString( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_16_printPos( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_17_printHpr( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_18_printScale( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_1_id(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_21_printTransform( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_22_iPos( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_23_iHpr( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_24_iScale( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_27_place(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_28_explore(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_30_select(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_31_deselect(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_32_showCS( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_33_hideCS( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_34_posInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_35_hprInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_36_quatInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_38_shearInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_3_printChildren(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_47_colorInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_4_removeChildren(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex( PyObject *defaults );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_58_analyze(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_5_toggleVis(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_6_showSiblings(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants(  );


static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_9_isolate(  );


// The module function definitions.
static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_1_id( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a4a38329bd458a66a6517c3d4782c57a, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_e917277f6cb7db604adcd995cbb75173;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 17;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 18;
    tmp_return_value = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getKey );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 18;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_1_id );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_1_id );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f20eb553132f70591ac6f09348b76083, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_60e8ae5173922e540ddfbff28401f039;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 25;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 25;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 26;
    tmp_list_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getChildren );
    if ( tmp_list_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_return_value = PySequence_List( tmp_list_arg_1 );
    Py_DECREF( tmp_list_arg_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 26;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_3_printChildren( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1bb6f852641846ecaa47b620831c0e05, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_91640840388c643d3b01f90ede98717d;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 34;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 35;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getChildren );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            frame_function->m_frame.f_lineno = 35;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_child;
        var_child = tmp_assign_source_3;
        Py_INCREF( var_child );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = var_child;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 36;
    tmp_print_value = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 36;
        type_description = "oo";
        goto try_except_handler_2;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 36;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 36;
        type_description = "oo";
        goto try_except_handler_2;
    }
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 35;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_child );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_3_printChildren );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_3_printChildren );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_4_removeChildren( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8d5c5ffe3ac136b2bc27338308c8905d, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_c32947a023738e64a068931829c2cbe7;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 43;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 43;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 44;
    tmp_called_instance_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getChildren );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 44;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 44;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_detach );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 44;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_4_removeChildren );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_4_removeChildren );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_5_toggleVis( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ba6cd53fc9b355e90dc863a2acc4d9f1, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_53bc5171cf67f03e6360b218341ac9ed;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 51;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 52;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isHidden );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 52;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 52;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 53;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_show );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 53;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_pos_1;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 56;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_hide );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 56;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_return_value = const_int_0;
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_5_toggleVis );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_5_toggleVis );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_6_showSiblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_sib = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_cdca1d9a6df747a6cccd7c5aa1482adb, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_ba00b854e68e3d31836ee7259fad44c3;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 64;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 64;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 65;
    tmp_called_instance_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getParent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 65;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getChildren );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            frame_function->m_frame.f_lineno = 65;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_sib;
        var_sib = tmp_assign_source_3;
        Py_INCREF( var_sib );
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = var_sib;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 66;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_node );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 66;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 66;
    tmp_compare_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_node );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 66;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 66;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_5 = var_sib;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 67;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_show );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 67;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 65;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_sib );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_6_showSiblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_6_showSiblings );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_sib = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_818cda0c76c6effe914b73b37dcaa240, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_11c3b44c13cb5260233013d95d9d6fee;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 74;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 74;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 75;
    tmp_called_instance_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getParent );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 75;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getChildren );
    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            frame_function->m_frame.f_lineno = 75;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_sib;
        var_sib = tmp_assign_source_3;
        Py_INCREF( var_sib );
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = var_sib;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 76;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_node );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 76;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 76;
    tmp_compare_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_node );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 76;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 76;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_5 = var_sib;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 77;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_hide );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 77;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 75;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_sib );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1a445f66eca44998dcb0d5b061eb3036, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_3538967cd056504ea8299e4ed627b926;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 84;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 85;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_show );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 85;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 86;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getChildren );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            frame_function->m_frame.f_lineno = 86;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_child;
        var_child = tmp_assign_source_3;
        Py_INCREF( var_child );
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = var_child;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 87;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_showAllDescendants );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 87;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 86;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_child );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_9_isolate( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_sib = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7c2672539834dd2957cc8a68f41352f1, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_89cbe1136d45e998389d6c3f912bf0b9;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 94;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 94;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 95;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_showAllDescendants );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 95;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 96;
    tmp_called_instance_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getParent );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 96;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getChildren );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oo";
            frame_function->m_frame.f_lineno = 96;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_sib;
        var_sib = tmp_assign_source_3;
        Py_INCREF( var_sib );
        Py_XDECREF( old );
    }

    tmp_called_instance_4 = var_sib;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 97;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_node );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 97;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 97;
    tmp_compare_right_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_node );
    if ( tmp_compare_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 97;
        type_description = "oo";
        goto try_except_handler_2;
    }
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );
        Py_DECREF( tmp_compare_right_1 );

        exception_lineno = 97;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    Py_DECREF( tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_6 = var_sib;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 98;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_hide );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 98;
        type_description = "oo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 96;
        type_description = "oo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_sib );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_9_isolate );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_sib );
    var_sib = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_9_isolate );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_10_remove( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_list_element_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_06a9537ad26ca8b502d78bcb41a911c9, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_bac08fb81251f0d3f6fdb9de54f05162;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 105;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 105;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_messenger );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_messenger );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "messenger" );
        exception_tb = NULL;

        exception_lineno = 108;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = const_str_plain_preRemoveNodePath;
    tmp_args_element_name_2 = PyList_New( 1 );
    tmp_list_element_1 = par_self;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_args_element_name_2, 0, tmp_list_element_1 );
    frame_function->m_frame.f_lineno = 108;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_1, const_str_plain_send, call_args );
    }

    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 108;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 110;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_removeNode );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 110;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_10_remove );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_10_remove );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_11_lsNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_type = NULL;
    PyObject *var_name = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_06a81b72c525dae2f442cc0d66794129, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_bc0e80cd2cccb41242a91323ec48d3fa;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 117;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 118;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_isEmpty );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 118;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 118;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_print_value = const_str_digest_20cc24bb99251993826a0b06bd8fb28e;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 119;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 119;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 121;
    tmp_called_instance_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_node );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 121;
    tmp_called_instance_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getType );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 121;
    tmp_assign_source_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 121;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_type == NULL );
    var_type = tmp_assign_source_1;

    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 122;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getName );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 122;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_2;

    tmp_left_name_2 = var_type;

    CHECK_OBJECT( tmp_left_name_2 );
    tmp_right_name_1 = const_str_digest_b8872718382dd39ffa4013e303d20ce5;
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 123;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_2 = var_name;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 123;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 123;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 123;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_6 = par_self;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 124;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_lsNamesRecurse );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 124;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_type, var_name );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_11_lsNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_11_lsNames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_indentString = python_pars[ 1 ];
    PyObject *var_nodePath = NULL;
    PyObject *var_type = NULL;
    PyObject *var_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_90b5ab8872ab2916e5c87911d8e91f5e, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_e0dbf252c0255ebe72277da1e8b32358;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 131;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 132;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getChildren );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooo";
            frame_function->m_frame.f_lineno = 132;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_nodePath;
        var_nodePath = tmp_assign_source_3;
        Py_INCREF( var_nodePath );
        Py_XDECREF( old );
    }

    tmp_called_instance_4 = var_nodePath;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 133;
    tmp_called_instance_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_node );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 133;
    tmp_called_instance_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getType );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 133;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 133;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_type;
        var_type = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_called_instance_5 = var_nodePath;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 134;
    tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getName );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 134;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_left_name_3 = par_indentString;

    CHECK_OBJECT( tmp_left_name_3 );
    tmp_right_name_1 = var_type;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_left_name_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_1 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_2 = const_str_digest_b8872718382dd39ffa4013e303d20ce5;
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_3 = var_name;

    CHECK_OBJECT( tmp_right_name_3 );
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 135;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 135;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_source_name_1 = var_nodePath;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_lsNamesRecurse );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 136;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_4 = par_indentString;

    CHECK_OBJECT( tmp_left_name_4 );
    tmp_right_name_4 = const_str_space;
    tmp_args_element_name_1 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 136;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 136;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 136;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 132;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_indentString, var_nodePath, var_type, var_name );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_indentString );
    Py_DECREF( par_indentString );
    par_indentString = NULL;

    Py_XDECREF( var_nodePath );
    var_nodePath = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_indentString );
    Py_DECREF( par_indentString );
    par_indentString = NULL;

    Py_XDECREF( var_nodePath );
    var_nodePath = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ancestors = NULL;
    PyObject *var_ancestry = NULL;
    PyObject *var_indentString = NULL;
    PyObject *var_nodePath = NULL;
    PyObject *var_type = NULL;
    PyObject *var_name = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b8dc973a59a525b1d5937ff2ee8b8804, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_06971424f50e889da5ec9adae51853c6;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 143;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 143;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 144;
    tmp_list_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getAncestors );
    if ( tmp_list_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    Py_DECREF( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 144;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ancestors == NULL );
    var_ancestors = tmp_assign_source_1;

    tmp_called_instance_2 = var_ancestors;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 145;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_reverse );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 145;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_ancestry == NULL );
    var_ancestry = tmp_assign_source_2;

    tmp_assign_source_3 = const_str_empty;
    assert( var_indentString == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_indentString = tmp_assign_source_3;

    tmp_iter_arg_1 = var_ancestry;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_4 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_4;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_5 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooo";
            frame_function->m_frame.f_lineno = 147;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_assign_source_6 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_6 );
    {
        PyObject *old = var_nodePath;
        var_nodePath = tmp_assign_source_6;
        Py_INCREF( var_nodePath );
        Py_XDECREF( old );
    }

    tmp_called_instance_5 = var_nodePath;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 148;
    tmp_called_instance_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_node );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 148;
    tmp_called_instance_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getType );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 148;
    tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getName );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 148;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_type;
        var_type = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_called_instance_6 = var_nodePath;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 149;
    tmp_assign_source_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getName );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 149;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_name;
        var_name = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    tmp_left_name_3 = var_indentString;

    if ( tmp_left_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "indentString" );
        exception_tb = NULL;

        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_1 = var_type;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_left_name_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_1 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_2 = const_str_digest_b8872718382dd39ffa4013e303d20ce5;
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_3 = var_name;

    CHECK_OBJECT( tmp_right_name_3 );
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 150;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_4 = var_indentString;

    if ( tmp_left_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "indentString" );
        exception_tb = NULL;

        exception_lineno = 151;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_4 = const_str_space;
    tmp_assign_source_9 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 151;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_indentString;
        var_indentString = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 147;
        type_description = "ooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_ancestors, var_ancestry, var_indentString, var_nodePath, var_type, var_name );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ancestors );
    Py_DECREF( var_ancestors );
    var_ancestors = NULL;

    CHECK_OBJECT( (PyObject *)var_ancestry );
    Py_DECREF( var_ancestry );
    var_ancestry = NULL;

    Py_XDECREF( var_indentString );
    var_indentString = NULL;

    Py_XDECREF( var_nodePath );
    var_nodePath = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ancestors );
    var_ancestors = NULL;

    Py_XDECREF( var_ancestry );
    var_ancestry = NULL;

    Py_XDECREF( var_indentString );
    var_indentString = NULL;

    Py_XDECREF( var_nodePath );
    var_nodePath = NULL;

    Py_XDECREF( var_type );
    var_type = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_14_getAncestry( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_ancestors = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_list_arg_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_37d493be231c5010b970ce6276e19603, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_8e6ec66a21e36095d352cc99eb873978;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 158;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 158;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 159;
    tmp_list_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getAncestors );
    if ( tmp_list_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PySequence_List( tmp_list_arg_1 );
    Py_DECREF( tmp_list_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 159;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    assert( var_ancestors == NULL );
    var_ancestors = tmp_assign_source_1;

    tmp_called_instance_2 = var_ancestors;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 160;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_reverse );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 160;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_ancestors );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_ancestors;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_14_getAncestry );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_ancestors );
    Py_DECREF( var_ancestors );
    var_ancestors = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_ancestors );
    var_ancestors = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_14_getAncestry );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_15_pPrintString( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *var_pos = NULL;
    PyObject *var_hpr = NULL;
    PyObject *var_scale = NULL;
    PyObject *var_shear = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_fde9287990a9dab12fd41e019193bedc, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_746f609ec37af2b9cd6674c0823bc3f7;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 171;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 177;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 178;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getPos, call_args );
    }

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 178;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_1;

    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = par_other;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 179;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getHpr, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 179;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_2;

    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_3 = par_other;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 180;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_getScale, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 180;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_3;

    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_4 = par_other;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 181;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_getShear, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 181;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_shear == NULL );
    var_shear = tmp_assign_source_4;

    tmp_left_name_1 = const_str_digest_0dfcaf48daceb4bbbd511004ff22d2e1;
    tmp_right_name_1 = PyTuple_New( 1 );
    tmp_called_instance_5 = par_other;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 182;
    tmp_tuple_element_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getName );
    if ( tmp_tuple_element_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_1 );

        exception_lineno = 182;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_1, 0, tmp_tuple_element_1 );
    tmp_assign_source_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 182;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_5;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_6 = par_self;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 184;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getPos );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 184;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_6;

    tmp_called_instance_7 = par_self;

    CHECK_OBJECT( tmp_called_instance_7 );
    frame_function->m_frame.f_lineno = 185;
    tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getHpr );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 185;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_7;

    tmp_called_instance_8 = par_self;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 186;
    tmp_assign_source_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getScale );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 186;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_8;

    tmp_called_instance_9 = par_self;

    CHECK_OBJECT( tmp_called_instance_9 );
    frame_function->m_frame.f_lineno = 187;
    tmp_assign_source_9 = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_getShear );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 187;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_shear == NULL );
    var_shear = tmp_assign_source_9;

    tmp_assign_source_10 = const_str_newline;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_10 );
    var_otherString = tmp_assign_source_10;

    branch_end_1:;
    tmp_left_name_8 = const_str_digest_c53ef752a249b2e5a51aa448d57d70d2;
    tmp_called_instance_10 = par_self;

    CHECK_OBJECT( tmp_called_instance_10 );
    frame_function->m_frame.f_lineno = 190;
    tmp_right_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_getName );
    if ( tmp_right_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_8, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = var_otherString;

    CHECK_OBJECT( tmp_right_name_3 );
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 190;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = const_str_digest_7996907301bec4877f4d020cf3f44696;
    tmp_called_instance_11 = var_pos;

    CHECK_OBJECT( tmp_called_instance_11 );
    frame_function->m_frame.f_lineno = 192;
    tmp_right_name_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_pPrintValues );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 192;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_right_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 192;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 191;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_10 = const_str_digest_f40118032477fce3c42a75520e50ad50;
    tmp_called_instance_12 = var_hpr;

    CHECK_OBJECT( tmp_called_instance_12 );
    frame_function->m_frame.f_lineno = 193;
    tmp_right_name_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_12, const_str_plain_pPrintValues );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_5 );

        exception_lineno = 193;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = BINARY_OPERATION_REMAINDER( tmp_left_name_10, tmp_right_name_7 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_right_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_5 );

        exception_lineno = 193;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_4 = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_5 );
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 192;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_11 = const_str_digest_1b278c87e5956d0815aacacaa6122dce;
    tmp_called_instance_13 = var_scale;

    CHECK_OBJECT( tmp_called_instance_13 );
    frame_function->m_frame.f_lineno = 194;
    tmp_right_name_9 = CALL_METHOD_NO_ARGS( tmp_called_instance_13, const_str_plain_pPrintValues );
    if ( tmp_right_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_4 );

        exception_lineno = 194;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_8 = BINARY_OPERATION_REMAINDER( tmp_left_name_11, tmp_right_name_9 );
    Py_DECREF( tmp_right_name_9 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_4 );

        exception_lineno = 194;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_8 );
    Py_DECREF( tmp_left_name_4 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_left_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 193;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_12 = const_str_digest_309d8f9a2a8b5f431567fe03852b19cd;
    tmp_called_instance_14 = var_shear;

    CHECK_OBJECT( tmp_called_instance_14 );
    frame_function->m_frame.f_lineno = 195;
    tmp_right_name_11 = CALL_METHOD_NO_ARGS( tmp_called_instance_14, const_str_plain_pPrintValues );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_3 );

        exception_lineno = 195;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_12, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_3 );

        exception_lineno = 195;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = BINARY_OPERATION_ADD( tmp_left_name_3, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_3 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 194;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_chr_125;
    tmp_return_value = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_2 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 195;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, var_pos, var_hpr, var_scale, var_shear, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_15_pPrintString );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)var_pos );
    Py_DECREF( var_pos );
    var_pos = NULL;

    CHECK_OBJECT( (PyObject *)var_hpr );
    Py_DECREF( var_hpr );
    var_hpr = NULL;

    CHECK_OBJECT( (PyObject *)var_scale );
    Py_DECREF( var_scale );
    var_scale = NULL;

    CHECK_OBJECT( (PyObject *)var_shear );
    Py_DECREF( var_shear );
    var_shear = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_shear );
    var_shear = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_15_pPrintString );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_16_printPos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *var_formatString = NULL;
    PyObject *var_pos = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ae46e0796f95e234fd8d8691701c5c85, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_503cbb628f4ae47a725b7c360e49319f;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 203;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_ee238700af53818c4ed331ccfcb75d41;
    tmp_left_name_3 = const_str_digest_a9f9a21e276932d061c34fdf077216a6;
    tmp_right_name_2 = par_sd;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_plain_f;
    tmp_assign_source_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 204;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_formatString == NULL );
    var_formatString = tmp_assign_source_1;

    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 205;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 206;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getPos, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 206;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_2;

    tmp_called_instance_2 = par_other;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 207;
    tmp_left_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_assign_source_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 207;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_3;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 209;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getPos );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 209;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_4;

    tmp_assign_source_5 = const_str_empty;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_otherString = tmp_assign_source_5;

    branch_end_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 211;
    tmp_left_name_12 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getName );
    if ( tmp_left_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_5 = const_str_digest_77e9c17b462a3d9a8f3d88de94cab242;
    tmp_left_name_11 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_12 );
    if ( tmp_left_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = var_otherString;

    CHECK_OBJECT( tmp_right_name_6 );
    tmp_left_name_10 = BINARY_OPERATION_ADD( tmp_left_name_11, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_11 );
    if ( tmp_left_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_13 = var_formatString;

    CHECK_OBJECT( tmp_left_name_13 );
    tmp_subscribed_name_1 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 212;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_13, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 212;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = BINARY_OPERATION_ADD( tmp_left_name_10, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_10 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_left_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_9 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_8 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_9 );
    Py_DECREF( tmp_left_name_9 );
    if ( tmp_left_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 212;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_14 = var_formatString;

    CHECK_OBJECT( tmp_left_name_14 );
    tmp_subscribed_name_2 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_right_name_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 213;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_14, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 213;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_8 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 212;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_15 = var_formatString;

    CHECK_OBJECT( tmp_left_name_15 );
    tmp_subscribed_name_3 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 214;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_15, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_right_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 214;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_13 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_13 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 213;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_15 = const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_15 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 214;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 211;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, var_formatString, var_pos, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_16_printPos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)var_formatString );
    Py_DECREF( var_formatString );
    var_formatString = NULL;

    CHECK_OBJECT( (PyObject *)var_pos );
    Py_DECREF( var_pos );
    var_pos = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    Py_XDECREF( var_formatString );
    var_formatString = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_16_printPos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_17_printHpr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *var_formatString = NULL;
    PyObject *var_hpr = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_9555320a3f201bb9e8eb1d3aedb3d9e3, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_095507e151ec3e28c10d55b825eb29fc;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 222;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 222;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_ee238700af53818c4ed331ccfcb75d41;
    tmp_left_name_3 = const_str_digest_a9f9a21e276932d061c34fdf077216a6;
    tmp_right_name_2 = par_sd;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_plain_f;
    tmp_assign_source_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 223;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_formatString == NULL );
    var_formatString = tmp_assign_source_1;

    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 224;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 225;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getHpr, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 225;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_2;

    tmp_called_instance_2 = par_other;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 226;
    tmp_left_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 226;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_assign_source_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 226;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_3;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 228;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getHpr );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 228;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_4;

    tmp_assign_source_5 = const_str_empty;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_otherString = tmp_assign_source_5;

    branch_end_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 230;
    tmp_left_name_12 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getName );
    if ( tmp_left_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_5 = const_str_digest_cb55be559bd21b2bb4f7207654f14aea;
    tmp_left_name_11 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_12 );
    if ( tmp_left_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = var_otherString;

    CHECK_OBJECT( tmp_right_name_6 );
    tmp_left_name_10 = BINARY_OPERATION_ADD( tmp_left_name_11, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_11 );
    if ( tmp_left_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_13 = var_formatString;

    CHECK_OBJECT( tmp_left_name_13 );
    tmp_subscribed_name_1 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 231;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_13, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 231;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = BINARY_OPERATION_ADD( tmp_left_name_10, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_10 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_left_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_9 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_8 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_9 );
    Py_DECREF( tmp_left_name_9 );
    if ( tmp_left_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 231;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_14 = var_formatString;

    CHECK_OBJECT( tmp_left_name_14 );
    tmp_subscribed_name_2 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_right_name_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 232;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_14, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 232;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_8 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 231;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 232;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_15 = var_formatString;

    CHECK_OBJECT( tmp_left_name_15 );
    tmp_subscribed_name_3 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 233;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_15, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_right_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 233;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_13 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_13 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 232;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_15 = const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_15 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 233;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 230;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, var_formatString, var_hpr, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_17_printHpr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)var_formatString );
    Py_DECREF( var_formatString );
    var_formatString = NULL;

    CHECK_OBJECT( (PyObject *)var_hpr );
    Py_DECREF( var_hpr );
    var_hpr = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    Py_XDECREF( var_formatString );
    var_formatString = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_17_printHpr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_18_printScale( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *var_formatString = NULL;
    PyObject *var_scale = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1085e04a622479f3d892fba051817853, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_841c073c60a7d5f21d68b18948e7bd8a;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 241;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 241;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_ee238700af53818c4ed331ccfcb75d41;
    tmp_left_name_3 = const_str_digest_a9f9a21e276932d061c34fdf077216a6;
    tmp_right_name_2 = par_sd;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 242;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 242;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_plain_f;
    tmp_assign_source_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 242;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_formatString == NULL );
    var_formatString = tmp_assign_source_1;

    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 243;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 244;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getScale, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 244;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_2;

    tmp_called_instance_2 = par_other;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 245;
    tmp_left_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getName );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 245;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_assign_source_3 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 245;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_3;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 247;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getScale );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 247;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_4;

    tmp_assign_source_5 = const_str_empty;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_otherString = tmp_assign_source_5;

    branch_end_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 249;
    tmp_left_name_12 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getName );
    if ( tmp_left_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_5 = const_str_digest_8539abab90e32d39166e1ee2cfc4d229;
    tmp_left_name_11 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_12 );
    if ( tmp_left_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = var_otherString;

    CHECK_OBJECT( tmp_right_name_6 );
    tmp_left_name_10 = BINARY_OPERATION_ADD( tmp_left_name_11, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_11 );
    if ( tmp_left_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_13 = var_formatString;

    CHECK_OBJECT( tmp_left_name_13 );
    tmp_subscribed_name_1 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 250;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_13, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 250;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = BINARY_OPERATION_ADD( tmp_left_name_10, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_10 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_left_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_9 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_8 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_9 );
    Py_DECREF( tmp_left_name_9 );
    if ( tmp_left_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_14 = var_formatString;

    CHECK_OBJECT( tmp_left_name_14 );
    tmp_subscribed_name_2 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_right_name_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 251;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_14, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 251;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_8 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 250;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_15 = var_formatString;

    CHECK_OBJECT( tmp_left_name_15 );
    tmp_subscribed_name_3 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 252;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_15, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_right_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 252;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_13 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_13 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 251;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_15 = const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_15 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 252;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 249;
        type_description = "oooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, var_formatString, var_scale, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_18_printScale );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)var_formatString );
    Py_DECREF( var_formatString );
    var_formatString = NULL;

    CHECK_OBJECT( (PyObject *)var_scale );
    Py_DECREF( var_scale );
    var_scale = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    Py_XDECREF( var_formatString );
    var_formatString = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_18_printScale );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *var_formatString = NULL;
    PyObject *var_pos = NULL;
    PyObject *var_hpr = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_left_name_16;
    PyObject *tmp_left_name_17;
    PyObject *tmp_left_name_18;
    PyObject *tmp_left_name_19;
    PyObject *tmp_left_name_20;
    PyObject *tmp_left_name_21;
    PyObject *tmp_left_name_22;
    PyObject *tmp_left_name_23;
    PyObject *tmp_left_name_24;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_right_name_16;
    PyObject *tmp_right_name_17;
    PyObject *tmp_right_name_18;
    PyObject *tmp_right_name_19;
    PyObject *tmp_right_name_20;
    PyObject *tmp_right_name_21;
    PyObject *tmp_right_name_22;
    PyObject *tmp_right_name_23;
    PyObject *tmp_right_name_24;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_bdabf02f866f906167831c0ba99843d4, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_3022a4824a2c2fe8c6d287d38d814227;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 260;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_ee238700af53818c4ed331ccfcb75d41;
    tmp_left_name_3 = const_str_digest_a9f9a21e276932d061c34fdf077216a6;
    tmp_right_name_2 = par_sd;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_plain_f;
    tmp_assign_source_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 261;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_formatString == NULL );
    var_formatString = tmp_assign_source_1;

    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 262;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 263;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getPos, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 263;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_2;

    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = par_other;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 264;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getHpr, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 264;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_3;

    tmp_called_instance_3 = par_other;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 265;
    tmp_left_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getName );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 265;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_assign_source_4 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 265;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_4;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 267;
    tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getPos );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 267;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_5;

    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 268;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getHpr );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 268;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_6;

    tmp_assign_source_7 = const_str_empty;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_7 );
    var_otherString = tmp_assign_source_7;

    branch_end_1:;
    tmp_called_instance_6 = par_self;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 270;
    tmp_left_name_18 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getName );
    if ( tmp_left_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_5 = const_str_digest_73fa360419110f5e7e11bd2f92e1c0ad;
    tmp_left_name_17 = BINARY_OPERATION_ADD( tmp_left_name_18, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_18 );
    if ( tmp_left_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = var_otherString;

    CHECK_OBJECT( tmp_right_name_6 );
    tmp_left_name_16 = BINARY_OPERATION_ADD( tmp_left_name_17, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_17 );
    if ( tmp_left_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_19 = var_formatString;

    CHECK_OBJECT( tmp_left_name_19 );
    tmp_subscribed_name_1 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_16 );

        exception_lineno = 271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_19, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_16 );

        exception_lineno = 271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_15 = BINARY_OPERATION_ADD( tmp_left_name_16, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_16 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_left_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_9 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_14 = BINARY_OPERATION_ADD( tmp_left_name_15, tmp_right_name_9 );
    Py_DECREF( tmp_left_name_15 );
    if ( tmp_left_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_20 = var_formatString;

    CHECK_OBJECT( tmp_left_name_20 );
    tmp_subscribed_name_2 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_right_name_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_14 );

        exception_lineno = 272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_20, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_14 );

        exception_lineno = 272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_13 = BINARY_OPERATION_ADD( tmp_left_name_14, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_14 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 271;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_12 = BINARY_OPERATION_ADD( tmp_left_name_13, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_13 );
    if ( tmp_left_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_21 = var_formatString;

    CHECK_OBJECT( tmp_left_name_21 );
    tmp_subscribed_name_3 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_12 );

        exception_lineno = 273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_21, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_right_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_12 );

        exception_lineno = 273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_11 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_13 );
    Py_DECREF( tmp_left_name_12 );
    Py_DECREF( tmp_right_name_13 );
    if ( tmp_left_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 272;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_15 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_10 = BINARY_OPERATION_ADD( tmp_left_name_11, tmp_right_name_15 );
    Py_DECREF( tmp_left_name_11 );
    if ( tmp_left_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_22 = var_formatString;

    CHECK_OBJECT( tmp_left_name_22 );
    tmp_subscribed_name_4 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_right_name_17 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_right_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_16 = BINARY_OPERATION_REMAINDER( tmp_left_name_22, tmp_right_name_17 );
    Py_DECREF( tmp_right_name_17 );
    if ( tmp_right_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = BINARY_OPERATION_ADD( tmp_left_name_10, tmp_right_name_16 );
    Py_DECREF( tmp_left_name_10 );
    Py_DECREF( tmp_right_name_16 );
    if ( tmp_left_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 273;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_18 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_8 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_18 );
    Py_DECREF( tmp_left_name_9 );
    if ( tmp_left_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_23 = var_formatString;

    CHECK_OBJECT( tmp_left_name_23 );
    tmp_subscribed_name_5 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_pos_1;
    tmp_right_name_20 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_right_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_19 = BINARY_OPERATION_REMAINDER( tmp_left_name_23, tmp_right_name_20 );
    Py_DECREF( tmp_right_name_20 );
    if ( tmp_right_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_19 );
    Py_DECREF( tmp_left_name_8 );
    Py_DECREF( tmp_right_name_19 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 274;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_21 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_21 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_24 = var_formatString;

    CHECK_OBJECT( tmp_left_name_24 );
    tmp_subscribed_name_6 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_pos_2;
    tmp_right_name_23 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_right_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 276;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_22 = BINARY_OPERATION_REMAINDER( tmp_left_name_24, tmp_right_name_23 );
    Py_DECREF( tmp_right_name_23 );
    if ( tmp_right_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 276;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_22 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_22 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 275;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_24 = const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_24 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 276;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 270;
        type_description = "ooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, var_formatString, var_pos, var_hpr, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)var_formatString );
    Py_DECREF( var_formatString );
    var_formatString = NULL;

    CHECK_OBJECT( (PyObject *)var_pos );
    Py_DECREF( var_pos );
    var_pos = NULL;

    CHECK_OBJECT( (PyObject *)var_hpr );
    Py_DECREF( var_hpr );
    var_hpr = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    Py_XDECREF( var_formatString );
    var_formatString = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *var_formatString = NULL;
    PyObject *var_pos = NULL;
    PyObject *var_hpr = NULL;
    PyObject *var_scale = NULL;
    PyObject *var_otherString = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_left_name_16;
    PyObject *tmp_left_name_17;
    PyObject *tmp_left_name_18;
    PyObject *tmp_left_name_19;
    PyObject *tmp_left_name_20;
    PyObject *tmp_left_name_21;
    PyObject *tmp_left_name_22;
    PyObject *tmp_left_name_23;
    PyObject *tmp_left_name_24;
    PyObject *tmp_left_name_25;
    PyObject *tmp_left_name_26;
    PyObject *tmp_left_name_27;
    PyObject *tmp_left_name_28;
    PyObject *tmp_left_name_29;
    PyObject *tmp_left_name_30;
    PyObject *tmp_left_name_31;
    PyObject *tmp_left_name_32;
    PyObject *tmp_left_name_33;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_right_name_16;
    PyObject *tmp_right_name_17;
    PyObject *tmp_right_name_18;
    PyObject *tmp_right_name_19;
    PyObject *tmp_right_name_20;
    PyObject *tmp_right_name_21;
    PyObject *tmp_right_name_22;
    PyObject *tmp_right_name_23;
    PyObject *tmp_right_name_24;
    PyObject *tmp_right_name_25;
    PyObject *tmp_right_name_26;
    PyObject *tmp_right_name_27;
    PyObject *tmp_right_name_28;
    PyObject *tmp_right_name_29;
    PyObject *tmp_right_name_30;
    PyObject *tmp_right_name_31;
    PyObject *tmp_right_name_32;
    PyObject *tmp_right_name_33;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_72050c740292be6322a3a502126e5e39, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_2f9b549ac2e6176a73d3747b50505803;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 284;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_2 = const_str_digest_ee238700af53818c4ed331ccfcb75d41;
    tmp_left_name_3 = const_str_digest_a9f9a21e276932d061c34fdf077216a6;
    tmp_right_name_2 = par_sd;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_right_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_2 );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 285;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BINARY_OPERATION_ADD( tmp_left_name_2, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 285;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_3 = const_str_plain_f;
    tmp_assign_source_1 = BINARY_OPERATION_ADD( tmp_left_name_1, tmp_right_name_3 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 285;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_formatString == NULL );
    var_formatString = tmp_assign_source_1;

    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 286;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 287;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_getPos, call_args );
    }

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 287;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_2;

    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = par_other;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 288;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_assign_source_3 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_getHpr, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 288;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_3;

    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_3 = par_other;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 289;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_assign_source_4 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_getScale, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 289;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_4;

    tmp_called_instance_4 = par_other;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 290;
    tmp_left_name_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getName );
    if ( tmp_left_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_4 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_assign_source_5 = BINARY_OPERATION_ADD( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_left_name_4 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 290;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_otherString == NULL );
    var_otherString = tmp_assign_source_5;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 292;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getPos );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 292;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_6;

    tmp_called_instance_6 = par_self;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 293;
    tmp_assign_source_7 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getHpr );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 293;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_7;

    tmp_called_instance_7 = par_self;

    CHECK_OBJECT( tmp_called_instance_7 );
    frame_function->m_frame.f_lineno = 294;
    tmp_assign_source_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getScale );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 294;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_8;

    tmp_assign_source_9 = const_str_empty;
    assert( var_otherString == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_otherString = tmp_assign_source_9;

    branch_end_1:;
    tmp_called_instance_8 = par_self;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 296;
    tmp_left_name_24 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getName );
    if ( tmp_left_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_5 = const_str_digest_ab62dd0d26391f0d1f3fa85284b2e0ca;
    tmp_left_name_23 = BINARY_OPERATION_ADD( tmp_left_name_24, tmp_right_name_5 );
    Py_DECREF( tmp_left_name_24 );
    if ( tmp_left_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_6 = var_otherString;

    CHECK_OBJECT( tmp_right_name_6 );
    tmp_left_name_22 = BINARY_OPERATION_ADD( tmp_left_name_23, tmp_right_name_6 );
    Py_DECREF( tmp_left_name_23 );
    if ( tmp_left_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_25 = var_formatString;

    CHECK_OBJECT( tmp_left_name_25 );
    tmp_subscribed_name_1 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_right_name_8 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_right_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_22 );

        exception_lineno = 297;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_25, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_right_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_22 );

        exception_lineno = 297;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_21 = BINARY_OPERATION_ADD( tmp_left_name_22, tmp_right_name_7 );
    Py_DECREF( tmp_left_name_22 );
    Py_DECREF( tmp_right_name_7 );
    if ( tmp_left_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_9 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_20 = BINARY_OPERATION_ADD( tmp_left_name_21, tmp_right_name_9 );
    Py_DECREF( tmp_left_name_21 );
    if ( tmp_left_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 297;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_26 = var_formatString;

    CHECK_OBJECT( tmp_left_name_26 );
    tmp_subscribed_name_2 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_right_name_11 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_right_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_20 );

        exception_lineno = 298;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_10 = BINARY_OPERATION_REMAINDER( tmp_left_name_26, tmp_right_name_11 );
    Py_DECREF( tmp_right_name_11 );
    if ( tmp_right_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_20 );

        exception_lineno = 298;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_19 = BINARY_OPERATION_ADD( tmp_left_name_20, tmp_right_name_10 );
    Py_DECREF( tmp_left_name_20 );
    Py_DECREF( tmp_right_name_10 );
    if ( tmp_left_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 297;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_12 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_18 = BINARY_OPERATION_ADD( tmp_left_name_19, tmp_right_name_12 );
    Py_DECREF( tmp_left_name_19 );
    if ( tmp_left_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 298;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_27 = var_formatString;

    CHECK_OBJECT( tmp_left_name_27 );
    tmp_subscribed_name_3 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_right_name_14 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_right_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_18 );

        exception_lineno = 299;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_27, tmp_right_name_14 );
    Py_DECREF( tmp_right_name_14 );
    if ( tmp_right_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_18 );

        exception_lineno = 299;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_17 = BINARY_OPERATION_ADD( tmp_left_name_18, tmp_right_name_13 );
    Py_DECREF( tmp_left_name_18 );
    Py_DECREF( tmp_right_name_13 );
    if ( tmp_left_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 298;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_15 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_16 = BINARY_OPERATION_ADD( tmp_left_name_17, tmp_right_name_15 );
    Py_DECREF( tmp_left_name_17 );
    if ( tmp_left_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 299;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_28 = var_formatString;

    CHECK_OBJECT( tmp_left_name_28 );
    tmp_subscribed_name_4 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_right_name_17 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_right_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_16 );

        exception_lineno = 300;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_16 = BINARY_OPERATION_REMAINDER( tmp_left_name_28, tmp_right_name_17 );
    Py_DECREF( tmp_right_name_17 );
    if ( tmp_right_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_16 );

        exception_lineno = 300;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_15 = BINARY_OPERATION_ADD( tmp_left_name_16, tmp_right_name_16 );
    Py_DECREF( tmp_left_name_16 );
    Py_DECREF( tmp_right_name_16 );
    if ( tmp_left_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 299;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_18 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_14 = BINARY_OPERATION_ADD( tmp_left_name_15, tmp_right_name_18 );
    Py_DECREF( tmp_left_name_15 );
    if ( tmp_left_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 300;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_29 = var_formatString;

    CHECK_OBJECT( tmp_left_name_29 );
    tmp_subscribed_name_5 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_pos_1;
    tmp_right_name_20 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_right_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_14 );

        exception_lineno = 301;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_19 = BINARY_OPERATION_REMAINDER( tmp_left_name_29, tmp_right_name_20 );
    Py_DECREF( tmp_right_name_20 );
    if ( tmp_right_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_14 );

        exception_lineno = 301;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_13 = BINARY_OPERATION_ADD( tmp_left_name_14, tmp_right_name_19 );
    Py_DECREF( tmp_left_name_14 );
    Py_DECREF( tmp_right_name_19 );
    if ( tmp_left_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 300;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_21 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_12 = BINARY_OPERATION_ADD( tmp_left_name_13, tmp_right_name_21 );
    Py_DECREF( tmp_left_name_13 );
    if ( tmp_left_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 301;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_30 = var_formatString;

    CHECK_OBJECT( tmp_left_name_30 );
    tmp_subscribed_name_6 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_pos_2;
    tmp_right_name_23 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_right_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_12 );

        exception_lineno = 302;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_22 = BINARY_OPERATION_REMAINDER( tmp_left_name_30, tmp_right_name_23 );
    Py_DECREF( tmp_right_name_23 );
    if ( tmp_right_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_12 );

        exception_lineno = 302;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_11 = BINARY_OPERATION_ADD( tmp_left_name_12, tmp_right_name_22 );
    Py_DECREF( tmp_left_name_12 );
    Py_DECREF( tmp_right_name_22 );
    if ( tmp_left_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 301;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_24 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_10 = BINARY_OPERATION_ADD( tmp_left_name_11, tmp_right_name_24 );
    Py_DECREF( tmp_left_name_11 );
    if ( tmp_left_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_31 = var_formatString;

    CHECK_OBJECT( tmp_left_name_31 );
    tmp_subscribed_name_7 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_right_name_26 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_right_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 303;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_25 = BINARY_OPERATION_REMAINDER( tmp_left_name_31, tmp_right_name_26 );
    Py_DECREF( tmp_right_name_26 );
    if ( tmp_right_name_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_10 );

        exception_lineno = 303;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_9 = BINARY_OPERATION_ADD( tmp_left_name_10, tmp_right_name_25 );
    Py_DECREF( tmp_left_name_10 );
    Py_DECREF( tmp_right_name_25 );
    if ( tmp_left_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 302;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_27 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_8 = BINARY_OPERATION_ADD( tmp_left_name_9, tmp_right_name_27 );
    Py_DECREF( tmp_left_name_9 );
    if ( tmp_left_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_32 = var_formatString;

    CHECK_OBJECT( tmp_left_name_32 );
    tmp_subscribed_name_8 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_8 );
    tmp_subscript_name_8 = const_int_pos_1;
    tmp_right_name_29 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_right_name_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 304;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_28 = BINARY_OPERATION_REMAINDER( tmp_left_name_32, tmp_right_name_29 );
    Py_DECREF( tmp_right_name_29 );
    if ( tmp_right_name_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_8 );

        exception_lineno = 304;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_7 = BINARY_OPERATION_ADD( tmp_left_name_8, tmp_right_name_28 );
    Py_DECREF( tmp_left_name_8 );
    Py_DECREF( tmp_right_name_28 );
    if ( tmp_left_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 303;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_30 = const_str_digest_db35ab94a03c3cbeb13cbe2a1d728b77;
    tmp_left_name_6 = BINARY_OPERATION_ADD( tmp_left_name_7, tmp_right_name_30 );
    Py_DECREF( tmp_left_name_7 );
    if ( tmp_left_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_33 = var_formatString;

    CHECK_OBJECT( tmp_left_name_33 );
    tmp_subscribed_name_9 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_9 );
    tmp_subscript_name_9 = const_int_pos_2;
    tmp_right_name_32 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_right_name_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 305;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_31 = BINARY_OPERATION_REMAINDER( tmp_left_name_33, tmp_right_name_32 );
    Py_DECREF( tmp_right_name_32 );
    if ( tmp_right_name_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_left_name_6 );

        exception_lineno = 305;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_left_name_5 = BINARY_OPERATION_ADD( tmp_left_name_6, tmp_right_name_31 );
    Py_DECREF( tmp_left_name_6 );
    Py_DECREF( tmp_right_name_31 );
    if ( tmp_left_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 304;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_right_name_33 = const_str_digest_34ed79348cb98bde09a3c57c5890eed0;
    tmp_print_value = BINARY_OPERATION_ADD( tmp_left_name_5, tmp_right_name_33 );
    Py_DECREF( tmp_left_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 305;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 296;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, var_formatString, var_pos, var_hpr, var_scale, var_otherString );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)var_formatString );
    Py_DECREF( var_formatString );
    var_formatString = NULL;

    CHECK_OBJECT( (PyObject *)var_pos );
    Py_DECREF( var_pos );
    var_pos = NULL;

    CHECK_OBJECT( (PyObject *)var_hpr );
    Py_DECREF( var_hpr );
    var_hpr = NULL;

    CHECK_OBJECT( (PyObject *)var_scale );
    Py_DECREF( var_scale );
    var_scale = NULL;

    CHECK_OBJECT( (PyObject *)var_otherString );
    Py_DECREF( var_otherString );
    var_otherString = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    Py_XDECREF( var_formatString );
    var_formatString = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_otherString );
    var_otherString = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_21_printTransform( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *par_sd = python_pars[ 2 ];
    PyObject *par_fRecursive = python_pars[ 3 ];
    PyObject *var_Vec3 = NULL;
    PyObject *var_fmtStr = NULL;
    PyObject *var_name = NULL;
    PyObject *var_transform = NULL;
    PyObject *var_pos = NULL;
    PyObject *var_outputString = NULL;
    PyObject *var_hpr = NULL;
    PyObject *var_scale = NULL;
    PyObject *var_child = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    int tmp_cmp_Eq_1;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    PyObject *tmp_tuple_element_1;
    PyObject *tmp_tuple_element_2;
    PyObject *tmp_tuple_element_3;
    PyObject *tmp_tuple_element_4;
    PyObject *tmp_tuple_element_5;
    PyObject *tmp_tuple_element_6;
    PyObject *tmp_tuple_element_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b66f7e35466ba9337d7dc7e685ead2c7, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_992342804c63488bb7dc99bf40bab416;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 314;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_Vec3_tuple;
    frame_function->m_frame.f_lineno = 315;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_Vec3 );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 315;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_Vec3 == NULL );
    var_Vec3 = tmp_assign_source_1;

    tmp_left_name_1 = const_str_digest_8e72c82b5d9083fb94a573ca3ea6c2fe;
    tmp_right_name_1 = par_sd;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_assign_source_2 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 316;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_fmtStr == NULL );
    var_fmtStr = tmp_assign_source_2;

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 317;
    tmp_assign_source_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getName );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 317;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_name == NULL );
    var_name = tmp_assign_source_3;

    tmp_compare_left_1 = par_other;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 318;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 319;
    tmp_assign_source_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getTransform );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 319;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_transform == NULL );
    var_transform = tmp_assign_source_4;

    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 321;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_getTransform, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 321;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_transform == NULL );
    var_transform = tmp_assign_source_5;

    branch_end_1:;
    tmp_called_instance_4 = var_transform;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 322;
    tmp_cond_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_hasPos );
    if ( tmp_cond_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 322;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 322;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_5 = var_transform;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 323;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getPos );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 323;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_pos == NULL );
    var_pos = tmp_assign_source_6;

    tmp_source_name_1 = var_pos;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_almostEqual );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_2 = var_Vec3;

    CHECK_OBJECT( tmp_called_name_2 );
    frame_function->m_frame.f_lineno = 324;
    tmp_args_element_name_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 324;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 324;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_cond_value_2 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 324;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 324;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_no_3;
    }
    else
    {
        goto branch_yes_3;
    }
    branch_yes_3:;
    tmp_left_name_2 = const_str_digest_a8d65c3d3b507677d22784985ff6542a;
    tmp_right_name_2 = PyTuple_New( 4 );
    tmp_tuple_element_1 = var_name;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_2, 0, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_2, 1, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_2, 2, tmp_tuple_element_1 );
    tmp_tuple_element_1 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_right_name_2, 3, tmp_tuple_element_1 );
    tmp_assign_source_7 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    Py_DECREF( tmp_right_name_2 );
    if ( tmp_assign_source_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 325;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_outputString == NULL );
    var_outputString = tmp_assign_source_7;

    tmp_left_name_3 = var_outputString;

    CHECK_OBJECT( tmp_left_name_3 );
    tmp_right_name_3 = PyTuple_New( 3 );
    tmp_subscribed_name_1 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_3 );

        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_3, 0, tmp_tuple_element_2 );
    tmp_subscribed_name_2 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = const_int_pos_1;
    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_3 );

        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_3, 1, tmp_tuple_element_2 );
    tmp_subscribed_name_3 = var_pos;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = const_int_pos_2;
    tmp_tuple_element_2 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_tuple_element_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_3 );

        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_3, 2, tmp_tuple_element_2 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_3, tmp_right_name_3 );
    Py_DECREF( tmp_right_name_3 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 326;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_3:;
    branch_no_2:;
    tmp_called_instance_6 = var_transform;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 327;
    tmp_cond_value_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_hasHpr );
    if ( tmp_cond_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 327;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 327;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_called_instance_7 = var_transform;

    CHECK_OBJECT( tmp_called_instance_7 );
    frame_function->m_frame.f_lineno = 328;
    tmp_assign_source_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getHpr );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 328;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_hpr == NULL );
    var_hpr = tmp_assign_source_8;

    tmp_source_name_2 = var_hpr;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_almostEqual );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 329;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_4 = var_Vec3;

    CHECK_OBJECT( tmp_called_name_4 );
    frame_function->m_frame.f_lineno = 329;
    tmp_args_element_name_3 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, &PyTuple_GET_ITEM( const_tuple_int_0_tuple, 0 ) );

    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 329;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 329;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_cond_value_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_cond_value_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 329;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 329;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_no_5;
    }
    else
    {
        goto branch_yes_5;
    }
    branch_yes_5:;
    tmp_left_name_4 = const_str_digest_8d4812dee8f3081b71f85da68e87d9e1;
    tmp_right_name_4 = PyTuple_New( 4 );
    tmp_tuple_element_3 = var_name;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_right_name_4, 0, tmp_tuple_element_3 );
    tmp_tuple_element_3 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_right_name_4, 1, tmp_tuple_element_3 );
    tmp_tuple_element_3 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_right_name_4, 2, tmp_tuple_element_3 );
    tmp_tuple_element_3 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_3 );
    Py_INCREF( tmp_tuple_element_3 );
    PyTuple_SET_ITEM( tmp_right_name_4, 3, tmp_tuple_element_3 );
    tmp_assign_source_9 = BINARY_OPERATION_REMAINDER( tmp_left_name_4, tmp_right_name_4 );
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_assign_source_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 330;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_outputString;
        var_outputString = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_left_name_5 = var_outputString;

    CHECK_OBJECT( tmp_left_name_5 );
    tmp_right_name_5 = PyTuple_New( 3 );
    tmp_subscribed_name_4 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = const_int_0;
    tmp_tuple_element_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_tuple_element_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_5 );

        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_5, 0, tmp_tuple_element_4 );
    tmp_subscribed_name_5 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = const_int_pos_1;
    tmp_tuple_element_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_tuple_element_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_5 );

        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_5, 1, tmp_tuple_element_4 );
    tmp_subscribed_name_6 = var_hpr;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = const_int_pos_2;
    tmp_tuple_element_4 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_tuple_element_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_5 );

        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_5, 2, tmp_tuple_element_4 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_5, tmp_right_name_5 );
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 331;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_5:;
    branch_no_4:;
    tmp_called_instance_8 = var_transform;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 332;
    tmp_cond_value_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_hasScale );
    if ( tmp_cond_value_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 332;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 332;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_called_instance_9 = var_transform;

    CHECK_OBJECT( tmp_called_instance_9 );
    frame_function->m_frame.f_lineno = 333;
    tmp_cond_value_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_hasUniformScale );
    if ( tmp_cond_value_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 333;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 333;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_called_instance_10 = var_transform;

    CHECK_OBJECT( tmp_called_instance_10 );
    frame_function->m_frame.f_lineno = 334;
    tmp_assign_source_10 = CALL_METHOD_NO_ARGS( tmp_called_instance_10, const_str_plain_getUniformScale );
    if ( tmp_assign_source_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 334;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_10;

    tmp_compare_left_2 = var_scale;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = const_float_1_0;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 335;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_left_name_6 = const_str_digest_eeb948922be95abd991ff245125db928;
    tmp_right_name_6 = PyTuple_New( 2 );
    tmp_tuple_element_5 = var_name;

    CHECK_OBJECT( tmp_tuple_element_5 );
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_right_name_6, 0, tmp_tuple_element_5 );
    tmp_tuple_element_5 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_5 );
    Py_INCREF( tmp_tuple_element_5 );
    PyTuple_SET_ITEM( tmp_right_name_6, 1, tmp_tuple_element_5 );
    tmp_assign_source_11 = BINARY_OPERATION_REMAINDER( tmp_left_name_6, tmp_right_name_6 );
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 336;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_outputString;
        var_outputString = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_left_name_7 = var_outputString;

    CHECK_OBJECT( tmp_left_name_7 );
    tmp_right_name_7 = var_scale;

    CHECK_OBJECT( tmp_right_name_7 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_7, tmp_right_name_7 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 337;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 337;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_8:;
    goto branch_end_7;
    branch_no_7:;
    tmp_called_instance_11 = var_transform;

    CHECK_OBJECT( tmp_called_instance_11 );
    frame_function->m_frame.f_lineno = 339;
    tmp_assign_source_12 = CALL_METHOD_NO_ARGS( tmp_called_instance_11, const_str_plain_getScale );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 339;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_scale == NULL );
    var_scale = tmp_assign_source_12;

    tmp_source_name_3 = var_scale;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_almostEqual );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 340;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_6 = var_Vec3;

    CHECK_OBJECT( tmp_called_name_6 );
    frame_function->m_frame.f_lineno = 340;
    tmp_args_element_name_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, &PyTuple_GET_ITEM( const_tuple_int_pos_1_tuple, 0 ) );

    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 340;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 340;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_cond_value_7 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_cond_value_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 340;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 340;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_no_9;
    }
    else
    {
        goto branch_yes_9;
    }
    branch_yes_9:;
    tmp_left_name_8 = const_str_digest_699a545b77b3e4ba76f4fb1ce6853c36;
    tmp_right_name_8 = PyTuple_New( 4 );
    tmp_tuple_element_6 = var_name;

    CHECK_OBJECT( tmp_tuple_element_6 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_8, 0, tmp_tuple_element_6 );
    tmp_tuple_element_6 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_6 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_8, 1, tmp_tuple_element_6 );
    tmp_tuple_element_6 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_6 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_8, 2, tmp_tuple_element_6 );
    tmp_tuple_element_6 = var_fmtStr;

    CHECK_OBJECT( tmp_tuple_element_6 );
    Py_INCREF( tmp_tuple_element_6 );
    PyTuple_SET_ITEM( tmp_right_name_8, 3, tmp_tuple_element_6 );
    tmp_assign_source_13 = BINARY_OPERATION_REMAINDER( tmp_left_name_8, tmp_right_name_8 );
    Py_DECREF( tmp_right_name_8 );
    if ( tmp_assign_source_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 341;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_outputString;
        var_outputString = tmp_assign_source_13;
        Py_XDECREF( old );
    }

    tmp_left_name_9 = var_outputString;

    CHECK_OBJECT( tmp_left_name_9 );
    tmp_right_name_9 = PyTuple_New( 3 );
    tmp_subscribed_name_7 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = const_int_0;
    tmp_tuple_element_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_9 );

        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_9, 0, tmp_tuple_element_7 );
    tmp_subscribed_name_8 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_8 );
    tmp_subscript_name_8 = const_int_pos_1;
    tmp_tuple_element_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_9 );

        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_9, 1, tmp_tuple_element_7 );
    tmp_subscribed_name_9 = var_scale;

    CHECK_OBJECT( tmp_subscribed_name_9 );
    tmp_subscript_name_9 = const_int_pos_2;
    tmp_tuple_element_7 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_tuple_element_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_right_name_9 );

        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    PyTuple_SET_ITEM( tmp_right_name_9, 2, tmp_tuple_element_7 );
    tmp_print_value = BINARY_OPERATION_REMAINDER( tmp_left_name_9, tmp_right_name_9 );
    Py_DECREF( tmp_right_name_9 );
    if ( tmp_print_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_print_value );

        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_print_value );
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 342;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    branch_no_9:;
    branch_end_7:;
    branch_no_6:;
    tmp_cond_value_8 = par_fRecursive;

    CHECK_OBJECT( tmp_cond_value_8 );
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 343;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_called_instance_12 = par_self;

    CHECK_OBJECT( tmp_called_instance_12 );
    frame_function->m_frame.f_lineno = 344;
    tmp_iter_arg_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_12, const_str_plain_getChildren );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 344;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_14 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 344;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_14;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_15 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_15 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooooooooo";
            frame_function->m_frame.f_lineno = 344;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_15;
        Py_XDECREF( old );
    }

    tmp_assign_source_16 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_16 );
    {
        PyObject *old = var_child;
        var_child = tmp_assign_source_16;
        Py_INCREF( var_child );
        Py_XDECREF( old );
    }

    tmp_called_instance_13 = var_child;

    CHECK_OBJECT( tmp_called_instance_13 );
    tmp_args_element_name_5 = par_other;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_sd;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = par_fRecursive;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 345;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_13, const_str_plain_printTransform, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 345;
        type_description = "ooooooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 344;
        type_description = "ooooooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    branch_no_10:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other, par_sd, par_fRecursive, var_Vec3, var_fmtStr, var_name, var_transform, var_pos, var_outputString, var_hpr, var_scale, var_child );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_21_printTransform );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)par_fRecursive );
    Py_DECREF( par_fRecursive );
    par_fRecursive = NULL;

    CHECK_OBJECT( (PyObject *)var_Vec3 );
    Py_DECREF( var_Vec3 );
    var_Vec3 = NULL;

    CHECK_OBJECT( (PyObject *)var_fmtStr );
    Py_DECREF( var_fmtStr );
    var_fmtStr = NULL;

    CHECK_OBJECT( (PyObject *)var_name );
    Py_DECREF( var_name );
    var_name = NULL;

    CHECK_OBJECT( (PyObject *)var_transform );
    Py_DECREF( var_transform );
    var_transform = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_outputString );
    var_outputString = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    CHECK_OBJECT( (PyObject *)par_sd );
    Py_DECREF( par_sd );
    par_sd = NULL;

    CHECK_OBJECT( (PyObject *)par_fRecursive );
    Py_DECREF( par_fRecursive );
    par_fRecursive = NULL;

    Py_XDECREF( var_Vec3 );
    var_Vec3 = NULL;

    Py_XDECREF( var_fmtStr );
    var_fmtStr = NULL;

    Py_XDECREF( var_name );
    var_name = NULL;

    Py_XDECREF( var_transform );
    var_transform = NULL;

    Py_XDECREF( var_pos );
    var_pos = NULL;

    Py_XDECREF( var_outputString );
    var_outputString = NULL;

    Py_XDECREF( var_hpr );
    var_hpr = NULL;

    Py_XDECREF( var_scale );
    var_scale = NULL;

    Py_XDECREF( var_child );
    var_child = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_21_printTransform );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_22_iPos( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_0edc8cacec2283d0259b8c1790b2dac6, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_053e5e3bfa671cc09bbbfe2a7d1da46c;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 354;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 354;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 355;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = const_int_0;
    tmp_args_element_name_3 = const_int_0;
    tmp_args_element_name_4 = const_int_0;
    frame_function->m_frame.f_lineno = 356;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_setPos, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 356;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 358;
    tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_setPos, &PyTuple_GET_ITEM( const_tuple_int_0_int_0_int_0_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 358;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_22_iPos );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_22_iPos );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_23_iHpr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f8ad8c4d96a1525ce95fbd90ff9951a5, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_bd96532d176388ff9d8ae80995aefb1a;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 365;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 366;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = const_int_0;
    tmp_args_element_name_3 = const_int_0;
    tmp_args_element_name_4 = const_int_0;
    frame_function->m_frame.f_lineno = 367;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_setHpr, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 367;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 369;
    tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_setHpr, &PyTuple_GET_ITEM( const_tuple_int_0_int_0_int_0_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 369;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_23_iHpr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_23_iHpr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_24_iScale( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_67bdd3356210f8c54f0ce6b2e15719fa, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_136d8c8696b9665bea7cef47470e2afb;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 376;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 376;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 377;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = const_int_pos_1;
    tmp_args_element_name_3 = const_int_pos_1;
    tmp_args_element_name_4 = const_int_pos_1;
    frame_function->m_frame.f_lineno = 378;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS4( tmp_called_instance_1, const_str_plain_setScale, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 378;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 380;
    tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_2, const_str_plain_setScale, &PyTuple_GET_ITEM( const_tuple_int_pos_1_int_pos_1_int_pos_1_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 380;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_24_iScale );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_24_iScale );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_7cfe05b9583b06a64e13e7f4a487bdcd, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_f9d1ea5b90058e527abc9ac18d067545;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 387;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 387;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 388;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = const_int_0;
    tmp_args_element_name_3 = const_int_0;
    tmp_args_element_name_4 = const_int_0;
    tmp_args_element_name_5 = const_int_0;
    tmp_args_element_name_6 = const_int_0;
    tmp_args_element_name_7 = const_int_0;
    frame_function->m_frame.f_lineno = 389;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS7( tmp_called_instance_1, const_str_plain_setPosHpr, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 389;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 391;
    tmp_unused = CALL_METHOD_WITH_ARGS6( tmp_called_instance_2, const_str_plain_setPosHpr, &PyTuple_GET_ITEM( const_tuple_int_0_int_0_int_0_int_0_int_0_int_0_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 391;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_other = python_pars[ 1 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_21e5ffbcd83dc3719251a0cc773c4b50, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_fc6651ce2bf4c50e0dded358cfe6a5b8;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 398;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = par_other;

    CHECK_OBJECT( tmp_cond_value_1 );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 399;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_other;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = const_int_0;
    tmp_args_element_name_3 = const_int_0;
    tmp_args_element_name_4 = const_int_0;
    tmp_args_element_name_5 = const_int_0;
    tmp_args_element_name_6 = const_int_0;
    tmp_args_element_name_7 = const_int_0;
    tmp_args_element_name_8 = const_int_pos_1;
    tmp_args_element_name_9 = const_int_pos_1;
    tmp_args_element_name_10 = const_int_pos_1;
    frame_function->m_frame.f_lineno = 400;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS10( tmp_called_instance_1, const_str_plain_setPosHprScale, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 400;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_instance_2 = par_self;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 402;
    tmp_unused = CALL_METHOD_WITH_ARGS9( tmp_called_instance_2, const_str_plain_setPosHprScale, &PyTuple_GET_ITEM( const_tuple_c73386e0476eb45878e9a64725822b1e_tuple, 0 ) );

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 402;
        type_description = "oo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_other );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_other );
    Py_DECREF( par_other );
    par_other = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_27_place( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_importlib = NULL;
    PyObject *var_Placer = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ede5eb5c9d547319ad6296a3834aaee2, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 409;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_startDirect );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 409;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_82438769d4f7f66d5a77a06a04bb40a6 );
    frame_function->m_frame.f_lineno = 409;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 409;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_name_name_1 = const_str_plain_importlib;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    frame_function->m_frame.f_lineno = 412;
    tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 412;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_importlib == NULL );
    var_importlib = tmp_assign_source_1;

    tmp_called_instance_1 = var_importlib;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 413;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_5475c93c31866a42dfb5b7fbdfa9607b_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 413;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_Placer == NULL );
    var_Placer = tmp_assign_source_2;

    tmp_called_instance_2 = var_Placer;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 414;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_place, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 414;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_importlib, var_Placer );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_27_place );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_importlib );
    Py_DECREF( var_importlib );
    var_importlib = NULL;

    CHECK_OBJECT( (PyObject *)var_Placer );
    Py_DECREF( var_Placer );
    var_Placer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_importlib );
    var_importlib = NULL;

    Py_XDECREF( var_Placer );
    var_Placer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_27_place );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_28_explore( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_importlib = NULL;
    PyObject *var_SceneGraphExplorer = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_name_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3bc046785039d0c763921969e5abbeb6, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 420;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_startDirect );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 420;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_82438769d4f7f66d5a77a06a04bb40a6 );
    frame_function->m_frame.f_lineno = 420;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 420;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_name_name_1 = const_str_plain_importlib;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    frame_function->m_frame.f_lineno = 423;
    tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 423;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_importlib == NULL );
    var_importlib = tmp_assign_source_1;

    tmp_called_instance_1 = var_importlib;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 424;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_e5a70be140fb2f14027ecfb7aa572fac_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 424;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    assert( var_SceneGraphExplorer == NULL );
    var_SceneGraphExplorer = tmp_assign_source_2;

    tmp_called_instance_2 = var_SceneGraphExplorer;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 425;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_return_value = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_explore, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 425;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_importlib, var_SceneGraphExplorer );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_28_explore );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_importlib );
    Py_DECREF( var_importlib );
    var_importlib = NULL;

    CHECK_OBJECT( (PyObject *)var_SceneGraphExplorer );
    Py_DECREF( var_SceneGraphExplorer );
    var_SceneGraphExplorer = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_importlib );
    var_importlib = NULL;

    Py_XDECREF( var_SceneGraphExplorer );
    var_SceneGraphExplorer = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_28_explore );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_cb = python_pars[ 1 ];
    PyObject *var_importlib = NULL;
    PyObject *var_Slider = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8b01c6b7b0f1a362254e7c72179e70ce, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_called_instance_1 == NULL ))
    {
        tmp_called_instance_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_called_instance_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 431;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }

    frame_function->m_frame.f_lineno = 431;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_startTk );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 431;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_name_name_1 = const_str_plain_importlib;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = Py_None;
    frame_function->m_frame.f_lineno = 434;
    tmp_assign_source_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 434;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_importlib == NULL );
    var_importlib = tmp_assign_source_1;

    tmp_called_instance_2 = var_importlib;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 435;
    tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_import_module, &PyTuple_GET_ITEM( const_tuple_str_digest_3fb30edff6bdd123d0f703659311cfbc_tuple, 0 ) );

    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 435;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_Slider == NULL );
    var_Slider = tmp_assign_source_2;

    tmp_called_instance_3 = var_Slider;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_cb;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 436;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_return_value = CALL_METHOD_WITH_ARGS2( tmp_called_instance_3, const_str_plain_rgbPanel, call_args );
    }

    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 436;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_cb, var_importlib, var_Slider );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb );
    Py_DECREF( par_cb );
    par_cb = NULL;

    CHECK_OBJECT( (PyObject *)var_importlib );
    Py_DECREF( var_importlib );
    var_importlib = NULL;

    CHECK_OBJECT( (PyObject *)var_Slider );
    Py_DECREF( var_Slider );
    var_Slider = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_cb );
    Py_DECREF( par_cb );
    par_cb = NULL;

    Py_XDECREF( var_importlib );
    var_importlib = NULL;

    Py_XDECREF( var_Slider );
    var_Slider = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_30_select( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b401191088d960f3ac2fd4aface3a609, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 442;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_startDirect );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_55b580ba8802a2d7adcd3895d0c5b8d9 );
    frame_function->m_frame.f_lineno = 442;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 442;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 443;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_direct );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 443;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 443;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_select, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 443;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_30_select );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_30_select );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_31_deselect( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_name_1;
    PyObject *tmp_kw_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_30e9339eb9718b0bf4ed92e21e17830d, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 449;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_startDirect );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 449;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_kw_name_1 = PyDict_Copy( const_dict_55b580ba8802a2d7adcd3895d0c5b8d9 );
    frame_function->m_frame.f_lineno = 449;
    tmp_unused = CALL_FUNCTION_WITH_KEYARGS( tmp_called_name_1, tmp_kw_name_1 );
    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_kw_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 449;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_2 == NULL ))
    {
        tmp_source_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 450;
        type_description = "o";
        goto frame_exception_exit_1;
    }

    tmp_called_instance_1 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_direct );
    if ( tmp_called_instance_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 450;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_1 = par_self;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 450;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_deselect, call_args );
    }

    Py_DECREF( tmp_called_instance_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 450;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_31_deselect );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_31_deselect );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_32_showCS( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mask = python_pars[ 1 ];
    PyObject *var_npc = NULL;
    PyObject *var_p = NULL;
    PyObject *var_np = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_next_source_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_range2_high_1;
    PyObject *tmp_range2_low_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a82129c14635955c01cfb361d8ca205c, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_dc8ebf821d0ec8a379e0623265c69bad;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 463;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 463;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 464;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findAllMatches, &PyTuple_GET_ITEM( const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 464;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_npc == NULL );
    var_npc = tmp_assign_source_1;

    tmp_range2_low_1 = const_int_0;
    tmp_called_instance_2 = var_npc;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 465;
    tmp_range2_high_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getNumPaths );
    if ( tmp_range2_high_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE2( tmp_range2_low_1, tmp_range2_high_1 );
    Py_DECREF( tmp_range2_high_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooo";
            frame_function->m_frame.f_lineno = 465;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_p;
        var_p = tmp_assign_source_4;
        Py_INCREF( var_p );
        Py_XDECREF( old );
    }

    tmp_subscribed_name_1 = var_npc;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = var_p;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 466;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_np;
        var_np = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_compexpr_left_1 = par_mask;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_or_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_instance_5 = var_np;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 467;
    tmp_called_instance_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_node );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 467;
    tmp_left_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getIntoCollideMask );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = par_mask;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_called_instance_3 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 467;
    tmp_or_right_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getWord );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 467;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_6 = var_np;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 468;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_show );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 468;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 465;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_mask, var_npc, var_p, var_np );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_32_showCS );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mask );
    Py_DECREF( par_mask );
    par_mask = NULL;

    CHECK_OBJECT( (PyObject *)var_npc );
    Py_DECREF( var_npc );
    var_npc = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mask );
    Py_DECREF( par_mask );
    par_mask = NULL;

    Py_XDECREF( var_npc );
    var_npc = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_32_showCS );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_33_hideCS( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_mask = python_pars[ 1 ];
    PyObject *var_npc = NULL;
    PyObject *var_p = NULL;
    PyObject *var_np = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_right_1;
    int tmp_cond_truth_1;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_next_source_1;
    int tmp_or_left_truth_1;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_print_value;
    PyObject *tmp_range2_high_1;
    PyObject *tmp_range2_low_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_a6e51965cda121fb0a19a2726a47a80d, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_2d6f8042b6a48948b99a4fe55a6dd148;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 481;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 481;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 482;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findAllMatches, &PyTuple_GET_ITEM( const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 482;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( var_npc == NULL );
    var_npc = tmp_assign_source_1;

    tmp_range2_low_1 = const_int_0;
    tmp_called_instance_2 = var_npc;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 483;
    tmp_range2_high_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getNumPaths );
    if ( tmp_range2_high_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_1 = BUILTIN_RANGE2( tmp_range2_low_1, tmp_range2_high_1 );
    Py_DECREF( tmp_range2_high_1 );
    if ( tmp_iter_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    Py_DECREF( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description = "ooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooo";
            frame_function->m_frame.f_lineno = 483;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_p;
        var_p = tmp_assign_source_4;
        Py_INCREF( var_p );
        Py_XDECREF( old );
    }

    tmp_subscribed_name_1 = var_npc;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = var_p;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_5 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 484;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_np;
        var_np = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_compexpr_left_1 = par_mask;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_compexpr_right_1 = Py_None;
    tmp_or_left_value_1 = RICH_COMPARE_EQ( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_called_instance_5 = var_np;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 485;
    tmp_called_instance_4 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_node );
    if ( tmp_called_instance_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 485;
    tmp_left_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getIntoCollideMask );
    Py_DECREF( tmp_called_instance_4 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_right_name_1 = par_mask;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_called_instance_3 = BINARY_OPERATION( PyNumber_And, tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_called_instance_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 485;
    tmp_or_right_value_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getWord );
    Py_DECREF( tmp_called_instance_3 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 485;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_6 = var_np;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 486;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_hide );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 486;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 483;
        type_description = "ooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_mask, var_npc, var_p, var_np );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_33_hideCS );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mask );
    Py_DECREF( par_mask );
    par_mask = NULL;

    CHECK_OBJECT( (PyObject *)var_npc );
    Py_DECREF( var_npc );
    var_npc = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_mask );
    Py_DECREF( par_mask );
    par_mask = NULL;

    Py_XDECREF( var_npc );
    var_npc = NULL;

    Py_XDECREF( var_p );
    var_p = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_33_hideCS );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_34_posInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f697788ed0cf64090cd6a1600b9becbd, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 492;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 492;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 493;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_34_posInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_34_posInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_35_hprInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1546005869a33e57d250c5dc2ce5e9d4, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 499;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 499;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpHprInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 500;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_35_hprInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_35_hprInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_36_quatInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_64986c494f8638acc30b7202cc9d095d, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 506;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 506;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpQuatInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 507;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 507;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_36_quatInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_36_quatInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_251981d21f0e7ac6a88d29596b2ff1e1, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 513;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 513;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 513;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 514;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_38_shearInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3b4e490f7fd3a498f95e88a94688294d, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 520;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 520;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpShearInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 521;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 521;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_38_shearInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_38_shearInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_52d0034855259c50ed78ce646321cc12, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 527;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 527;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 527;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosHprInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 528;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 528;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_943e96b997a504a7c8581c23be1fa155, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 534;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 534;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosQuatInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 535;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8d4fad2be4e746683e779efc097e6fc6, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 541;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 541;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpHprScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 542;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 542;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_93c57184fdf27ec01488b63785c45257, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 548;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 548;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 548;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpQuatScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 549;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 549;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_ddeedc3bb3e3990af1babf16721bf63c, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 555;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 555;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 555;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosHprScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 556;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 556;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_8df4f0be86cc851730731fffe3959e9e, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 562;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 562;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 562;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosQuatScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 563;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 563;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_3d5f2dee7311a69e6ac751e09d7f0f87, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 569;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 569;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 569;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosHprScaleShearInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 570;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 570;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_64748f9472a2446221cb502039bde3fd, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 576;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 576;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpPosQuatScaleShearInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 577;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_47_colorInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_612efba40b41720fd5ff60f9276db0ce, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 583;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 583;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 583;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpColorInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 584;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 584;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_47_colorInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_47_colorInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_args = python_pars[ 1 ];
    PyObject *par_kw = python_pars[ 2 ];
    PyObject *var_LerpInterval = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_dircall_arg1_1;
    PyObject *tmp_dircall_arg2_1;
    PyObject *tmp_dircall_arg3_1;
    PyObject *tmp_dircall_arg4_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_tuple_element_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f50a0450676289b0423260c876009e5f, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_b82e83cedc3143a0d315ea5068d2162b;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_LerpInterval_tuple;
    frame_function->m_frame.f_lineno = 590;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 590;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_LerpInterval );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 590;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_LerpInterval == NULL );
    var_LerpInterval = tmp_assign_source_1;

    tmp_source_name_1 = var_LerpInterval;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_LerpColorScaleInterval );
    if ( tmp_dircall_arg1_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_dircall_arg2_1 = PyTuple_New( 1 );
    tmp_tuple_element_1 = par_self;

    CHECK_OBJECT( tmp_tuple_element_1 );
    Py_INCREF( tmp_tuple_element_1 );
    PyTuple_SET_ITEM( tmp_dircall_arg2_1, 0, tmp_tuple_element_1 );
    tmp_dircall_arg3_1 = par_args;

    CHECK_OBJECT( tmp_dircall_arg3_1 );
    tmp_dircall_arg4_1 = par_kw;

    CHECK_OBJECT( tmp_dircall_arg4_1 );
    Py_INCREF( tmp_dircall_arg3_1 );
    Py_INCREF( tmp_dircall_arg4_1 );

    {
        PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
        tmp_return_value = impl___internal__$$$function_7_complex_call_helper_pos_star_list_star_dict( dir_call_args );
    }
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 591;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_args, par_kw, var_LerpInterval );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    CHECK_OBJECT( (PyObject *)var_LerpInterval );
    Py_DECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_args );
    Py_DECREF( par_args );
    par_args = NULL;

    CHECK_OBJECT( (PyObject *)par_kw );
    Py_DECREF( par_kw );
    par_kw = NULL;

    Py_XDECREF( var_LerpInterval );
    var_LerpInterval = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_cx = python_pars[ 2 ];
    PyObject *par_cy = python_pars[ 3 ];
    PyObject *par_cz = python_pars[ 4 ];
    PyObject *par_r = python_pars[ 5 ];
    PyObject *par_fromCollide = python_pars[ 6 ];
    PyObject *par_intoCollide = python_pars[ 7 ];
    PyObject *var_CollisionSphere = NULL;
    PyObject *var_CollisionNode = NULL;
    PyObject *var_coll = NULL;
    PyObject *var_collNode = NULL;
    PyObject *var_collNodePath = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_24d26537227966edb813d67da7e6e214, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_CollisionSphere_tuple;
    frame_function->m_frame.f_lineno = 597;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 597;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_CollisionSphere );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 597;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionSphere == NULL );
    var_CollisionSphere = tmp_assign_source_1;

    tmp_name_name_2 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_CollisionNode_tuple;
    frame_function->m_frame.f_lineno = 598;
    tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 598;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_CollisionNode );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 598;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionNode == NULL );
    var_CollisionNode = tmp_assign_source_2;

    tmp_called_name_1 = var_CollisionSphere;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = par_cx;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_cy;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_cz;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_r;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 599;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS4( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 599;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_coll == NULL );
    var_coll = tmp_assign_source_3;

    tmp_called_name_2 = var_CollisionNode;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_5 = par_name;

    CHECK_OBJECT( tmp_args_element_name_5 );
    frame_function->m_frame.f_lineno = 600;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 600;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNode == NULL );
    var_collNode = tmp_assign_source_4;

    tmp_called_instance_1 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_6 = var_coll;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 601;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_addSolid, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 601;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_7 = par_fromCollide;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 602;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setFromCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 602;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_8 = par_intoCollide;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_function->m_frame.f_lineno = 603;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setIntoCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 603;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_9 = var_collNode;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 604;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_attachNewNode, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 604;
        type_description = "ooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNodePath == NULL );
    var_collNodePath = tmp_assign_source_5;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name, par_cx, par_cy, par_cz, par_r, par_fromCollide, par_intoCollide, var_CollisionSphere, var_CollisionNode, var_coll, var_collNode, var_collNodePath );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_collNodePath;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_cx );
    Py_DECREF( par_cx );
    par_cx = NULL;

    CHECK_OBJECT( (PyObject *)par_cy );
    Py_DECREF( par_cy );
    par_cy = NULL;

    CHECK_OBJECT( (PyObject *)par_cz );
    Py_DECREF( par_cz );
    par_cz = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionSphere );
    Py_DECREF( var_CollisionSphere );
    var_CollisionSphere = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionNode );
    Py_DECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    CHECK_OBJECT( (PyObject *)var_coll );
    Py_DECREF( var_coll );
    var_coll = NULL;

    CHECK_OBJECT( (PyObject *)var_collNode );
    Py_DECREF( var_collNode );
    var_collNode = NULL;

    CHECK_OBJECT( (PyObject *)var_collNodePath );
    Py_DECREF( var_collNodePath );
    var_collNodePath = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_cx );
    Py_DECREF( par_cx );
    par_cx = NULL;

    CHECK_OBJECT( (PyObject *)par_cy );
    Py_DECREF( par_cy );
    par_cy = NULL;

    CHECK_OBJECT( (PyObject *)par_cz );
    Py_DECREF( par_cz );
    par_cz = NULL;

    CHECK_OBJECT( (PyObject *)par_r );
    Py_DECREF( par_r );
    par_r = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    Py_XDECREF( var_CollisionSphere );
    var_CollisionSphere = NULL;

    Py_XDECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    Py_XDECREF( var_coll );
    var_coll = NULL;

    Py_XDECREF( var_collNode );
    var_collNode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_ax = python_pars[ 2 ];
    PyObject *par_ay = python_pars[ 3 ];
    PyObject *par_az = python_pars[ 4 ];
    PyObject *par_bx = python_pars[ 5 ];
    PyObject *par_by = python_pars[ 6 ];
    PyObject *par_bz = python_pars[ 7 ];
    PyObject *par_fromCollide = python_pars[ 8 ];
    PyObject *par_intoCollide = python_pars[ 9 ];
    PyObject *var_CollisionSegment = NULL;
    PyObject *var_CollisionNode = NULL;
    PyObject *var_coll = NULL;
    PyObject *var_collNode = NULL;
    PyObject *var_collNodePath = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f6b6e768e97eea8a9d9fd1daf5a5ec04, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_CollisionSegment_tuple;
    frame_function->m_frame.f_lineno = 611;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_CollisionSegment );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 611;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionSegment == NULL );
    var_CollisionSegment = tmp_assign_source_1;

    tmp_name_name_2 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_CollisionNode_tuple;
    frame_function->m_frame.f_lineno = 612;
    tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_CollisionNode );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 612;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionNode == NULL );
    var_CollisionNode = tmp_assign_source_2;

    tmp_called_name_1 = var_CollisionSegment;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = par_ax;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_ay;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_az;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_bx;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_by;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_bz;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 613;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS6( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 613;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_coll == NULL );
    var_coll = tmp_assign_source_3;

    tmp_called_name_2 = var_CollisionNode;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_7 = par_name;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 614;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 614;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNode == NULL );
    var_collNode = tmp_assign_source_4;

    tmp_called_instance_1 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_8 = var_coll;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_function->m_frame.f_lineno = 615;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_addSolid, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 615;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_9 = par_fromCollide;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 616;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setFromCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 616;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_10 = par_intoCollide;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 617;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setIntoCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 617;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_11 = var_collNode;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_function->m_frame.f_lineno = 618;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_attachNewNode, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 618;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNodePath == NULL );
    var_collNodePath = tmp_assign_source_5;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name, par_ax, par_ay, par_az, par_bx, par_by, par_bz, par_fromCollide, par_intoCollide, var_CollisionSegment, var_CollisionNode, var_coll, var_collNode, var_collNodePath );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_collNodePath;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_ax );
    Py_DECREF( par_ax );
    par_ax = NULL;

    CHECK_OBJECT( (PyObject *)par_ay );
    Py_DECREF( par_ay );
    par_ay = NULL;

    CHECK_OBJECT( (PyObject *)par_az );
    Py_DECREF( par_az );
    par_az = NULL;

    CHECK_OBJECT( (PyObject *)par_bx );
    Py_DECREF( par_bx );
    par_bx = NULL;

    CHECK_OBJECT( (PyObject *)par_by );
    Py_DECREF( par_by );
    par_by = NULL;

    CHECK_OBJECT( (PyObject *)par_bz );
    Py_DECREF( par_bz );
    par_bz = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionSegment );
    Py_DECREF( var_CollisionSegment );
    var_CollisionSegment = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionNode );
    Py_DECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    CHECK_OBJECT( (PyObject *)var_coll );
    Py_DECREF( var_coll );
    var_coll = NULL;

    CHECK_OBJECT( (PyObject *)var_collNode );
    Py_DECREF( var_collNode );
    var_collNode = NULL;

    CHECK_OBJECT( (PyObject *)var_collNodePath );
    Py_DECREF( var_collNodePath );
    var_collNodePath = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_ax );
    Py_DECREF( par_ax );
    par_ax = NULL;

    CHECK_OBJECT( (PyObject *)par_ay );
    Py_DECREF( par_ay );
    par_ay = NULL;

    CHECK_OBJECT( (PyObject *)par_az );
    Py_DECREF( par_az );
    par_az = NULL;

    CHECK_OBJECT( (PyObject *)par_bx );
    Py_DECREF( par_bx );
    par_bx = NULL;

    CHECK_OBJECT( (PyObject *)par_by );
    Py_DECREF( par_by );
    par_by = NULL;

    CHECK_OBJECT( (PyObject *)par_bz );
    Py_DECREF( par_bz );
    par_bz = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    Py_XDECREF( var_CollisionSegment );
    var_CollisionSegment = NULL;

    Py_XDECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    Py_XDECREF( var_coll );
    var_coll = NULL;

    Py_XDECREF( var_collNode );
    var_collNode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_name = python_pars[ 1 ];
    PyObject *par_ox = python_pars[ 2 ];
    PyObject *par_oy = python_pars[ 3 ];
    PyObject *par_oz = python_pars[ 4 ];
    PyObject *par_dx = python_pars[ 5 ];
    PyObject *par_dy = python_pars[ 6 ];
    PyObject *par_dz = python_pars[ 7 ];
    PyObject *par_fromCollide = python_pars[ 8 ];
    PyObject *par_intoCollide = python_pars[ 9 ];
    PyObject *var_CollisionRay = NULL;
    PyObject *var_CollisionNode = NULL;
    PyObject *var_coll = NULL;
    PyObject *var_collNode = NULL;
    PyObject *var_collNodePath = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    PyObject *tmp_return_value;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_6cefa3a641e11cce6d9dafaf21255680, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_CollisionRay_tuple;
    frame_function->m_frame.f_lineno = 625;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 625;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_CollisionRay );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 625;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionRay == NULL );
    var_CollisionRay = tmp_assign_source_1;

    tmp_name_name_2 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_CollisionNode_tuple;
    frame_function->m_frame.f_lineno = 626;
    tmp_import_name_from_2 = IMPORT_MODULE4( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_2 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_CollisionNode );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 626;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_CollisionNode == NULL );
    var_CollisionNode = tmp_assign_source_2;

    tmp_called_name_1 = var_CollisionRay;

    CHECK_OBJECT( tmp_called_name_1 );
    tmp_args_element_name_1 = par_ox;

    CHECK_OBJECT( tmp_args_element_name_1 );
    tmp_args_element_name_2 = par_oy;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = par_oz;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_dx;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = par_dy;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_dz;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 627;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_assign_source_3 = CALL_FUNCTION_WITH_ARGS6( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 627;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_coll == NULL );
    var_coll = tmp_assign_source_3;

    tmp_called_name_2 = var_CollisionNode;

    CHECK_OBJECT( tmp_called_name_2 );
    tmp_args_element_name_7 = par_name;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 628;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 628;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNode == NULL );
    var_collNode = tmp_assign_source_4;

    tmp_called_instance_1 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_8 = var_coll;

    CHECK_OBJECT( tmp_args_element_name_8 );
    frame_function->m_frame.f_lineno = 629;
    {
        PyObject *call_args[] = { tmp_args_element_name_8 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_addSolid, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 629;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_9 = par_fromCollide;

    CHECK_OBJECT( tmp_args_element_name_9 );
    frame_function->m_frame.f_lineno = 630;
    {
        PyObject *call_args[] = { tmp_args_element_name_9 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setFromCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 630;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_collNode;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_10 = par_intoCollide;

    CHECK_OBJECT( tmp_args_element_name_10 );
    frame_function->m_frame.f_lineno = 631;
    {
        PyObject *call_args[] = { tmp_args_element_name_10 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setIntoCollideMask, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 631;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_4 = par_self;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_11 = var_collNode;

    CHECK_OBJECT( tmp_args_element_name_11 );
    frame_function->m_frame.f_lineno = 632;
    {
        PyObject *call_args[] = { tmp_args_element_name_11 };
        tmp_assign_source_5 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_attachNewNode, call_args );
    }

    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 632;
        type_description = "ooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_collNodePath == NULL );
    var_collNodePath = tmp_assign_source_5;


#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_name, par_ox, par_oy, par_oz, par_dx, par_dy, par_dz, par_fromCollide, par_intoCollide, var_CollisionRay, var_CollisionNode, var_coll, var_collNode, var_collNodePath );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_collNodePath;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_ox );
    Py_DECREF( par_ox );
    par_ox = NULL;

    CHECK_OBJECT( (PyObject *)par_oy );
    Py_DECREF( par_oy );
    par_oy = NULL;

    CHECK_OBJECT( (PyObject *)par_oz );
    Py_DECREF( par_oz );
    par_oz = NULL;

    CHECK_OBJECT( (PyObject *)par_dx );
    Py_DECREF( par_dx );
    par_dx = NULL;

    CHECK_OBJECT( (PyObject *)par_dy );
    Py_DECREF( par_dy );
    par_dy = NULL;

    CHECK_OBJECT( (PyObject *)par_dz );
    Py_DECREF( par_dz );
    par_dz = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionRay );
    Py_DECREF( var_CollisionRay );
    var_CollisionRay = NULL;

    CHECK_OBJECT( (PyObject *)var_CollisionNode );
    Py_DECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    CHECK_OBJECT( (PyObject *)var_coll );
    Py_DECREF( var_coll );
    var_coll = NULL;

    CHECK_OBJECT( (PyObject *)var_collNode );
    Py_DECREF( var_collNode );
    var_collNode = NULL;

    CHECK_OBJECT( (PyObject *)var_collNodePath );
    Py_DECREF( var_collNodePath );
    var_collNodePath = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_name );
    Py_DECREF( par_name );
    par_name = NULL;

    CHECK_OBJECT( (PyObject *)par_ox );
    Py_DECREF( par_ox );
    par_ox = NULL;

    CHECK_OBJECT( (PyObject *)par_oy );
    Py_DECREF( par_oy );
    par_oy = NULL;

    CHECK_OBJECT( (PyObject *)par_oz );
    Py_DECREF( par_oz );
    par_oz = NULL;

    CHECK_OBJECT( (PyObject *)par_dx );
    Py_DECREF( par_dx );
    par_dx = NULL;

    CHECK_OBJECT( (PyObject *)par_dy );
    Py_DECREF( par_dy );
    par_dy = NULL;

    CHECK_OBJECT( (PyObject *)par_dz );
    Py_DECREF( par_dz );
    par_dz = NULL;

    CHECK_OBJECT( (PyObject *)par_fromCollide );
    Py_DECREF( par_fromCollide );
    par_fromCollide = NULL;

    CHECK_OBJECT( (PyObject *)par_intoCollide );
    Py_DECREF( par_intoCollide );
    par_intoCollide = NULL;

    Py_XDECREF( var_CollisionRay );
    var_CollisionRay = NULL;

    Py_XDECREF( var_CollisionNode );
    var_CollisionNode = NULL;

    Py_XDECREF( var_coll );
    var_coll = NULL;

    Py_XDECREF( var_collNode );
    var_collNode = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_stateFrom = python_pars[ 1 ];
    PyObject *par_target = python_pars[ 2 ];
    PyObject *par_useGeom = python_pars[ 3 ];
    PyObject *par_allowTexMat = python_pars[ 4 ];
    PyObject *par_win = python_pars[ 5 ];
    PyObject *var_MultitexReducer = NULL;
    PyObject *var_mr = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_name_1;
    int tmp_cmp_Eq_1;
    int tmp_cmp_Eq_2;
    int tmp_cmp_NotEq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_1ec8b1703c5ca7d38b5327cb40adc36e, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_MultitexReducer_tuple;
    frame_function->m_frame.f_lineno = 640;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 640;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_MultitexReducer );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 640;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_MultitexReducer == NULL );
    var_MultitexReducer = tmp_assign_source_1;

    tmp_called_name_1 = var_MultitexReducer;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_function->m_frame.f_lineno = 641;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 641;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_mr == NULL );
    var_mr = tmp_assign_source_2;

    tmp_compare_left_1 = par_target;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = Py_None;
    tmp_cmp_NotEq_1 = RICH_COMPARE_BOOL_NE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_NotEq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 642;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_NotEq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_called_instance_1 = var_mr;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_1 = par_target;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 643;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_setTarget, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 643;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_1:;
    tmp_called_instance_2 = var_mr;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_2 = par_useGeom;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 644;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_setUseGeom, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 644;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_mr;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_3 = par_allowTexMat;

    CHECK_OBJECT( tmp_args_element_name_3 );
    frame_function->m_frame.f_lineno = 645;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_setAllowTexMat, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 645;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_compare_left_2 = par_win;

    CHECK_OBJECT( tmp_compare_left_2 );
    tmp_compare_right_2 = Py_None;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_2, tmp_compare_right_2 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 647;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_source_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_base );

    if (unlikely( tmp_source_name_1 == NULL ))
    {
        tmp_source_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_base );
    }

    if ( tmp_source_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "base" );
        exception_tb = NULL;

        exception_lineno = 648;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_3 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_win );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 648;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = par_win;
        assert( old != NULL );
        par_win = tmp_assign_source_3;
        Py_DECREF( old );
    }

    branch_no_2:;
    tmp_compare_left_3 = par_stateFrom;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = Py_None;
    tmp_cmp_Eq_2 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Eq_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 650;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_cmp_Eq_2 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_called_instance_4 = var_mr;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_4 = par_self;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 651;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_scan, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 651;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_3;
    branch_no_3:;
    tmp_called_instance_5 = var_mr;

    CHECK_OBJECT( tmp_called_instance_5 );
    tmp_args_element_name_5 = par_self;

    CHECK_OBJECT( tmp_args_element_name_5 );
    tmp_args_element_name_6 = par_stateFrom;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 653;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS2( tmp_called_instance_5, const_str_plain_scan, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 653;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_3:;
    tmp_called_instance_6 = var_mr;

    CHECK_OBJECT( tmp_called_instance_6 );
    tmp_args_element_name_7 = par_win;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 654;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_6, const_str_plain_flatten, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 654;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_stateFrom, par_target, par_useGeom, par_allowTexMat, par_win, var_MultitexReducer, var_mr );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_stateFrom );
    Py_DECREF( par_stateFrom );
    par_stateFrom = NULL;

    CHECK_OBJECT( (PyObject *)par_target );
    Py_DECREF( par_target );
    par_target = NULL;

    CHECK_OBJECT( (PyObject *)par_useGeom );
    Py_DECREF( par_useGeom );
    par_useGeom = NULL;

    CHECK_OBJECT( (PyObject *)par_allowTexMat );
    Py_DECREF( par_allowTexMat );
    par_allowTexMat = NULL;

    CHECK_OBJECT( (PyObject *)par_win );
    Py_DECREF( par_win );
    par_win = NULL;

    CHECK_OBJECT( (PyObject *)var_MultitexReducer );
    Py_DECREF( var_MultitexReducer );
    var_MultitexReducer = NULL;

    CHECK_OBJECT( (PyObject *)var_mr );
    Py_DECREF( var_mr );
    var_mr = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_stateFrom );
    Py_DECREF( par_stateFrom );
    par_stateFrom = NULL;

    CHECK_OBJECT( (PyObject *)par_target );
    Py_DECREF( par_target );
    par_target = NULL;

    CHECK_OBJECT( (PyObject *)par_useGeom );
    Py_DECREF( par_useGeom );
    par_useGeom = NULL;

    CHECK_OBJECT( (PyObject *)par_allowTexMat );
    Py_DECREF( par_allowTexMat );
    par_allowTexMat = NULL;

    Py_XDECREF( par_win );
    par_win = NULL;

    Py_XDECREF( var_MultitexReducer );
    var_MultitexReducer = NULL;

    Py_XDECREF( var_mr );
    var_mr = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_left_name_1;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_dacf8d19a45379c1a042d986d0d4159e, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 659;
    tmp_len_arg_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findAllMatches, &PyTuple_GET_ITEM( const_tuple_str_digest_29bbf2a0ea668f7cb550eb66ebe90f9e_tuple, 0 ) );

    if ( tmp_len_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_left_name_1 = BUILTIN_LEN( tmp_len_arg_1 );
    Py_DECREF( tmp_len_arg_1 );
    if ( tmp_left_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    tmp_right_name_1 = const_int_pos_1;
    tmp_return_value = BINARY_OPERATION_SUB( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_left_name_1 );
    if ( tmp_return_value == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 659;
        type_description = "o";
        goto frame_exception_exit_1;
    }
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_stack = NULL;
    PyObject *var_np = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_list_element_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_b9b9d7c571a64c8ab56168796d8dcb06, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_print_value = const_str_digest_afc53e5a5c9626f0b132417ffd0373cd;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 665;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = PyList_New( 1 );
    tmp_list_element_1 = par_self;

    CHECK_OBJECT( tmp_list_element_1 );
    Py_INCREF( tmp_list_element_1 );
    PyList_SET_ITEM( tmp_assign_source_1, 0, tmp_list_element_1 );
    assert( var_stack == NULL );
    var_stack = tmp_assign_source_1;

    loop_start_1:;
    tmp_len_arg_1 = var_stack;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_cond_value_1 = BUILTIN_LEN( tmp_len_arg_1 );
    assert( tmp_cond_value_1 != NULL );
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_no_1;
    }
    else
    {
        goto branch_yes_1;
    }
    branch_yes_1:;
    goto loop_end_1;
    branch_no_1:;
    tmp_called_instance_1 = var_stack;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 668;
    tmp_assign_source_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_pop );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 668;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    {
        PyObject *old = var_np;
        var_np = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = var_np;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 670;
    tmp_called_instance_2 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_find, &PyTuple_GET_ITEM( const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple, 0 ) );

    if ( tmp_called_instance_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 670;
    tmp_cond_value_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_isEmpty );
    Py_DECREF( tmp_called_instance_2 );
    if ( tmp_cond_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 670;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 670;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_called_instance_4 = var_np;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 671;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_detachNode );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 671;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_2;
    branch_no_2:;
    tmp_source_name_1 = var_stack;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_extend );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 673;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_5 = var_np;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 673;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getChildren );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 673;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 673;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 673;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_end_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 667;
        type_description = "ooo";
        goto frame_exception_exit_1;
    }
    goto loop_start_1;
    loop_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_stack, var_np );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_stack );
    Py_DECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_stack );
    var_stack = NULL;

    Py_XDECREF( var_np );
    var_np = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_numSolidsInLeaves = python_pars[ 1 ];
    PyObject *var_colNps = NULL;
    PyObject *var_colNp = NULL;
    PyObject *var_node = NULL;
    PyObject *var_numSolids = NULL;
    PyObject *var_solids = NULL;
    PyObject *var_i = NULL;
    PyObject *var_solidTree = NULL;
    PyObject *var_root = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_range_arg_1;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_5e756e83abbf94b405c26bfd697e4eea, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 685;
    tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_1, const_str_plain_findAllMatches, &PyTuple_GET_ITEM( const_tuple_str_digest_d92ad2f0577d6ed9c07aa409a7ddded5_tuple, 0 ) );

    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 685;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_colNps == NULL );
    var_colNps = tmp_assign_source_1;

    tmp_iter_arg_1 = var_colNps;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_2 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description = "oooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_2;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_3 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooooo";
            frame_function->m_frame.f_lineno = 686;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_3;
        Py_XDECREF( old );
    }

    tmp_assign_source_4 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_4 );
    {
        PyObject *old = var_colNp;
        var_colNp = tmp_assign_source_4;
        Py_INCREF( var_colNp );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = var_colNp;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 687;
    tmp_assign_source_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_node );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 687;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_node;
        var_node = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_called_instance_3 = var_node;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 688;
    tmp_assign_source_6 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getNumSolids );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 688;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_numSolids;
        var_numSolids = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    tmp_compare_left_1 = var_numSolids;

    CHECK_OBJECT( tmp_compare_left_1 );
    tmp_compare_right_1 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 689;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    goto loop_start_1;
    branch_no_1:;
    tmp_assign_source_7 = PyList_New( 0 );
    {
        PyObject *old = var_solids;
        var_solids = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_range_arg_1 = var_numSolids;

    CHECK_OBJECT( tmp_range_arg_1 );
    tmp_iter_arg_2 = BUILTIN_RANGE( tmp_range_arg_1 );
    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_assign_source_8 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_8;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_9 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_9 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooooo";
            frame_function->m_frame.f_lineno = 693;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_9;
        Py_XDECREF( old );
    }

    tmp_assign_source_10 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_10 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_10;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_source_name_1 = var_solids;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 694;
        type_description = "oooooooooo";
        goto try_except_handler_3;
    }
    tmp_called_instance_4 = var_node;

    CHECK_OBJECT( tmp_called_instance_4 );
    tmp_args_element_name_2 = var_i;

    CHECK_OBJECT( tmp_args_element_name_2 );
    frame_function->m_frame.f_lineno = 694;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS1( tmp_called_instance_4, const_str_plain_getSolid, call_args );
    }

    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 694;
        type_description = "oooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 694;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 694;
        type_description = "oooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 693;
        type_description = "oooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    tmp_args_element_name_3 = var_solids;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 696;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_assign_source_11 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_5, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 696;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_solidTree;
        var_solidTree = tmp_assign_source_11;
        Py_XDECREF( old );
    }

    tmp_called_instance_6 = var_colNp;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 697;
    tmp_source_name_2 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getParent );
    if ( tmp_source_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_attachNewNode );
    Py_DECREF( tmp_source_name_2 );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_1 = const_str_digest_2fbcad0fe537265b904c373a7885697a;
    tmp_called_instance_7 = var_colNp;

    CHECK_OBJECT( tmp_called_instance_7 );
    frame_function->m_frame.f_lineno = 697;
    tmp_right_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getName );
    if ( tmp_right_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 697;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    Py_DECREF( tmp_right_name_1 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 697;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 697;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_12 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 697;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_root;
        var_root = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    tmp_source_name_3 = par_self;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_3 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_r_constructCollisionTree );
    if ( tmp_called_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    tmp_args_element_name_6 = var_solidTree;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_root;

    CHECK_OBJECT( tmp_args_element_name_7 );
    tmp_called_instance_8 = var_colNp;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 698;
    tmp_args_element_name_8 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getName );
    if ( tmp_args_element_name_8 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_3 );

        exception_lineno = 698;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 698;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS3( tmp_called_name_3, call_args );
    }

    Py_DECREF( tmp_called_name_3 );
    Py_DECREF( tmp_args_element_name_8 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 698;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_9 = var_colNp;

    CHECK_OBJECT( tmp_called_instance_9 );
    frame_function->m_frame.f_lineno = 699;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_9, const_str_plain_stash );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 699;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 686;
        type_description = "oooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_numSolidsInLeaves, var_colNps, var_colNp, var_node, var_numSolids, var_solids, var_i, var_solidTree, var_root );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_numSolidsInLeaves );
    Py_DECREF( par_numSolidsInLeaves );
    par_numSolidsInLeaves = NULL;

    CHECK_OBJECT( (PyObject *)var_colNps );
    Py_DECREF( var_colNps );
    var_colNps = NULL;

    Py_XDECREF( var_colNp );
    var_colNp = NULL;

    Py_XDECREF( var_node );
    var_node = NULL;

    Py_XDECREF( var_numSolids );
    var_numSolids = NULL;

    Py_XDECREF( var_solids );
    var_solids = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_solidTree );
    var_solidTree = NULL;

    Py_XDECREF( var_root );
    var_root = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_numSolidsInLeaves );
    Py_DECREF( par_numSolidsInLeaves );
    par_numSolidsInLeaves = NULL;

    Py_XDECREF( var_colNps );
    var_colNps = NULL;

    Py_XDECREF( var_colNp );
    var_colNp = NULL;

    Py_XDECREF( var_node );
    var_node = NULL;

    Py_XDECREF( var_numSolids );
    var_numSolids = NULL;

    Py_XDECREF( var_solids );
    var_solids = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_solidTree );
    var_solidTree = NULL;

    Py_XDECREF( var_root );
    var_root = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_solids = python_pars[ 1 ];
    PyObject *par_numSolidsInLeaves = python_pars[ 2 ];
    PyObject *var_origins = NULL;
    PyObject *var_avgX = NULL;
    PyObject *var_avgY = NULL;
    PyObject *var_avgZ = NULL;
    PyObject *var_minX = NULL;
    PyObject *var_minY = NULL;
    PyObject *var_minZ = NULL;
    PyObject *var_maxX = NULL;
    PyObject *var_maxY = NULL;
    PyObject *var_maxZ = NULL;
    PyObject *var_solid = NULL;
    PyObject *var_origin = NULL;
    PyObject *var_x = NULL;
    PyObject *var_y = NULL;
    PyObject *var_z = NULL;
    PyObject *var_extentX = NULL;
    PyObject *var_extentY = NULL;
    PyObject *var_extentZ = NULL;
    PyObject *var_maxExtent = NULL;
    PyObject *var_xyzSolids = NULL;
    PyObject *var_XyzSolids = NULL;
    PyObject *var_xYzSolids = NULL;
    PyObject *var_XYzSolids = NULL;
    PyObject *var_xyZSolids = NULL;
    PyObject *var_XyZSolids = NULL;
    PyObject *var_xYZSolids = NULL;
    PyObject *var_XYZSolids = NULL;
    PyObject *var_midX = NULL;
    PyObject *var_midY = NULL;
    PyObject *var_midZ = NULL;
    PyObject *var_i = NULL;
    PyObject *var_newSolids = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_instance_6;
    PyObject *tmp_called_instance_7;
    PyObject *tmp_called_instance_8;
    PyObject *tmp_called_instance_9;
    PyObject *tmp_called_instance_10;
    PyObject *tmp_called_instance_11;
    PyObject *tmp_called_instance_12;
    PyObject *tmp_called_instance_13;
    PyObject *tmp_called_instance_14;
    PyObject *tmp_called_instance_15;
    PyObject *tmp_called_instance_16;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    int tmp_cmp_Lt_1;
    int tmp_cmp_Lt_2;
    int tmp_cmp_Lt_3;
    int tmp_cmp_Lt_4;
    int tmp_cmp_Lt_5;
    int tmp_cmp_Lt_6;
    int tmp_cmp_Lt_7;
    int tmp_cmp_LtE_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_left_2;
    PyObject *tmp_compare_left_3;
    PyObject *tmp_compare_left_4;
    PyObject *tmp_compare_left_5;
    PyObject *tmp_compare_left_6;
    PyObject *tmp_compare_left_7;
    PyObject *tmp_compare_left_8;
    PyObject *tmp_compare_left_9;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_compare_right_2;
    PyObject *tmp_compare_right_3;
    PyObject *tmp_compare_right_4;
    PyObject *tmp_compare_right_5;
    PyObject *tmp_compare_right_6;
    PyObject *tmp_compare_right_7;
    PyObject *tmp_compare_right_8;
    PyObject *tmp_compare_right_9;
    PyObject *tmp_compexpr_left_1;
    PyObject *tmp_compexpr_left_2;
    PyObject *tmp_compexpr_left_3;
    PyObject *tmp_compexpr_left_4;
    PyObject *tmp_compexpr_left_5;
    PyObject *tmp_compexpr_left_6;
    PyObject *tmp_compexpr_right_1;
    PyObject *tmp_compexpr_right_2;
    PyObject *tmp_compexpr_right_3;
    PyObject *tmp_compexpr_right_4;
    PyObject *tmp_compexpr_right_5;
    PyObject *tmp_compexpr_right_6;
    int tmp_cond_truth_1;
    int tmp_cond_truth_2;
    int tmp_cond_truth_3;
    int tmp_cond_truth_4;
    int tmp_cond_truth_5;
    int tmp_cond_truth_6;
    int tmp_cond_truth_7;
    int tmp_cond_truth_8;
    int tmp_cond_truth_9;
    int tmp_cond_truth_10;
    int tmp_cond_truth_11;
    PyObject *tmp_cond_value_1;
    PyObject *tmp_cond_value_2;
    PyObject *tmp_cond_value_3;
    PyObject *tmp_cond_value_4;
    PyObject *tmp_cond_value_5;
    PyObject *tmp_cond_value_6;
    PyObject *tmp_cond_value_7;
    PyObject *tmp_cond_value_8;
    PyObject *tmp_cond_value_9;
    PyObject *tmp_cond_value_10;
    PyObject *tmp_cond_value_11;
    bool tmp_is_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_left_name_3;
    PyObject *tmp_left_name_4;
    PyObject *tmp_left_name_5;
    PyObject *tmp_left_name_6;
    PyObject *tmp_left_name_7;
    PyObject *tmp_left_name_8;
    PyObject *tmp_left_name_9;
    PyObject *tmp_left_name_10;
    PyObject *tmp_left_name_11;
    PyObject *tmp_left_name_12;
    PyObject *tmp_left_name_13;
    PyObject *tmp_left_name_14;
    PyObject *tmp_left_name_15;
    PyObject *tmp_left_name_16;
    PyObject *tmp_left_name_17;
    PyObject *tmp_left_name_18;
    PyObject *tmp_len_arg_1;
    PyObject *tmp_len_arg_2;
    PyObject *tmp_len_arg_3;
    PyObject *tmp_len_arg_4;
    PyObject *tmp_len_arg_5;
    PyObject *tmp_len_arg_6;
    PyObject *tmp_len_arg_7;
    PyObject *tmp_len_arg_8;
    PyObject *tmp_len_arg_9;
    PyObject *tmp_len_arg_10;
    PyObject *tmp_len_arg_11;
    PyObject *tmp_len_arg_12;
    PyObject *tmp_len_arg_13;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    int tmp_or_left_truth_1;
    int tmp_or_left_truth_2;
    int tmp_or_left_truth_3;
    PyObject *tmp_or_left_value_1;
    PyObject *tmp_or_left_value_2;
    PyObject *tmp_or_left_value_3;
    PyObject *tmp_or_right_value_1;
    PyObject *tmp_or_right_value_2;
    PyObject *tmp_or_right_value_3;
    PyObject *tmp_range_arg_1;
    bool tmp_result;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_right_name_3;
    PyObject *tmp_right_name_4;
    PyObject *tmp_right_name_5;
    PyObject *tmp_right_name_6;
    PyObject *tmp_right_name_7;
    PyObject *tmp_right_name_8;
    PyObject *tmp_right_name_9;
    PyObject *tmp_right_name_10;
    PyObject *tmp_right_name_11;
    PyObject *tmp_right_name_12;
    PyObject *tmp_right_name_13;
    PyObject *tmp_right_name_14;
    PyObject *tmp_right_name_15;
    PyObject *tmp_right_name_16;
    PyObject *tmp_right_name_17;
    PyObject *tmp_right_name_18;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    PyObject *tmp_source_name_8;
    PyObject *tmp_source_name_9;
    PyObject *tmp_source_name_10;
    PyObject *tmp_source_name_11;
    PyObject *tmp_source_name_12;
    PyObject *tmp_source_name_13;
    PyObject *tmp_source_name_14;
    PyObject *tmp_source_name_15;
    PyObject *tmp_source_name_16;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscribed_name_2;
    PyObject *tmp_subscribed_name_3;
    PyObject *tmp_subscribed_name_4;
    PyObject *tmp_subscribed_name_5;
    PyObject *tmp_subscribed_name_6;
    PyObject *tmp_subscribed_name_7;
    PyObject *tmp_subscribed_name_8;
    PyObject *tmp_subscribed_name_9;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_subscript_name_2;
    PyObject *tmp_subscript_name_3;
    PyObject *tmp_subscript_name_4;
    PyObject *tmp_subscript_name_5;
    PyObject *tmp_subscript_name_6;
    PyObject *tmp_subscript_name_7;
    PyObject *tmp_subscript_name_8;
    PyObject *tmp_subscript_name_9;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_0f643037e6b0a7646115bb655f2d42a1, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_len_arg_1 = par_solids;

    CHECK_OBJECT( tmp_len_arg_1 );
    tmp_compare_left_1 = BUILTIN_LEN( tmp_len_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 706;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_compare_right_1 );
    tmp_cmp_LtE_1 = RICH_COMPARE_BOOL_LE( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_LtE_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 706;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_LtE_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_return_value = par_solids;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto frame_return_exit_1;
    branch_no_1:;
    tmp_assign_source_1 = PyList_New( 0 );
    assert( var_origins == NULL );
    var_origins = tmp_assign_source_1;

    tmp_assign_source_2 = const_int_0;
    assert( var_avgX == NULL );
    Py_INCREF( tmp_assign_source_2 );
    var_avgX = tmp_assign_source_2;

    tmp_assign_source_3 = const_int_0;
    assert( var_avgY == NULL );
    Py_INCREF( tmp_assign_source_3 );
    var_avgY = tmp_assign_source_3;

    tmp_assign_source_4 = const_int_0;
    assert( var_avgZ == NULL );
    Py_INCREF( tmp_assign_source_4 );
    var_avgZ = tmp_assign_source_4;

    tmp_assign_source_5 = Py_None;
    assert( var_minX == NULL );
    Py_INCREF( tmp_assign_source_5 );
    var_minX = tmp_assign_source_5;

    tmp_assign_source_6 = Py_None;
    assert( var_minY == NULL );
    Py_INCREF( tmp_assign_source_6 );
    var_minY = tmp_assign_source_6;

    tmp_assign_source_7 = Py_None;
    assert( var_minZ == NULL );
    Py_INCREF( tmp_assign_source_7 );
    var_minZ = tmp_assign_source_7;

    tmp_assign_source_8 = Py_None;
    assert( var_maxX == NULL );
    Py_INCREF( tmp_assign_source_8 );
    var_maxX = tmp_assign_source_8;

    tmp_assign_source_9 = Py_None;
    assert( var_maxY == NULL );
    Py_INCREF( tmp_assign_source_9 );
    var_maxY = tmp_assign_source_9;

    tmp_assign_source_10 = Py_None;
    assert( var_maxZ == NULL );
    Py_INCREF( tmp_assign_source_10 );
    var_maxZ = tmp_assign_source_10;

    tmp_iter_arg_1 = par_solids;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_11 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_11;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_12 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_12 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooooooooooooooooooooooooooooooo";
            frame_function->m_frame.f_lineno = 712;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_12;
        Py_XDECREF( old );
    }

    tmp_assign_source_13 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_13 );
    {
        PyObject *old = var_solid;
        var_solid = tmp_assign_source_13;
        Py_INCREF( var_solid );
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = var_solid;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 713;
    tmp_assign_source_14 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_getCollisionOrigin );
    if ( tmp_assign_source_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 713;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_origin;
        var_origin = tmp_assign_source_14;
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = var_origins;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_1 = var_origin;

    CHECK_OBJECT( tmp_args_element_name_1 );
    frame_function->m_frame.f_lineno = 714;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_append, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 714;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_3 = var_origin;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 715;
    tmp_assign_source_15 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_getX );
    if ( tmp_assign_source_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_15;
        Py_XDECREF( old );
    }

    tmp_called_instance_4 = var_origin;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 715;
    tmp_assign_source_16 = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_getY );
    if ( tmp_assign_source_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_y;
        var_y = tmp_assign_source_16;
        Py_XDECREF( old );
    }

    tmp_called_instance_5 = var_origin;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 715;
    tmp_assign_source_17 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_getZ );
    if ( tmp_assign_source_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 715;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_z;
        var_z = tmp_assign_source_17;
        Py_XDECREF( old );
    }

    tmp_left_name_1 = var_avgX;

    if ( tmp_left_name_1 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgX" );
        exception_tb = NULL;

        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_1 = var_x;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_1, tmp_right_name_1 );
    tmp_assign_source_18 = tmp_left_name_1;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    var_avgX = tmp_assign_source_18;

    tmp_left_name_2 = var_avgY;

    if ( tmp_left_name_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgY" );
        exception_tb = NULL;

        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_2 = var_y;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_2, tmp_right_name_2 );
    tmp_assign_source_19 = tmp_left_name_2;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    var_avgY = tmp_assign_source_19;

    tmp_left_name_3 = var_avgZ;

    if ( tmp_left_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgZ" );
        exception_tb = NULL;

        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    tmp_right_name_3 = var_z;

    CHECK_OBJECT( tmp_right_name_3 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_3, tmp_right_name_3 );
    tmp_assign_source_20 = tmp_left_name_3;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 716;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    var_avgZ = tmp_assign_source_20;

    tmp_compare_left_2 = var_minX;

    if ( tmp_compare_left_2 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minX" );
        exception_tb = NULL;

        exception_lineno = 717;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    tmp_compare_right_2 = Py_None;
    tmp_is_1 = ( tmp_compare_left_2 == tmp_compare_right_2 );
    if ( tmp_is_1 )
    {
        goto branch_yes_2;
    }
    else
    {
        goto branch_no_2;
    }
    branch_yes_2:;
    tmp_assign_source_21 = var_x;

    CHECK_OBJECT( tmp_assign_source_21 );
    {
        PyObject *old = var_minX;
        var_minX = tmp_assign_source_21;
        Py_INCREF( var_minX );
        Py_XDECREF( old );
    }

    tmp_assign_source_22 = var_y;

    CHECK_OBJECT( tmp_assign_source_22 );
    {
        PyObject *old = var_minY;
        var_minY = tmp_assign_source_22;
        Py_INCREF( var_minY );
        Py_XDECREF( old );
    }

    tmp_assign_source_23 = var_z;

    CHECK_OBJECT( tmp_assign_source_23 );
    {
        PyObject *old = var_minZ;
        var_minZ = tmp_assign_source_23;
        Py_INCREF( var_minZ );
        Py_XDECREF( old );
    }

    tmp_assign_source_24 = var_x;

    CHECK_OBJECT( tmp_assign_source_24 );
    {
        PyObject *old = var_maxX;
        var_maxX = tmp_assign_source_24;
        Py_INCREF( var_maxX );
        Py_XDECREF( old );
    }

    tmp_assign_source_25 = var_y;

    CHECK_OBJECT( tmp_assign_source_25 );
    {
        PyObject *old = var_maxY;
        var_maxY = tmp_assign_source_25;
        Py_INCREF( var_maxY );
        Py_XDECREF( old );
    }

    tmp_assign_source_26 = var_z;

    CHECK_OBJECT( tmp_assign_source_26 );
    {
        PyObject *old = var_maxZ;
        var_maxZ = tmp_assign_source_26;
        Py_INCREF( var_maxZ );
        Py_XDECREF( old );
    }

    goto branch_end_2;
    branch_no_2:;
    tmp_called_name_1 = LOOKUP_BUILTIN( const_str_plain_min );
    assert( tmp_called_name_1 != NULL );
    tmp_args_element_name_2 = var_x;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_minX;

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minX" );
        exception_tb = NULL;

        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 721;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3 };
        tmp_assign_source_27 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_assign_source_27 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_minX;
        var_minX = tmp_assign_source_27;
        Py_XDECREF( old );
    }

    tmp_called_name_2 = LOOKUP_BUILTIN( const_str_plain_min );
    assert( tmp_called_name_2 != NULL );
    tmp_args_element_name_4 = var_y;

    CHECK_OBJECT( tmp_args_element_name_4 );
    tmp_args_element_name_5 = var_minY;

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minY" );
        exception_tb = NULL;

        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 721;
    {
        PyObject *call_args[] = { tmp_args_element_name_4, tmp_args_element_name_5 };
        tmp_assign_source_28 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_assign_source_28 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_minY;
        var_minY = tmp_assign_source_28;
        Py_XDECREF( old );
    }

    tmp_called_name_3 = LOOKUP_BUILTIN( const_str_plain_min );
    assert( tmp_called_name_3 != NULL );
    tmp_args_element_name_6 = var_z;

    CHECK_OBJECT( tmp_args_element_name_6 );
    tmp_args_element_name_7 = var_minZ;

    if ( tmp_args_element_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minZ" );
        exception_tb = NULL;

        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 721;
    {
        PyObject *call_args[] = { tmp_args_element_name_6, tmp_args_element_name_7 };
        tmp_assign_source_29 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    if ( tmp_assign_source_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 721;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_minZ;
        var_minZ = tmp_assign_source_29;
        Py_XDECREF( old );
    }

    tmp_called_name_4 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_4 != NULL );
    tmp_args_element_name_8 = var_x;

    CHECK_OBJECT( tmp_args_element_name_8 );
    tmp_args_element_name_9 = var_maxX;

    if ( tmp_args_element_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxX" );
        exception_tb = NULL;

        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 722;
    {
        PyObject *call_args[] = { tmp_args_element_name_8, tmp_args_element_name_9 };
        tmp_assign_source_30 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_assign_source_30 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_maxX;
        var_maxX = tmp_assign_source_30;
        Py_XDECREF( old );
    }

    tmp_called_name_5 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_5 != NULL );
    tmp_args_element_name_10 = var_y;

    CHECK_OBJECT( tmp_args_element_name_10 );
    tmp_args_element_name_11 = var_maxY;

    if ( tmp_args_element_name_11 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxY" );
        exception_tb = NULL;

        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 722;
    {
        PyObject *call_args[] = { tmp_args_element_name_10, tmp_args_element_name_11 };
        tmp_assign_source_31 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    if ( tmp_assign_source_31 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_maxY;
        var_maxY = tmp_assign_source_31;
        Py_XDECREF( old );
    }

    tmp_called_name_6 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_6 != NULL );
    tmp_args_element_name_12 = var_z;

    CHECK_OBJECT( tmp_args_element_name_12 );
    tmp_args_element_name_13 = var_maxZ;

    if ( tmp_args_element_name_13 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxZ" );
        exception_tb = NULL;

        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }

    frame_function->m_frame.f_lineno = 722;
    {
        PyObject *call_args[] = { tmp_args_element_name_12, tmp_args_element_name_13 };
        tmp_assign_source_32 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    if ( tmp_assign_source_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 722;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_maxZ;
        var_maxZ = tmp_assign_source_32;
        Py_XDECREF( old );
    }

    branch_end_2:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 712;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_left_name_4 = var_avgX;

    if ( tmp_left_name_4 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgX" );
        exception_tb = NULL;

        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_len_arg_2 = par_solids;

    CHECK_OBJECT( tmp_len_arg_2 );
    tmp_right_name_4 = BUILTIN_LEN( tmp_len_arg_2 );
    if ( tmp_right_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceDivide, &tmp_left_name_4, tmp_right_name_4 );
    tmp_assign_source_33 = tmp_left_name_4;
    Py_DECREF( tmp_right_name_4 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_avgX = tmp_assign_source_33;

    tmp_left_name_5 = var_avgY;

    if ( tmp_left_name_5 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgY" );
        exception_tb = NULL;

        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_len_arg_3 = par_solids;

    CHECK_OBJECT( tmp_len_arg_3 );
    tmp_right_name_5 = BUILTIN_LEN( tmp_len_arg_3 );
    if ( tmp_right_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceDivide, &tmp_left_name_5, tmp_right_name_5 );
    tmp_assign_source_34 = tmp_left_name_5;
    Py_DECREF( tmp_right_name_5 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_avgY = tmp_assign_source_34;

    tmp_left_name_6 = var_avgZ;

    if ( tmp_left_name_6 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "avgZ" );
        exception_tb = NULL;

        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_len_arg_4 = par_solids;

    CHECK_OBJECT( tmp_len_arg_4 );
    tmp_right_name_6 = BUILTIN_LEN( tmp_len_arg_4 );
    if ( tmp_right_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_result = BINARY_OPERATION_INPLACE( PyNumber_InPlaceDivide, &tmp_left_name_6, tmp_right_name_6 );
    tmp_assign_source_35 = tmp_left_name_6;
    Py_DECREF( tmp_right_name_6 );
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 723;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_avgZ = tmp_assign_source_35;

    tmp_left_name_7 = var_maxX;

    if ( tmp_left_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxX" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_7 = var_minX;

    if ( tmp_right_name_7 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minX" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_36 = BINARY_OPERATION_SUB( tmp_left_name_7, tmp_right_name_7 );
    if ( tmp_assign_source_36 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_extentX == NULL );
    var_extentX = tmp_assign_source_36;

    tmp_left_name_8 = var_maxY;

    if ( tmp_left_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxY" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_8 = var_minY;

    if ( tmp_right_name_8 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minY" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_37 = BINARY_OPERATION_SUB( tmp_left_name_8, tmp_right_name_8 );
    if ( tmp_assign_source_37 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_extentY == NULL );
    var_extentY = tmp_assign_source_37;

    tmp_left_name_9 = var_maxZ;

    if ( tmp_left_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "maxZ" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_right_name_9 = var_minZ;

    if ( tmp_right_name_9 == NULL )
    {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "local variable '%s' referenced before assignment", "minZ" );
        exception_tb = NULL;

        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_assign_source_38 = BINARY_OPERATION_SUB( tmp_left_name_9, tmp_right_name_9 );
    if ( tmp_assign_source_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 724;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_extentZ == NULL );
    var_extentZ = tmp_assign_source_38;

    tmp_called_name_7 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_7 != NULL );
    tmp_called_name_8 = LOOKUP_BUILTIN( const_str_plain_max );
    assert( tmp_called_name_8 != NULL );
    tmp_args_element_name_15 = var_extentX;

    CHECK_OBJECT( tmp_args_element_name_15 );
    tmp_args_element_name_16 = var_extentY;

    CHECK_OBJECT( tmp_args_element_name_16 );
    frame_function->m_frame.f_lineno = 725;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_args_element_name_14 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    if ( tmp_args_element_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_args_element_name_17 = var_extentZ;

    CHECK_OBJECT( tmp_args_element_name_17 );
    frame_function->m_frame.f_lineno = 725;
    {
        PyObject *call_args[] = { tmp_args_element_name_14, tmp_args_element_name_17 };
        tmp_assign_source_39 = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_args_element_name_14 );
    if ( tmp_assign_source_39 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 725;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( var_maxExtent == NULL );
    var_maxExtent = tmp_assign_source_39;

    tmp_assign_source_40 = PyList_New( 0 );
    assert( var_xyzSolids == NULL );
    var_xyzSolids = tmp_assign_source_40;

    tmp_assign_source_41 = PyList_New( 0 );
    assert( var_XyzSolids == NULL );
    var_XyzSolids = tmp_assign_source_41;

    tmp_assign_source_42 = PyList_New( 0 );
    assert( var_xYzSolids == NULL );
    var_xYzSolids = tmp_assign_source_42;

    tmp_assign_source_43 = PyList_New( 0 );
    assert( var_XYzSolids == NULL );
    var_XYzSolids = tmp_assign_source_43;

    tmp_assign_source_44 = PyList_New( 0 );
    assert( var_xyZSolids == NULL );
    var_xyZSolids = tmp_assign_source_44;

    tmp_assign_source_45 = PyList_New( 0 );
    assert( var_XyZSolids == NULL );
    var_XyZSolids = tmp_assign_source_45;

    tmp_assign_source_46 = PyList_New( 0 );
    assert( var_xYZSolids == NULL );
    var_xYZSolids = tmp_assign_source_46;

    tmp_assign_source_47 = PyList_New( 0 );
    assert( var_XYZSolids == NULL );
    var_XYZSolids = tmp_assign_source_47;

    tmp_assign_source_48 = var_avgX;

    CHECK_OBJECT( tmp_assign_source_48 );
    assert( var_midX == NULL );
    Py_INCREF( tmp_assign_source_48 );
    var_midX = tmp_assign_source_48;

    tmp_assign_source_49 = var_avgY;

    CHECK_OBJECT( tmp_assign_source_49 );
    assert( var_midY == NULL );
    Py_INCREF( tmp_assign_source_49 );
    var_midY = tmp_assign_source_49;

    tmp_assign_source_50 = var_avgZ;

    CHECK_OBJECT( tmp_assign_source_50 );
    assert( var_midZ == NULL );
    Py_INCREF( tmp_assign_source_50 );
    var_midZ = tmp_assign_source_50;

    tmp_compexpr_left_1 = var_extentX;

    CHECK_OBJECT( tmp_compexpr_left_1 );
    tmp_left_name_10 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_10 );
    tmp_right_name_10 = const_float_0_75;
    tmp_compexpr_right_1 = BINARY_OPERATION_MUL( tmp_left_name_10, tmp_right_name_10 );
    if ( tmp_compexpr_right_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_1 = RICH_COMPARE_LT( tmp_compexpr_left_1, tmp_compexpr_right_1 );
    Py_DECREF( tmp_compexpr_right_1 );
    if ( tmp_or_left_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_1 = CHECK_IF_TRUE( tmp_or_left_value_1 );
    if ( tmp_or_left_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_1 );

        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_1 == 1 )
    {
        goto or_left_1;
    }
    else
    {
        goto or_right_1;
    }
    or_right_1:;
    Py_DECREF( tmp_or_left_value_1 );
    tmp_compexpr_left_2 = var_extentX;

    CHECK_OBJECT( tmp_compexpr_left_2 );
    tmp_left_name_11 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_11 );
    tmp_right_name_11 = const_float_1_25;
    tmp_compexpr_right_2 = BINARY_OPERATION_MUL( tmp_left_name_11, tmp_right_name_11 );
    if ( tmp_compexpr_right_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_1 = RICH_COMPARE_GT( tmp_compexpr_left_2, tmp_compexpr_right_2 );
    Py_DECREF( tmp_compexpr_right_2 );
    if ( tmp_or_right_value_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_1 = tmp_or_right_value_1;
    goto or_end_1;
    or_left_1:;
    tmp_cond_value_1 = tmp_or_left_value_1;
    or_end_1:;
    tmp_cond_truth_1 = CHECK_IF_TRUE( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_1 );

        exception_lineno = 740;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_1 );
    if ( tmp_cond_truth_1 == 1 )
    {
        goto branch_yes_3;
    }
    else
    {
        goto branch_no_3;
    }
    branch_yes_3:;
    tmp_left_name_12 = var_midX;

    CHECK_OBJECT( tmp_left_name_12 );
    tmp_right_name_12 = var_maxExtent;

    CHECK_OBJECT( tmp_right_name_12 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_12, tmp_right_name_12 );
    tmp_assign_source_51 = tmp_left_name_12;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 741;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_midX = tmp_assign_source_51;

    branch_no_3:;
    tmp_compexpr_left_3 = var_extentY;

    CHECK_OBJECT( tmp_compexpr_left_3 );
    tmp_left_name_13 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_13 );
    tmp_right_name_13 = const_float_0_75;
    tmp_compexpr_right_3 = BINARY_OPERATION_MUL( tmp_left_name_13, tmp_right_name_13 );
    if ( tmp_compexpr_right_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_2 = RICH_COMPARE_LT( tmp_compexpr_left_3, tmp_compexpr_right_3 );
    Py_DECREF( tmp_compexpr_right_3 );
    if ( tmp_or_left_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_2 = CHECK_IF_TRUE( tmp_or_left_value_2 );
    if ( tmp_or_left_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_2 );

        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_2 == 1 )
    {
        goto or_left_2;
    }
    else
    {
        goto or_right_2;
    }
    or_right_2:;
    Py_DECREF( tmp_or_left_value_2 );
    tmp_compexpr_left_4 = var_extentY;

    CHECK_OBJECT( tmp_compexpr_left_4 );
    tmp_left_name_14 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_14 );
    tmp_right_name_14 = const_float_1_25;
    tmp_compexpr_right_4 = BINARY_OPERATION_MUL( tmp_left_name_14, tmp_right_name_14 );
    if ( tmp_compexpr_right_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_2 = RICH_COMPARE_GT( tmp_compexpr_left_4, tmp_compexpr_right_4 );
    Py_DECREF( tmp_compexpr_right_4 );
    if ( tmp_or_right_value_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_2 = tmp_or_right_value_2;
    goto or_end_2;
    or_left_2:;
    tmp_cond_value_2 = tmp_or_left_value_2;
    or_end_2:;
    tmp_cond_truth_2 = CHECK_IF_TRUE( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_2 );

        exception_lineno = 742;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_2 );
    if ( tmp_cond_truth_2 == 1 )
    {
        goto branch_yes_4;
    }
    else
    {
        goto branch_no_4;
    }
    branch_yes_4:;
    tmp_left_name_15 = var_midY;

    CHECK_OBJECT( tmp_left_name_15 );
    tmp_right_name_15 = var_maxExtent;

    CHECK_OBJECT( tmp_right_name_15 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_15, tmp_right_name_15 );
    tmp_assign_source_52 = tmp_left_name_15;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 743;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_midY = tmp_assign_source_52;

    branch_no_4:;
    tmp_compexpr_left_5 = var_extentZ;

    CHECK_OBJECT( tmp_compexpr_left_5 );
    tmp_left_name_16 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_16 );
    tmp_right_name_16 = const_float_0_75;
    tmp_compexpr_right_5 = BINARY_OPERATION_MUL( tmp_left_name_16, tmp_right_name_16 );
    if ( tmp_compexpr_right_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_value_3 = RICH_COMPARE_LT( tmp_compexpr_left_5, tmp_compexpr_right_5 );
    Py_DECREF( tmp_compexpr_right_5 );
    if ( tmp_or_left_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_left_truth_3 = CHECK_IF_TRUE( tmp_or_left_value_3 );
    if ( tmp_or_left_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_or_left_value_3 );

        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    if ( tmp_or_left_truth_3 == 1 )
    {
        goto or_left_3;
    }
    else
    {
        goto or_right_3;
    }
    or_right_3:;
    Py_DECREF( tmp_or_left_value_3 );
    tmp_compexpr_left_6 = var_extentZ;

    CHECK_OBJECT( tmp_compexpr_left_6 );
    tmp_left_name_17 = var_maxExtent;

    CHECK_OBJECT( tmp_left_name_17 );
    tmp_right_name_17 = const_float_1_25;
    tmp_compexpr_right_6 = BINARY_OPERATION_MUL( tmp_left_name_17, tmp_right_name_17 );
    if ( tmp_compexpr_right_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_or_right_value_3 = RICH_COMPARE_GT( tmp_compexpr_left_6, tmp_compexpr_right_6 );
    Py_DECREF( tmp_compexpr_right_6 );
    if ( tmp_or_right_value_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_cond_value_3 = tmp_or_right_value_3;
    goto or_end_3;
    or_left_3:;
    tmp_cond_value_3 = tmp_or_left_value_3;
    or_end_3:;
    tmp_cond_truth_3 = CHECK_IF_TRUE( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_3 );

        exception_lineno = 744;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_3 );
    if ( tmp_cond_truth_3 == 1 )
    {
        goto branch_yes_5;
    }
    else
    {
        goto branch_no_5;
    }
    branch_yes_5:;
    tmp_left_name_18 = var_midZ;

    CHECK_OBJECT( tmp_left_name_18 );
    tmp_right_name_18 = var_maxExtent;

    CHECK_OBJECT( tmp_right_name_18 );
    tmp_result = BINARY_OPERATION_ADD_INPLACE( &tmp_left_name_18, tmp_right_name_18 );
    tmp_assign_source_53 = tmp_left_name_18;
    if ( tmp_result == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 745;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    var_midZ = tmp_assign_source_53;

    branch_no_5:;
    tmp_len_arg_5 = par_solids;

    CHECK_OBJECT( tmp_len_arg_5 );
    tmp_range_arg_1 = BUILTIN_LEN( tmp_len_arg_5 );
    if ( tmp_range_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 746;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_iter_arg_2 = BUILTIN_RANGE( tmp_range_arg_1 );
    Py_DECREF( tmp_range_arg_1 );
    if ( tmp_iter_arg_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 746;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_54 = MAKE_ITERATOR( tmp_iter_arg_2 );
    Py_DECREF( tmp_iter_arg_2 );
    if ( tmp_assign_source_54 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 746;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_2__for_iterator == NULL );
    tmp_for_loop_2__for_iterator = tmp_assign_source_54;

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_55 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_55 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "ooooooooooooooooooooooooooooooooooo";
            frame_function->m_frame.f_lineno = 746;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_55;
        Py_XDECREF( old );
    }

    tmp_assign_source_56 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_56 );
    {
        PyObject *old = var_i;
        var_i = tmp_assign_source_56;
        Py_INCREF( var_i );
        Py_XDECREF( old );
    }

    tmp_subscribed_name_1 = var_origins;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = var_i;

    CHECK_OBJECT( tmp_subscript_name_1 );
    tmp_assign_source_57 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_assign_source_57 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 747;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_origin;
        var_origin = tmp_assign_source_57;
        Py_XDECREF( old );
    }

    tmp_called_instance_6 = var_origin;

    CHECK_OBJECT( tmp_called_instance_6 );
    frame_function->m_frame.f_lineno = 748;
    tmp_assign_source_58 = CALL_METHOD_NO_ARGS( tmp_called_instance_6, const_str_plain_getX );
    if ( tmp_assign_source_58 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 748;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_x;
        var_x = tmp_assign_source_58;
        Py_XDECREF( old );
    }

    tmp_called_instance_7 = var_origin;

    CHECK_OBJECT( tmp_called_instance_7 );
    frame_function->m_frame.f_lineno = 748;
    tmp_assign_source_59 = CALL_METHOD_NO_ARGS( tmp_called_instance_7, const_str_plain_getY );
    if ( tmp_assign_source_59 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 748;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_y;
        var_y = tmp_assign_source_59;
        Py_XDECREF( old );
    }

    tmp_called_instance_8 = var_origin;

    CHECK_OBJECT( tmp_called_instance_8 );
    frame_function->m_frame.f_lineno = 748;
    tmp_assign_source_60 = CALL_METHOD_NO_ARGS( tmp_called_instance_8, const_str_plain_getZ );
    if ( tmp_assign_source_60 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 748;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    {
        PyObject *old = var_z;
        var_z = tmp_assign_source_60;
        Py_XDECREF( old );
    }

    tmp_compare_left_3 = var_x;

    CHECK_OBJECT( tmp_compare_left_3 );
    tmp_compare_right_3 = var_midX;

    CHECK_OBJECT( tmp_compare_right_3 );
    tmp_cmp_Lt_1 = RICH_COMPARE_BOOL_LT( tmp_compare_left_3, tmp_compare_right_3 );
    if ( tmp_cmp_Lt_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 749;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_1 == 1 )
    {
        goto branch_yes_6;
    }
    else
    {
        goto branch_no_6;
    }
    branch_yes_6:;
    tmp_compare_left_4 = var_y;

    CHECK_OBJECT( tmp_compare_left_4 );
    tmp_compare_right_4 = var_midY;

    CHECK_OBJECT( tmp_compare_right_4 );
    tmp_cmp_Lt_2 = RICH_COMPARE_BOOL_LT( tmp_compare_left_4, tmp_compare_right_4 );
    if ( tmp_cmp_Lt_2 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 750;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_2 == 1 )
    {
        goto branch_yes_7;
    }
    else
    {
        goto branch_no_7;
    }
    branch_yes_7:;
    tmp_compare_left_5 = var_z;

    CHECK_OBJECT( tmp_compare_left_5 );
    tmp_compare_right_5 = var_midZ;

    CHECK_OBJECT( tmp_compare_right_5 );
    tmp_cmp_Lt_3 = RICH_COMPARE_BOOL_LT( tmp_compare_left_5, tmp_compare_right_5 );
    if ( tmp_cmp_Lt_3 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 751;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_3 == 1 )
    {
        goto branch_yes_8;
    }
    else
    {
        goto branch_no_8;
    }
    branch_yes_8:;
    tmp_source_name_1 = var_xyzSolids;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_9 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_append );
    if ( tmp_called_name_9 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_2 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_2 );
    tmp_subscript_name_2 = var_i;

    CHECK_OBJECT( tmp_subscript_name_2 );
    tmp_args_element_name_18 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_2, tmp_subscript_name_2 );
    if ( tmp_args_element_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_9 );

        exception_lineno = 752;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 752;
    {
        PyObject *call_args[] = { tmp_args_element_name_18 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_9, call_args );
    }

    Py_DECREF( tmp_called_name_9 );
    Py_DECREF( tmp_args_element_name_18 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 752;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_8;
    branch_no_8:;
    tmp_source_name_2 = var_xyZSolids;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_10 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_append );
    if ( tmp_called_name_10 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 754;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_3 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_3 );
    tmp_subscript_name_3 = var_i;

    CHECK_OBJECT( tmp_subscript_name_3 );
    tmp_args_element_name_19 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_3, tmp_subscript_name_3 );
    if ( tmp_args_element_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_10 );

        exception_lineno = 754;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 754;
    {
        PyObject *call_args[] = { tmp_args_element_name_19 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_10, call_args );
    }

    Py_DECREF( tmp_called_name_10 );
    Py_DECREF( tmp_args_element_name_19 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 754;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_end_8:;
    goto branch_end_7;
    branch_no_7:;
    tmp_compare_left_6 = var_z;

    CHECK_OBJECT( tmp_compare_left_6 );
    tmp_compare_right_6 = var_midZ;

    CHECK_OBJECT( tmp_compare_right_6 );
    tmp_cmp_Lt_4 = RICH_COMPARE_BOOL_LT( tmp_compare_left_6, tmp_compare_right_6 );
    if ( tmp_cmp_Lt_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 756;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_4 == 1 )
    {
        goto branch_yes_9;
    }
    else
    {
        goto branch_no_9;
    }
    branch_yes_9:;
    tmp_source_name_3 = var_xYzSolids;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_called_name_11 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_append );
    if ( tmp_called_name_11 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 757;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_4 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_4 );
    tmp_subscript_name_4 = var_i;

    CHECK_OBJECT( tmp_subscript_name_4 );
    tmp_args_element_name_20 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_4, tmp_subscript_name_4 );
    if ( tmp_args_element_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_11 );

        exception_lineno = 757;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 757;
    {
        PyObject *call_args[] = { tmp_args_element_name_20 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_11, call_args );
    }

    Py_DECREF( tmp_called_name_11 );
    Py_DECREF( tmp_args_element_name_20 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 757;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_9;
    branch_no_9:;
    tmp_source_name_4 = var_xYZSolids;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_12 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_append );
    if ( tmp_called_name_12 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 759;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_5 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_5 );
    tmp_subscript_name_5 = var_i;

    CHECK_OBJECT( tmp_subscript_name_5 );
    tmp_args_element_name_21 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_5, tmp_subscript_name_5 );
    if ( tmp_args_element_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_12 );

        exception_lineno = 759;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 759;
    {
        PyObject *call_args[] = { tmp_args_element_name_21 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_12, call_args );
    }

    Py_DECREF( tmp_called_name_12 );
    Py_DECREF( tmp_args_element_name_21 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 759;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_end_9:;
    branch_end_7:;
    goto branch_end_6;
    branch_no_6:;
    tmp_compare_left_7 = var_y;

    CHECK_OBJECT( tmp_compare_left_7 );
    tmp_compare_right_7 = var_midY;

    CHECK_OBJECT( tmp_compare_right_7 );
    tmp_cmp_Lt_5 = RICH_COMPARE_BOOL_LT( tmp_compare_left_7, tmp_compare_right_7 );
    if ( tmp_cmp_Lt_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 761;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_5 == 1 )
    {
        goto branch_yes_10;
    }
    else
    {
        goto branch_no_10;
    }
    branch_yes_10:;
    tmp_compare_left_8 = var_z;

    CHECK_OBJECT( tmp_compare_left_8 );
    tmp_compare_right_8 = var_midZ;

    CHECK_OBJECT( tmp_compare_right_8 );
    tmp_cmp_Lt_6 = RICH_COMPARE_BOOL_LT( tmp_compare_left_8, tmp_compare_right_8 );
    if ( tmp_cmp_Lt_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 762;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_6 == 1 )
    {
        goto branch_yes_11;
    }
    else
    {
        goto branch_no_11;
    }
    branch_yes_11:;
    tmp_source_name_5 = var_XyzSolids;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_13 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_append );
    if ( tmp_called_name_13 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_6 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_6 );
    tmp_subscript_name_6 = var_i;

    CHECK_OBJECT( tmp_subscript_name_6 );
    tmp_args_element_name_22 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_6, tmp_subscript_name_6 );
    if ( tmp_args_element_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_13 );

        exception_lineno = 763;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 763;
    {
        PyObject *call_args[] = { tmp_args_element_name_22 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_13, call_args );
    }

    Py_DECREF( tmp_called_name_13 );
    Py_DECREF( tmp_args_element_name_22 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 763;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_11;
    branch_no_11:;
    tmp_source_name_6 = var_XyZSolids;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_called_name_14 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_append );
    if ( tmp_called_name_14 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_7 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_7 );
    tmp_subscript_name_7 = var_i;

    CHECK_OBJECT( tmp_subscript_name_7 );
    tmp_args_element_name_23 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_7, tmp_subscript_name_7 );
    if ( tmp_args_element_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_14 );

        exception_lineno = 765;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 765;
    {
        PyObject *call_args[] = { tmp_args_element_name_23 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_14, call_args );
    }

    Py_DECREF( tmp_called_name_14 );
    Py_DECREF( tmp_args_element_name_23 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 765;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_end_11:;
    goto branch_end_10;
    branch_no_10:;
    tmp_compare_left_9 = var_z;

    CHECK_OBJECT( tmp_compare_left_9 );
    tmp_compare_right_9 = var_midZ;

    CHECK_OBJECT( tmp_compare_right_9 );
    tmp_cmp_Lt_7 = RICH_COMPARE_BOOL_LT( tmp_compare_left_9, tmp_compare_right_9 );
    if ( tmp_cmp_Lt_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 767;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    if ( tmp_cmp_Lt_7 == 1 )
    {
        goto branch_yes_12;
    }
    else
    {
        goto branch_no_12;
    }
    branch_yes_12:;
    tmp_source_name_7 = var_XYzSolids;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_15 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_append );
    if ( tmp_called_name_15 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 768;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_8 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_8 );
    tmp_subscript_name_8 = var_i;

    CHECK_OBJECT( tmp_subscript_name_8 );
    tmp_args_element_name_24 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_8, tmp_subscript_name_8 );
    if ( tmp_args_element_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_15 );

        exception_lineno = 768;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 768;
    {
        PyObject *call_args[] = { tmp_args_element_name_24 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_15, call_args );
    }

    Py_DECREF( tmp_called_name_15 );
    Py_DECREF( tmp_args_element_name_24 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 768;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_12;
    branch_no_12:;
    tmp_source_name_8 = var_XYZSolids;

    CHECK_OBJECT( tmp_source_name_8 );
    tmp_called_name_16 = LOOKUP_ATTRIBUTE( tmp_source_name_8, const_str_plain_append );
    if ( tmp_called_name_16 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 770;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    tmp_subscribed_name_9 = par_solids;

    CHECK_OBJECT( tmp_subscribed_name_9 );
    tmp_subscript_name_9 = var_i;

    CHECK_OBJECT( tmp_subscript_name_9 );
    tmp_args_element_name_25 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_9, tmp_subscript_name_9 );
    if ( tmp_args_element_name_25 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_16 );

        exception_lineno = 770;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    frame_function->m_frame.f_lineno = 770;
    {
        PyObject *call_args[] = { tmp_args_element_name_25 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_16, call_args );
    }

    Py_DECREF( tmp_called_name_16 );
    Py_DECREF( tmp_args_element_name_25 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 770;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    branch_end_12:;
    branch_end_10:;
    branch_end_6:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 746;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_assign_source_61 = PyList_New( 0 );
    assert( var_newSolids == NULL );
    var_newSolids = tmp_assign_source_61;

    tmp_len_arg_6 = var_xyzSolids;

    CHECK_OBJECT( tmp_len_arg_6 );
    tmp_cond_value_4 = BUILTIN_LEN( tmp_len_arg_6 );
    assert( tmp_cond_value_4 != NULL );
    tmp_cond_truth_4 = CHECK_IF_TRUE( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_4 );

        exception_lineno = 772;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_4 );
    if ( tmp_cond_truth_4 == 1 )
    {
        goto branch_yes_13;
    }
    else
    {
        goto branch_no_13;
    }
    branch_yes_13:;
    tmp_source_name_9 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_9 );
    tmp_called_name_17 = LOOKUP_ATTRIBUTE( tmp_source_name_9, const_str_plain_append );
    if ( tmp_called_name_17 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 773;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_9 = par_self;

    CHECK_OBJECT( tmp_called_instance_9 );
    tmp_args_element_name_27 = var_xyzSolids;

    CHECK_OBJECT( tmp_args_element_name_27 );
    tmp_args_element_name_28 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_28 );
    frame_function->m_frame.f_lineno = 773;
    {
        PyObject *call_args[] = { tmp_args_element_name_27, tmp_args_element_name_28 };
        tmp_args_element_name_26 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_9, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_26 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_17 );

        exception_lineno = 773;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 773;
    {
        PyObject *call_args[] = { tmp_args_element_name_26 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_17, call_args );
    }

    Py_DECREF( tmp_called_name_17 );
    Py_DECREF( tmp_args_element_name_26 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 773;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_13:;
    tmp_len_arg_7 = var_XyzSolids;

    CHECK_OBJECT( tmp_len_arg_7 );
    tmp_cond_value_5 = BUILTIN_LEN( tmp_len_arg_7 );
    assert( tmp_cond_value_5 != NULL );
    tmp_cond_truth_5 = CHECK_IF_TRUE( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_5 );

        exception_lineno = 774;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_5 );
    if ( tmp_cond_truth_5 == 1 )
    {
        goto branch_yes_14;
    }
    else
    {
        goto branch_no_14;
    }
    branch_yes_14:;
    tmp_source_name_10 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_10 );
    tmp_called_name_18 = LOOKUP_ATTRIBUTE( tmp_source_name_10, const_str_plain_append );
    if ( tmp_called_name_18 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 775;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_10 = par_self;

    CHECK_OBJECT( tmp_called_instance_10 );
    tmp_args_element_name_30 = var_XyzSolids;

    CHECK_OBJECT( tmp_args_element_name_30 );
    tmp_args_element_name_31 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_31 );
    frame_function->m_frame.f_lineno = 775;
    {
        PyObject *call_args[] = { tmp_args_element_name_30, tmp_args_element_name_31 };
        tmp_args_element_name_29 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_10, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_29 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_18 );

        exception_lineno = 775;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 775;
    {
        PyObject *call_args[] = { tmp_args_element_name_29 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_18, call_args );
    }

    Py_DECREF( tmp_called_name_18 );
    Py_DECREF( tmp_args_element_name_29 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 775;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_14:;
    tmp_len_arg_8 = var_xYzSolids;

    CHECK_OBJECT( tmp_len_arg_8 );
    tmp_cond_value_6 = BUILTIN_LEN( tmp_len_arg_8 );
    assert( tmp_cond_value_6 != NULL );
    tmp_cond_truth_6 = CHECK_IF_TRUE( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_6 );

        exception_lineno = 776;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_6 );
    if ( tmp_cond_truth_6 == 1 )
    {
        goto branch_yes_15;
    }
    else
    {
        goto branch_no_15;
    }
    branch_yes_15:;
    tmp_source_name_11 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_11 );
    tmp_called_name_19 = LOOKUP_ATTRIBUTE( tmp_source_name_11, const_str_plain_append );
    if ( tmp_called_name_19 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 777;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_11 = par_self;

    CHECK_OBJECT( tmp_called_instance_11 );
    tmp_args_element_name_33 = var_xYzSolids;

    CHECK_OBJECT( tmp_args_element_name_33 );
    tmp_args_element_name_34 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_34 );
    frame_function->m_frame.f_lineno = 777;
    {
        PyObject *call_args[] = { tmp_args_element_name_33, tmp_args_element_name_34 };
        tmp_args_element_name_32 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_11, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_32 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_19 );

        exception_lineno = 777;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 777;
    {
        PyObject *call_args[] = { tmp_args_element_name_32 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_19, call_args );
    }

    Py_DECREF( tmp_called_name_19 );
    Py_DECREF( tmp_args_element_name_32 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 777;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_15:;
    tmp_len_arg_9 = var_XYzSolids;

    CHECK_OBJECT( tmp_len_arg_9 );
    tmp_cond_value_7 = BUILTIN_LEN( tmp_len_arg_9 );
    assert( tmp_cond_value_7 != NULL );
    tmp_cond_truth_7 = CHECK_IF_TRUE( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_7 );

        exception_lineno = 778;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_7 );
    if ( tmp_cond_truth_7 == 1 )
    {
        goto branch_yes_16;
    }
    else
    {
        goto branch_no_16;
    }
    branch_yes_16:;
    tmp_source_name_12 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_12 );
    tmp_called_name_20 = LOOKUP_ATTRIBUTE( tmp_source_name_12, const_str_plain_append );
    if ( tmp_called_name_20 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_12 = par_self;

    CHECK_OBJECT( tmp_called_instance_12 );
    tmp_args_element_name_36 = var_XYzSolids;

    CHECK_OBJECT( tmp_args_element_name_36 );
    tmp_args_element_name_37 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_37 );
    frame_function->m_frame.f_lineno = 779;
    {
        PyObject *call_args[] = { tmp_args_element_name_36, tmp_args_element_name_37 };
        tmp_args_element_name_35 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_12, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_35 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_20 );

        exception_lineno = 779;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 779;
    {
        PyObject *call_args[] = { tmp_args_element_name_35 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_20, call_args );
    }

    Py_DECREF( tmp_called_name_20 );
    Py_DECREF( tmp_args_element_name_35 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 779;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_16:;
    tmp_len_arg_10 = var_xyZSolids;

    CHECK_OBJECT( tmp_len_arg_10 );
    tmp_cond_value_8 = BUILTIN_LEN( tmp_len_arg_10 );
    assert( tmp_cond_value_8 != NULL );
    tmp_cond_truth_8 = CHECK_IF_TRUE( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_8 );

        exception_lineno = 780;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_8 );
    if ( tmp_cond_truth_8 == 1 )
    {
        goto branch_yes_17;
    }
    else
    {
        goto branch_no_17;
    }
    branch_yes_17:;
    tmp_source_name_13 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_13 );
    tmp_called_name_21 = LOOKUP_ATTRIBUTE( tmp_source_name_13, const_str_plain_append );
    if ( tmp_called_name_21 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 781;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_13 = par_self;

    CHECK_OBJECT( tmp_called_instance_13 );
    tmp_args_element_name_39 = var_xyZSolids;

    CHECK_OBJECT( tmp_args_element_name_39 );
    tmp_args_element_name_40 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_40 );
    frame_function->m_frame.f_lineno = 781;
    {
        PyObject *call_args[] = { tmp_args_element_name_39, tmp_args_element_name_40 };
        tmp_args_element_name_38 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_13, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_38 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_21 );

        exception_lineno = 781;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 781;
    {
        PyObject *call_args[] = { tmp_args_element_name_38 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_21, call_args );
    }

    Py_DECREF( tmp_called_name_21 );
    Py_DECREF( tmp_args_element_name_38 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 781;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_17:;
    tmp_len_arg_11 = var_XyZSolids;

    CHECK_OBJECT( tmp_len_arg_11 );
    tmp_cond_value_9 = BUILTIN_LEN( tmp_len_arg_11 );
    assert( tmp_cond_value_9 != NULL );
    tmp_cond_truth_9 = CHECK_IF_TRUE( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_9 );

        exception_lineno = 782;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_9 );
    if ( tmp_cond_truth_9 == 1 )
    {
        goto branch_yes_18;
    }
    else
    {
        goto branch_no_18;
    }
    branch_yes_18:;
    tmp_source_name_14 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_14 );
    tmp_called_name_22 = LOOKUP_ATTRIBUTE( tmp_source_name_14, const_str_plain_append );
    if ( tmp_called_name_22 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_14 = par_self;

    CHECK_OBJECT( tmp_called_instance_14 );
    tmp_args_element_name_42 = var_XyZSolids;

    CHECK_OBJECT( tmp_args_element_name_42 );
    tmp_args_element_name_43 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_43 );
    frame_function->m_frame.f_lineno = 783;
    {
        PyObject *call_args[] = { tmp_args_element_name_42, tmp_args_element_name_43 };
        tmp_args_element_name_41 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_14, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_41 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_22 );

        exception_lineno = 783;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 783;
    {
        PyObject *call_args[] = { tmp_args_element_name_41 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_22, call_args );
    }

    Py_DECREF( tmp_called_name_22 );
    Py_DECREF( tmp_args_element_name_41 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 783;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_18:;
    tmp_len_arg_12 = var_xYZSolids;

    CHECK_OBJECT( tmp_len_arg_12 );
    tmp_cond_value_10 = BUILTIN_LEN( tmp_len_arg_12 );
    assert( tmp_cond_value_10 != NULL );
    tmp_cond_truth_10 = CHECK_IF_TRUE( tmp_cond_value_10 );
    if ( tmp_cond_truth_10 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_10 );

        exception_lineno = 784;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_10 );
    if ( tmp_cond_truth_10 == 1 )
    {
        goto branch_yes_19;
    }
    else
    {
        goto branch_no_19;
    }
    branch_yes_19:;
    tmp_source_name_15 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_15 );
    tmp_called_name_23 = LOOKUP_ATTRIBUTE( tmp_source_name_15, const_str_plain_append );
    if ( tmp_called_name_23 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_15 = par_self;

    CHECK_OBJECT( tmp_called_instance_15 );
    tmp_args_element_name_45 = var_xYZSolids;

    CHECK_OBJECT( tmp_args_element_name_45 );
    tmp_args_element_name_46 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_46 );
    frame_function->m_frame.f_lineno = 785;
    {
        PyObject *call_args[] = { tmp_args_element_name_45, tmp_args_element_name_46 };
        tmp_args_element_name_44 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_15, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_44 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_23 );

        exception_lineno = 785;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 785;
    {
        PyObject *call_args[] = { tmp_args_element_name_44 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_23, call_args );
    }

    Py_DECREF( tmp_called_name_23 );
    Py_DECREF( tmp_args_element_name_44 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 785;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_19:;
    tmp_len_arg_13 = var_XYZSolids;

    CHECK_OBJECT( tmp_len_arg_13 );
    tmp_cond_value_11 = BUILTIN_LEN( tmp_len_arg_13 );
    assert( tmp_cond_value_11 != NULL );
    tmp_cond_truth_11 = CHECK_IF_TRUE( tmp_cond_value_11 );
    if ( tmp_cond_truth_11 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_cond_value_11 );

        exception_lineno = 786;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_cond_value_11 );
    if ( tmp_cond_truth_11 == 1 )
    {
        goto branch_yes_20;
    }
    else
    {
        goto branch_no_20;
    }
    branch_yes_20:;
    tmp_source_name_16 = var_newSolids;

    CHECK_OBJECT( tmp_source_name_16 );
    tmp_called_name_24 = LOOKUP_ATTRIBUTE( tmp_source_name_16, const_str_plain_append );
    if ( tmp_called_name_24 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 787;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_16 = par_self;

    CHECK_OBJECT( tmp_called_instance_16 );
    tmp_args_element_name_48 = var_XYZSolids;

    CHECK_OBJECT( tmp_args_element_name_48 );
    tmp_args_element_name_49 = par_numSolidsInLeaves;

    CHECK_OBJECT( tmp_args_element_name_49 );
    frame_function->m_frame.f_lineno = 787;
    {
        PyObject *call_args[] = { tmp_args_element_name_48, tmp_args_element_name_49 };
        tmp_args_element_name_47 = CALL_METHOD_WITH_ARGS2( tmp_called_instance_16, const_str_plain_r_subdivideCollisions, call_args );
    }

    if ( tmp_args_element_name_47 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_24 );

        exception_lineno = 787;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 787;
    {
        PyObject *call_args[] = { tmp_args_element_name_47 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_24, call_args );
    }

    Py_DECREF( tmp_called_name_24 );
    Py_DECREF( tmp_args_element_name_47 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 787;
        type_description = "ooooooooooooooooooooooooooooooooooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    branch_no_20:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_solids, par_numSolidsInLeaves, var_origins, var_avgX, var_avgY, var_avgZ, var_minX, var_minY, var_minZ, var_maxX, var_maxY, var_maxZ, var_solid, var_origin, var_x, var_y, var_z, var_extentX, var_extentY, var_extentZ, var_maxExtent, var_xyzSolids, var_XyzSolids, var_xYzSolids, var_XYzSolids, var_xyZSolids, var_XyZSolids, var_xYZSolids, var_XYZSolids, var_midX, var_midY, var_midZ, var_i, var_newSolids );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = var_newSolids;

    CHECK_OBJECT( tmp_return_value );
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_solids );
    Py_DECREF( par_solids );
    par_solids = NULL;

    CHECK_OBJECT( (PyObject *)par_numSolidsInLeaves );
    Py_DECREF( par_numSolidsInLeaves );
    par_numSolidsInLeaves = NULL;

    Py_XDECREF( var_origins );
    var_origins = NULL;

    Py_XDECREF( var_avgX );
    var_avgX = NULL;

    Py_XDECREF( var_avgY );
    var_avgY = NULL;

    Py_XDECREF( var_avgZ );
    var_avgZ = NULL;

    Py_XDECREF( var_minX );
    var_minX = NULL;

    Py_XDECREF( var_minY );
    var_minY = NULL;

    Py_XDECREF( var_minZ );
    var_minZ = NULL;

    Py_XDECREF( var_maxX );
    var_maxX = NULL;

    Py_XDECREF( var_maxY );
    var_maxY = NULL;

    Py_XDECREF( var_maxZ );
    var_maxZ = NULL;

    Py_XDECREF( var_solid );
    var_solid = NULL;

    Py_XDECREF( var_origin );
    var_origin = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    Py_XDECREF( var_y );
    var_y = NULL;

    Py_XDECREF( var_z );
    var_z = NULL;

    Py_XDECREF( var_extentX );
    var_extentX = NULL;

    Py_XDECREF( var_extentY );
    var_extentY = NULL;

    Py_XDECREF( var_extentZ );
    var_extentZ = NULL;

    Py_XDECREF( var_maxExtent );
    var_maxExtent = NULL;

    Py_XDECREF( var_xyzSolids );
    var_xyzSolids = NULL;

    Py_XDECREF( var_XyzSolids );
    var_XyzSolids = NULL;

    Py_XDECREF( var_xYzSolids );
    var_xYzSolids = NULL;

    Py_XDECREF( var_XYzSolids );
    var_XYzSolids = NULL;

    Py_XDECREF( var_xyZSolids );
    var_xyZSolids = NULL;

    Py_XDECREF( var_XyZSolids );
    var_XyZSolids = NULL;

    Py_XDECREF( var_xYZSolids );
    var_xYZSolids = NULL;

    Py_XDECREF( var_XYZSolids );
    var_XYZSolids = NULL;

    Py_XDECREF( var_midX );
    var_midX = NULL;

    Py_XDECREF( var_midY );
    var_midY = NULL;

    Py_XDECREF( var_midZ );
    var_midZ = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_newSolids );
    var_newSolids = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_solids );
    Py_DECREF( par_solids );
    par_solids = NULL;

    CHECK_OBJECT( (PyObject *)par_numSolidsInLeaves );
    Py_DECREF( par_numSolidsInLeaves );
    par_numSolidsInLeaves = NULL;

    Py_XDECREF( var_origins );
    var_origins = NULL;

    Py_XDECREF( var_avgX );
    var_avgX = NULL;

    Py_XDECREF( var_avgY );
    var_avgY = NULL;

    Py_XDECREF( var_avgZ );
    var_avgZ = NULL;

    Py_XDECREF( var_minX );
    var_minX = NULL;

    Py_XDECREF( var_minY );
    var_minY = NULL;

    Py_XDECREF( var_minZ );
    var_minZ = NULL;

    Py_XDECREF( var_maxX );
    var_maxX = NULL;

    Py_XDECREF( var_maxY );
    var_maxY = NULL;

    Py_XDECREF( var_maxZ );
    var_maxZ = NULL;

    Py_XDECREF( var_solid );
    var_solid = NULL;

    Py_XDECREF( var_origin );
    var_origin = NULL;

    Py_XDECREF( var_x );
    var_x = NULL;

    Py_XDECREF( var_y );
    var_y = NULL;

    Py_XDECREF( var_z );
    var_z = NULL;

    Py_XDECREF( var_extentX );
    var_extentX = NULL;

    Py_XDECREF( var_extentY );
    var_extentY = NULL;

    Py_XDECREF( var_extentZ );
    var_extentZ = NULL;

    Py_XDECREF( var_maxExtent );
    var_maxExtent = NULL;

    Py_XDECREF( var_xyzSolids );
    var_xyzSolids = NULL;

    Py_XDECREF( var_XyzSolids );
    var_XyzSolids = NULL;

    Py_XDECREF( var_xYzSolids );
    var_xYzSolids = NULL;

    Py_XDECREF( var_XYzSolids );
    var_XYzSolids = NULL;

    Py_XDECREF( var_xyZSolids );
    var_xyZSolids = NULL;

    Py_XDECREF( var_XyZSolids );
    var_XyZSolids = NULL;

    Py_XDECREF( var_xYZSolids );
    var_xYZSolids = NULL;

    Py_XDECREF( var_XYZSolids );
    var_XYZSolids = NULL;

    Py_XDECREF( var_midX );
    var_midX = NULL;

    Py_XDECREF( var_midY );
    var_midY = NULL;

    Py_XDECREF( var_midZ );
    var_midZ = NULL;

    Py_XDECREF( var_i );
    var_i = NULL;

    Py_XDECREF( var_newSolids );
    var_newSolids = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *par_solidTree = python_pars[ 1 ];
    PyObject *par_parentNode = python_pars[ 2 ];
    PyObject *par_colName = python_pars[ 3 ];
    PyObject *var_item = NULL;
    PyObject *var_newNode = NULL;
    PyObject *var_cn = NULL;
    PyObject *var_solid = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_iter_arg_1;
    PyObject *tmp_iter_arg_2;
    PyObject *tmp_left_name_1;
    PyObject *tmp_left_name_2;
    PyObject *tmp_next_source_1;
    PyObject *tmp_next_source_2;
    PyObject *tmp_return_value;
    PyObject *tmp_right_name_1;
    PyObject *tmp_right_name_2;
    PyObject *tmp_source_name_1;
    PyObject *tmp_subscribed_name_1;
    PyObject *tmp_subscript_name_1;
    PyObject *tmp_type_arg_1;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_d9bf6af6c22e015411ad6e2cc98db101, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_iter_arg_1 = par_solidTree;

    CHECK_OBJECT( tmp_iter_arg_1 );
    tmp_assign_source_1 = MAKE_ITERATOR( tmp_iter_arg_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description = "oooooooo";
        goto frame_exception_exit_1;
    }
    assert( tmp_for_loop_1__for_iterator == NULL );
    tmp_for_loop_1__for_iterator = tmp_assign_source_1;

    // Tried code:
    loop_start_1:;
    tmp_next_source_1 = tmp_for_loop_1__for_iterator;

    CHECK_OBJECT( tmp_next_source_1 );
    tmp_assign_source_2 = ITERATOR_NEXT( tmp_next_source_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_1;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooo";
            frame_function->m_frame.f_lineno = 792;
            goto try_except_handler_2;
        }
    }

    {
        PyObject *old = tmp_for_loop_1__iter_value;
        tmp_for_loop_1__iter_value = tmp_assign_source_2;
        Py_XDECREF( old );
    }

    tmp_assign_source_3 = tmp_for_loop_1__iter_value;

    CHECK_OBJECT( tmp_assign_source_3 );
    {
        PyObject *old = var_item;
        var_item = tmp_assign_source_3;
        Py_INCREF( var_item );
        Py_XDECREF( old );
    }

    tmp_subscribed_name_1 = var_item;

    CHECK_OBJECT( tmp_subscribed_name_1 );
    tmp_subscript_name_1 = const_int_0;
    tmp_type_arg_1 = LOOKUP_SUBSCRIPT( tmp_subscribed_name_1, tmp_subscript_name_1 );
    if ( tmp_type_arg_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 793;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_compare_left_1 = BUILTIN_TYPE1( tmp_type_arg_1 );
    Py_DECREF( tmp_type_arg_1 );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 793;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_compare_right_1 = LOOKUP_BUILTIN( const_str_plain_list );
    assert( tmp_compare_right_1 != NULL );
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 793;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_source_name_1 = par_parentNode;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_1 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_attachNewNode );
    if ( tmp_called_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    tmp_left_name_1 = const_str_digest_be8949587e5eb5966c8063479c553455;
    tmp_right_name_1 = par_colName;

    CHECK_OBJECT( tmp_right_name_1 );
    tmp_args_element_name_1 = BINARY_OPERATION_REMAINDER( tmp_left_name_1, tmp_right_name_1 );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_1 );

        exception_lineno = 794;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 794;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_assign_source_4 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_1, call_args );
    }

    Py_DECREF( tmp_called_name_1 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 794;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_newNode;
        var_newNode = tmp_assign_source_4;
        Py_XDECREF( old );
    }

    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    tmp_args_element_name_2 = var_item;

    CHECK_OBJECT( tmp_args_element_name_2 );
    tmp_args_element_name_3 = var_newNode;

    CHECK_OBJECT( tmp_args_element_name_3 );
    tmp_args_element_name_4 = par_colName;

    CHECK_OBJECT( tmp_args_element_name_4 );
    frame_function->m_frame.f_lineno = 795;
    {
        PyObject *call_args[] = { tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_METHOD_WITH_ARGS3( tmp_called_instance_1, const_str_plain_r_constructCollisionTree, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 795;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    goto branch_end_1;
    branch_no_1:;
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_CollisionNode );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_CollisionNode );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "global name '%s' is not defined", "CollisionNode" );
        exception_tb = NULL;

        exception_lineno = 797;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }

    tmp_left_name_2 = const_str_digest_7562d3a4d5354201304f36f42e3a0f01;
    tmp_right_name_2 = par_colName;

    CHECK_OBJECT( tmp_right_name_2 );
    tmp_args_element_name_5 = BINARY_OPERATION_REMAINDER( tmp_left_name_2, tmp_right_name_2 );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 797;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    frame_function->m_frame.f_lineno = 797;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_assign_source_5 = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_assign_source_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 797;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = var_cn;
        var_cn = tmp_assign_source_5;
        Py_XDECREF( old );
    }

    tmp_iter_arg_2 = var_item;

    CHECK_OBJECT( tmp_iter_arg_2 );
    tmp_assign_source_6 = MAKE_ITERATOR( tmp_iter_arg_2 );
    if ( tmp_assign_source_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    {
        PyObject *old = tmp_for_loop_2__for_iterator;
        tmp_for_loop_2__for_iterator = tmp_assign_source_6;
        Py_XDECREF( old );
    }

    // Tried code:
    loop_start_2:;
    tmp_next_source_2 = tmp_for_loop_2__for_iterator;

    CHECK_OBJECT( tmp_next_source_2 );
    tmp_assign_source_7 = ITERATOR_NEXT( tmp_next_source_2 );
    if ( tmp_assign_source_7 == NULL )
    {
        if ( CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED() )
        {

            goto loop_end_2;
        }
        else
        {

            FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
            type_description = "oooooooo";
            frame_function->m_frame.f_lineno = 798;
            goto try_except_handler_3;
        }
    }

    {
        PyObject *old = tmp_for_loop_2__iter_value;
        tmp_for_loop_2__iter_value = tmp_assign_source_7;
        Py_XDECREF( old );
    }

    tmp_assign_source_8 = tmp_for_loop_2__iter_value;

    CHECK_OBJECT( tmp_assign_source_8 );
    {
        PyObject *old = var_solid;
        var_solid = tmp_assign_source_8;
        Py_INCREF( var_solid );
        Py_XDECREF( old );
    }

    tmp_called_instance_2 = var_cn;

    CHECK_OBJECT( tmp_called_instance_2 );
    tmp_args_element_name_6 = var_solid;

    CHECK_OBJECT( tmp_args_element_name_6 );
    frame_function->m_frame.f_lineno = 799;
    {
        PyObject *call_args[] = { tmp_args_element_name_6 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_2, const_str_plain_addSolid, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 799;
        type_description = "oooooooo";
        goto try_except_handler_3;
    }
    Py_DECREF( tmp_unused );
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 798;
        type_description = "oooooooo";
        goto try_except_handler_3;
    }
    goto loop_start_2;
    loop_end_2:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto try_except_handler_2;
    // End of try:
    try_end_1:;
    Py_XDECREF( tmp_for_loop_2__iter_value );
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_2__for_iterator );
    Py_DECREF( tmp_for_loop_2__for_iterator );
    tmp_for_loop_2__for_iterator = NULL;

    tmp_called_instance_3 = par_parentNode;

    CHECK_OBJECT( tmp_called_instance_3 );
    tmp_args_element_name_7 = var_cn;

    CHECK_OBJECT( tmp_args_element_name_7 );
    frame_function->m_frame.f_lineno = 800;
    {
        PyObject *call_args[] = { tmp_args_element_name_7 };
        tmp_unused = CALL_METHOD_WITH_ARGS1( tmp_called_instance_3, const_str_plain_attachNewNode, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 800;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    Py_DECREF( tmp_unused );
    branch_end_1:;
    if ( CONSIDER_THREADING() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 792;
        type_description = "oooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, par_solidTree, par_parentNode, par_colName, var_item, var_newNode, var_cn, var_solid );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    Py_XDECREF( tmp_for_loop_1__iter_value );
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT( (PyObject *)tmp_for_loop_1__for_iterator );
    Py_DECREF( tmp_for_loop_1__for_iterator );
    tmp_for_loop_1__for_iterator = NULL;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_solidTree );
    Py_DECREF( par_solidTree );
    par_solidTree = NULL;

    CHECK_OBJECT( (PyObject *)par_parentNode );
    Py_DECREF( par_parentNode );
    par_parentNode = NULL;

    CHECK_OBJECT( (PyObject *)par_colName );
    Py_DECREF( par_colName );
    par_colName = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    Py_XDECREF( var_newNode );
    var_newNode = NULL;

    Py_XDECREF( var_cn );
    var_cn = NULL;

    Py_XDECREF( var_solid );
    var_solid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)par_solidTree );
    Py_DECREF( par_solidTree );
    par_solidTree = NULL;

    CHECK_OBJECT( (PyObject *)par_parentNode );
    Py_DECREF( par_parentNode );
    par_parentNode = NULL;

    CHECK_OBJECT( (PyObject *)par_colName );
    Py_DECREF( par_colName );
    par_colName = NULL;

    Py_XDECREF( var_item );
    var_item = NULL;

    Py_XDECREF( var_newNode );
    var_newNode = NULL;

    Py_XDECREF( var_cn );
    var_cn = NULL;

    Py_XDECREF( var_solid );
    var_solid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}


static PyObject *impl_direct$extensions_native$NodePath_extensions$$$function_58_analyze( struct Nuitka_FunctionObject const *self, PyObject **python_pars )
{
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[ 0 ];
    PyObject *var_SceneGraphAnalyzer = NULL;
    PyObject *var_sga = NULL;
    PyObject *var_sga2 = NULL;
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_called_instance_1;
    PyObject *tmp_called_instance_2;
    PyObject *tmp_called_instance_3;
    PyObject *tmp_called_instance_4;
    PyObject *tmp_called_instance_5;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    int tmp_cmp_Eq_1;
    PyObject *tmp_compare_left_1;
    PyObject *tmp_compare_right_1;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_name_name_1;
    PyObject *tmp_print_value;
    PyObject *tmp_return_value;
    PyObject *tmp_source_name_1;
    PyObject *tmp_source_name_2;
    PyObject *tmp_source_name_3;
    PyObject *tmp_source_name_4;
    PyObject *tmp_source_name_5;
    PyObject *tmp_source_name_6;
    PyObject *tmp_source_name_7;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_function = NULL;

    struct Nuitka_FrameObject *frame_function;

    char const *type_description;
    tmp_return_value = NULL;

    // Actual function code.
    // Tried code:
    MAKE_OR_REUSE_FRAME( cache_frame_function, codeobj_f03b83bec65b720707e68bb9d9f7f928, module_direct$extensions_native$NodePath_extensions, sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *)+sizeof(PyObject *) );
    frame_function = cache_frame_function;

    // Push the new frame as the currently active one.
    pushFrameStack( frame_function );

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert( Py_REFCNT( frame_function ) == 2 ); // Frame stack

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_SceneGraphAnalyzer_tuple;
    frame_function->m_frame.f_lineno = 816;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_assign_source_1 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_SceneGraphAnalyzer );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 816;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_SceneGraphAnalyzer == NULL );
    var_SceneGraphAnalyzer = tmp_assign_source_1;

    tmp_called_name_1 = var_SceneGraphAnalyzer;

    CHECK_OBJECT( tmp_called_name_1 );
    frame_function->m_frame.f_lineno = 817;
    tmp_assign_source_2 = CALL_FUNCTION_NO_ARGS( tmp_called_name_1 );
    if ( tmp_assign_source_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 817;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_sga == NULL );
    var_sga = tmp_assign_source_2;

    tmp_source_name_1 = var_sga;

    CHECK_OBJECT( tmp_source_name_1 );
    tmp_called_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_1, const_str_plain_addNode );
    if ( tmp_called_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 818;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_1 = par_self;

    CHECK_OBJECT( tmp_called_instance_1 );
    frame_function->m_frame.f_lineno = 818;
    tmp_args_element_name_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_1, const_str_plain_node );
    if ( tmp_args_element_name_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_2 );

        exception_lineno = 818;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 818;
    {
        PyObject *call_args[] = { tmp_args_element_name_1 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_2, call_args );
    }

    Py_DECREF( tmp_called_name_2 );
    Py_DECREF( tmp_args_element_name_1 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 818;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_instance_2 = var_sga;

    CHECK_OBJECT( tmp_called_instance_2 );
    frame_function->m_frame.f_lineno = 819;
    tmp_compare_left_1 = CALL_METHOD_NO_ARGS( tmp_called_instance_2, const_str_plain_getNumLodNodes );
    if ( tmp_compare_left_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 819;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_compare_right_1 = const_int_0;
    tmp_cmp_Eq_1 = RICH_COMPARE_BOOL_EQ( tmp_compare_left_1, tmp_compare_right_1 );
    if ( tmp_cmp_Eq_1 == -1 )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_compare_left_1 );

        exception_lineno = 819;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_compare_left_1 );
    if ( tmp_cmp_Eq_1 == 1 )
    {
        goto branch_yes_1;
    }
    else
    {
        goto branch_no_1;
    }
    branch_yes_1:;
    tmp_print_value = var_sga;

    CHECK_OBJECT( tmp_print_value );
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 820;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 820;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_print_value = const_str_digest_fda6811bf39fdc1057e50f4fadb295e9;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 822;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 822;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_name_3 = var_SceneGraphAnalyzer;

    CHECK_OBJECT( tmp_called_name_3 );
    frame_function->m_frame.f_lineno = 823;
    tmp_assign_source_3 = CALL_FUNCTION_NO_ARGS( tmp_called_name_3 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 823;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    assert( var_sga2 == NULL );
    var_sga2 = tmp_assign_source_3;

    tmp_source_name_2 = var_sga2;

    CHECK_OBJECT( tmp_source_name_2 );
    tmp_called_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_2, const_str_plain_setLodMode );
    if ( tmp_called_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_3 = var_sga2;

    CHECK_OBJECT( tmp_source_name_3 );
    tmp_args_element_name_2 = LOOKUP_ATTRIBUTE( tmp_source_name_3, const_str_plain_LMHighest );
    if ( tmp_args_element_name_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_4 );

        exception_lineno = 824;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 824;
    {
        PyObject *call_args[] = { tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_4, call_args );
    }

    Py_DECREF( tmp_called_name_4 );
    Py_DECREF( tmp_args_element_name_2 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 824;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_4 = var_sga2;

    CHECK_OBJECT( tmp_source_name_4 );
    tmp_called_name_5 = LOOKUP_ATTRIBUTE( tmp_source_name_4, const_str_plain_addNode );
    if ( tmp_called_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_3 = par_self;

    CHECK_OBJECT( tmp_called_instance_3 );
    frame_function->m_frame.f_lineno = 825;
    tmp_args_element_name_3 = CALL_METHOD_NO_ARGS( tmp_called_instance_3, const_str_plain_node );
    if ( tmp_args_element_name_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_5 );

        exception_lineno = 825;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 825;
    {
        PyObject *call_args[] = { tmp_args_element_name_3 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_5, call_args );
    }

    Py_DECREF( tmp_called_name_5 );
    Py_DECREF( tmp_args_element_name_3 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 825;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_print_value = var_sga2;

    CHECK_OBJECT( tmp_print_value );
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 826;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_e4b151998270e43899ddbb5f99045dbe;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 828;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_4 = var_sga2;

    CHECK_OBJECT( tmp_called_instance_4 );
    frame_function->m_frame.f_lineno = 829;
    tmp_unused = CALL_METHOD_NO_ARGS( tmp_called_instance_4, const_str_plain_clear );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 829;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_5 = var_sga2;

    CHECK_OBJECT( tmp_source_name_5 );
    tmp_called_name_6 = LOOKUP_ATTRIBUTE( tmp_source_name_5, const_str_plain_setLodMode );
    if ( tmp_called_name_6 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_source_name_6 = var_sga2;

    CHECK_OBJECT( tmp_source_name_6 );
    tmp_args_element_name_4 = LOOKUP_ATTRIBUTE( tmp_source_name_6, const_str_plain_LMLowest );
    if ( tmp_args_element_name_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_6 );

        exception_lineno = 830;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 830;
    {
        PyObject *call_args[] = { tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_6, call_args );
    }

    Py_DECREF( tmp_called_name_6 );
    Py_DECREF( tmp_args_element_name_4 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 830;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_source_name_7 = var_sga2;

    CHECK_OBJECT( tmp_source_name_7 );
    tmp_called_name_7 = LOOKUP_ATTRIBUTE( tmp_source_name_7, const_str_plain_addNode );
    if ( tmp_called_name_7 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_called_instance_5 = par_self;

    CHECK_OBJECT( tmp_called_instance_5 );
    frame_function->m_frame.f_lineno = 831;
    tmp_args_element_name_5 = CALL_METHOD_NO_ARGS( tmp_called_instance_5, const_str_plain_node );
    if ( tmp_args_element_name_5 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );
        Py_DECREF( tmp_called_name_7 );

        exception_lineno = 831;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    frame_function->m_frame.f_lineno = 831;
    {
        PyObject *call_args[] = { tmp_args_element_name_5 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS1( tmp_called_name_7, call_args );
    }

    Py_DECREF( tmp_called_name_7 );
    Py_DECREF( tmp_args_element_name_5 );
    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 831;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_print_value = var_sga2;

    CHECK_OBJECT( tmp_print_value );
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 832;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = const_str_digest_9bd659cd284b4488953883e670875e15;
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 834;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    tmp_print_value = var_sga;

    CHECK_OBJECT( tmp_print_value );
    if ( PRINT_ITEM( tmp_print_value ) == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 835;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    if ( PRINT_NEW_LINE() == false )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 835;
        type_description = "oooo";
        goto frame_exception_exit_1;
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION( frame_function );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_function, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_function->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_function, exception_lineno );
    }

    Nuitka_Frame_AttachLocals( (struct Nuitka_FrameObject *)frame_function, type_description ,par_self, var_SceneGraphAnalyzer, var_sga, var_sga2 );

    // Release cached frame.
    if ( frame_function == cache_frame_function )
    {
        Py_DECREF( frame_function );
    }
    cache_frame_function = NULL;

    assertFrameObject( frame_function );


    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;

    tmp_return_value = Py_None;
    Py_INCREF( tmp_return_value );
    goto try_return_handler_1;
    // tried codes exits in all cases
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_58_analyze );
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    CHECK_OBJECT( (PyObject *)var_SceneGraphAnalyzer );
    Py_DECREF( var_SceneGraphAnalyzer );
    var_SceneGraphAnalyzer = NULL;

    CHECK_OBJECT( (PyObject *)var_sga );
    Py_DECREF( var_sga );
    var_sga = NULL;

    Py_XDECREF( var_sga2 );
    var_sga2 = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = -1;

    CHECK_OBJECT( (PyObject *)par_self );
    Py_DECREF( par_self );
    par_self = NULL;

    Py_XDECREF( var_SceneGraphAnalyzer );
    var_SceneGraphAnalyzer = NULL;

    Py_XDECREF( var_sga );
    var_sga = NULL;

    Py_XDECREF( var_sga2 );
    var_sga2 = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    // Return statement must have exited already.
    NUITKA_CANNOT_GET_HERE( direct$extensions_native$NodePath_extensions$$$function_58_analyze );
    return NULL;

function_exception_exit:
    assert( exception_type );
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );

    return NULL;
    function_return_exit:

    CHECK_OBJECT( tmp_return_value );
    assert( had_error || !ERROR_OCCURRED() );
    return tmp_return_value;

}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_10_remove(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_10_remove,
        const_str_plain_remove,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_06a9537ad26ca8b502d78bcb41a911c9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_b2b98b498f6c9bc6671ffae896e8f53b,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_11_lsNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_11_lsNames,
        const_str_plain_lsNames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_06a81b72c525dae2f442cc0d66794129,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_7008f8eb1ab08ab901bff06d4f36aa5c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse,
        const_str_plain_lsNamesRecurse,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_90b5ab8872ab2916e5c87911d8e91f5e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_3bff77c337e9ced759045bfa6af9fd7a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames,
        const_str_plain_reverseLsNames,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b8dc973a59a525b1d5937ff2ee8b8804,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_ca942f1abb1ab9e034d34109a7865404,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_14_getAncestry(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_14_getAncestry,
        const_str_plain_getAncestry,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_37d493be231c5010b970ce6276e19603,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_1534cb090b59d6ea78e080c0a531f66c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_15_pPrintString( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_15_pPrintString,
        const_str_plain_pPrintString,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_fde9287990a9dab12fd41e019193bedc,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_12c5328130517918ca9d49f0622ada30,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_16_printPos( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_16_printPos,
        const_str_plain_printPos,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ae46e0796f95e234fd8d8691701c5c85,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_accc6d7f594b841fd4ec537441b97824,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_17_printHpr( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_17_printHpr,
        const_str_plain_printHpr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_9555320a3f201bb9e8eb1d3aedb3d9e3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_2aaa28b3d493cec16afb02e4ee05025c,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_18_printScale( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_18_printScale,
        const_str_plain_printScale,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1085e04a622479f3d892fba051817853,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_9b1387bcbe22a7a3a9dfe8973569fbd2,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr,
        const_str_plain_printPosHpr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_bdabf02f866f906167831c0ba99843d4,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_e1d499a078ec1d220d93fb06f682d214,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_1_id(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_1_id,
        const_str_plain_id,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a4a38329bd458a66a6517c3d4782c57a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_76da864eb1584fe789e5ec7b9c456e6a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale,
        const_str_plain_printPosHprScale,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_72050c740292be6322a3a502126e5e39,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_20a2483b2157cbd98f585f6b4e968f97,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_21_printTransform( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_21_printTransform,
        const_str_plain_printTransform,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b66f7e35466ba9337d7dc7e685ead2c7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_97007f6b72f106c60d0886544555df19,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_22_iPos( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_22_iPos,
        const_str_plain_iPos,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0edc8cacec2283d0259b8c1790b2dac6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_0c5b0d596a8151bd1f5bf644e10998b9,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_23_iHpr( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_23_iHpr,
        const_str_plain_iHpr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f8ad8c4d96a1525ce95fbd90ff9951a5,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_b958960f2fd236679ce319e586eeacf0,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_24_iScale( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_24_iScale,
        const_str_plain_iScale,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_67bdd3356210f8c54f0ce6b2e15719fa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_97e8dda8bf2e2fec759c98598bae2ac3,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr,
        const_str_plain_iPosHpr,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7cfe05b9583b06a64e13e7f4a487bdcd,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_c3e7ebff48fc83a1a43b8f8eedbad5fb,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale,
        const_str_plain_iPosHprScale,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_21e5ffbcd83dc3719251a0cc773c4b50,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_61b9ebff752ab039660c3b1eb14c85ba,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_27_place(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_27_place,
        const_str_plain_place,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ede5eb5c9d547319ad6296a3834aaee2,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_28_explore(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_28_explore,
        const_str_plain_explore,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3bc046785039d0c763921969e5abbeb6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel,
        const_str_plain_rgbPanel,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8b01c6b7b0f1a362254e7c72179e70ce,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList,
        const_str_plain_getChildrenAsList,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f20eb553132f70591ac6f09348b76083,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_bbe0d8d2767726e357eab3b3c0fd9bd1,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_30_select(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_30_select,
        const_str_plain_select,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b401191088d960f3ac2fd4aface3a609,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_31_deselect(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_31_deselect,
        const_str_plain_deselect,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_30e9339eb9718b0bf4ed92e21e17830d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_32_showCS( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_32_showCS,
        const_str_plain_showCS,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a82129c14635955c01cfb361d8ca205c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_f43d5851181b239a5955f5f4ab670845,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_33_hideCS( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_33_hideCS,
        const_str_plain_hideCS,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_a6e51965cda121fb0a19a2726a47a80d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_9b9d92dce635694dfeae541eca84ac72,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_34_posInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_34_posInterval,
        const_str_plain_posInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f697788ed0cf64090cd6a1600b9becbd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_35_hprInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_35_hprInterval,
        const_str_plain_hprInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1546005869a33e57d250c5dc2ce5e9d4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_36_quatInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_36_quatInterval,
        const_str_plain_quatInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_64986c494f8638acc30b7202cc9d095d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval,
        const_str_plain_scaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_251981d21f0e7ac6a88d29596b2ff1e1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_38_shearInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_38_shearInterval,
        const_str_plain_shearInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3b4e490f7fd3a498f95e88a94688294d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval,
        const_str_plain_posHprInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_52d0034855259c50ed78ce646321cc12,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_3_printChildren(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_3_printChildren,
        const_str_plain_printChildren,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1bb6f852641846ecaa47b620831c0e05,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_6518dbc5ec2d6f64384b8ab8ad5c320d,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval,
        const_str_plain_posQuatInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_943e96b997a504a7c8581c23be1fa155,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval,
        const_str_plain_hprScaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8d4fad2be4e746683e779efc097e6fc6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval,
        const_str_plain_quatScaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_93c57184fdf27ec01488b63785c45257,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval,
        const_str_plain_posHprScaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ddeedc3bb3e3990af1babf16721bf63c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval,
        const_str_plain_posQuatScaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8df4f0be86cc851730731fffe3959e9e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval,
        const_str_plain_posHprScaleShearInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_3d5f2dee7311a69e6ac751e09d7f0f87,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval,
        const_str_plain_posQuatScaleShearInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_64748f9472a2446221cb502039bde3fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_47_colorInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_47_colorInterval,
        const_str_plain_colorInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_612efba40b41720fd5ff60f9276db0ce,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval,
        const_str_plain_colorScaleInterval,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f50a0450676289b0423260c876009e5f,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere,
        const_str_plain_attachCollisionSphere,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_24d26537227966edb813d67da7e6e214,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_4_removeChildren(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_4_removeChildren,
        const_str_plain_removeChildren,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_8d5c5ffe3ac136b2bc27338308c8905d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_9636692118d6ae60d387de5cf6ee2550,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment,
        const_str_plain_attachCollisionSegment,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f6b6e768e97eea8a9d9fd1daf5a5ec04,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay,
        const_str_plain_attachCollisionRay,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_6cefa3a641e11cce6d9dafaf21255680,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex( PyObject *defaults )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex,
        const_str_plain_flattenMultitex,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1ec8b1703c5ca7d38b5327cb40adc36e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants,
        const_str_plain_getNumDescendants,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_dacf8d19a45379c1a042d986d0d4159e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions,
        const_str_plain_removeNonCollisions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_b9b9d7c571a64c8ab56168796d8dcb06,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions,
        const_str_plain_subdivideCollisions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_5e756e83abbf94b405c26bfd697e4eea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_47194625d05e416bab876dcaaafddec7,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions,
        const_str_plain_r_subdivideCollisions,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_0f643037e6b0a7646115bb655f2d42a1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree,
        const_str_plain_r_constructCollisionTree,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_d9bf6af6c22e015411ad6e2cc98db101,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        Py_None,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_58_analyze(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_58_analyze,
        const_str_plain_analyze,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_f03b83bec65b720707e68bb9d9f7f928,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_e43f9e9dfaa37742a036468e70e7d9ad,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_5_toggleVis(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_5_toggleVis,
        const_str_plain_toggleVis,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_ba6cd53fc9b355e90dc863a2acc4d9f1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_cfa2cf27cc4cdd2bfc990e4e09a3399e,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_6_showSiblings(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_6_showSiblings,
        const_str_plain_showSiblings,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_cdca1d9a6df747a6cccd7c5aa1482adb,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_4141e963730526886a4b6a002fdcd779,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings,
        const_str_plain_hideSiblings,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_818cda0c76c6effe914b73b37dcaa240,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_32ad1e41899e662e0ba1996bff7d0a9a,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants,
        const_str_plain_showAllDescendants,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_1a445f66eca44998dcb0d5b061eb3036,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_1073b23d348cc8d2dede364119d1b818,
        0
    );


    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_9_isolate(  )
{
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_direct$extensions_native$NodePath_extensions$$$function_9_isolate,
        const_str_plain_isolate,
#if PYTHON_VERSION >= 330
        NULL,
#endif
        codeobj_7c2672539834dd2957cc8a68f41352f1,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        const_dict_empty,
#endif
        module_direct$extensions_native$NodePath_extensions,
        const_str_digest_5f9809dd4faa2e5c0ee4af9b5bc06f02,
        0
    );


    return (PyObject *)result;
}



#if PYTHON_VERSION >= 300
static struct PyModuleDef mdef_direct$extensions_native$NodePath_extensions =
{
    PyModuleDef_HEAD_INIT,
    "direct.extensions_native.NodePath_extensions",   /* m_name */
    NULL,                /* m_doc */
    -1,                  /* m_size */
    NULL,                /* m_methods */
    NULL,                /* m_reload */
    NULL,                /* m_traverse */
    NULL,                /* m_clear */
    NULL,                /* m_free */
  };
#endif

#if PYTHON_VERSION >= 300
extern PyObject *metapath_based_loader;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();
#if PYTHON_VERSION >= 350
extern void _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
extern void _initCompiledAsyncgenTypes();
#endif

// The exported interface to CPython. On import of the module, this function
// gets called. It has to have an exact function name, in cases it's a shared
// library export. This is hidden behind the MOD_INIT_DECL.

MOD_INIT_DECL( direct$extensions_native$NodePath_extensions )
{
#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if ( _init_done )
    {
        return MOD_RETURN_VALUE( module_direct$extensions_native$NodePath_extensions );
    }
    else
    {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();
#if PYTHON_VERSION >= 350
    _initCompiledCoroutineTypes();
#endif
#if PYTHON_VERSION >= 360
    _initCompiledAsyncgenTypes();
#endif

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("direct.extensions_native.NodePath_extensions: Calling createModuleConstants().");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    puts("direct.extensions_native.NodePath_extensions: Calling createModuleCodeObjects().");
#endif
    createModuleCodeObjects();

    // puts( "in initdirect$extensions_native$NodePath_extensions" );

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.
#if PYTHON_VERSION < 300
    module_direct$extensions_native$NodePath_extensions = Py_InitModule4(
        "direct.extensions_native.NodePath_extensions",       // Module Name
        NULL,                    // No methods initially, all are added
                                 // dynamically in actual module code only.
        NULL,                    // No __doc__ is initially set, as it could
                                 // not contain NUL this way, added early in
                                 // actual code.
        NULL,                    // No self for modules, we don't use it.
        PYTHON_API_VERSION
    );
#else
    module_direct$extensions_native$NodePath_extensions = PyModule_Create( &mdef_direct$extensions_native$NodePath_extensions );
#endif

    moduledict_direct$extensions_native$NodePath_extensions = (PyDictObject *)((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;

    CHECK_OBJECT( module_direct$extensions_native$NodePath_extensions );

// Seems to work for Python2.7 out of the box, but for Python3, the module
// doesn't automatically enter "sys.modules", so do it manually.
#if PYTHON_VERSION >= 300
    {
        int r = PyObject_SetItem( PySys_GetObject( (char *)"modules" ), const_str_digest_97d172f6b9adf5324941d1e6dd22a0d3, module_direct$extensions_native$NodePath_extensions );

        assert( r != -1 );
    }
#endif

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    PyObject *module_dict = PyModule_GetDict( module_direct$extensions_native$NodePath_extensions );

    if ( PyDict_GetItem( module_dict, const_str_plain___builtins__ ) == NULL )
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict( value );
#endif

#ifndef __NUITKA_NO_ASSERT__
        int res =
#endif
            PyDict_SetItem( module_dict, const_str_plain___builtins__, value );

        assert( res == 0 );
    }

#if PYTHON_VERSION >= 330
    PyDict_SetItem( module_dict, const_str_plain___loader__, metapath_based_loader );
#endif

    // Temp variables if any
    PyObject *exception_type = NULL, *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = -1;
    PyObject *tmp_args_element_name_1;
    PyObject *tmp_args_element_name_2;
    PyObject *tmp_args_element_name_3;
    PyObject *tmp_args_element_name_4;
    PyObject *tmp_args_element_name_5;
    PyObject *tmp_args_element_name_6;
    PyObject *tmp_args_element_name_7;
    PyObject *tmp_args_element_name_8;
    PyObject *tmp_args_element_name_9;
    PyObject *tmp_args_element_name_10;
    PyObject *tmp_args_element_name_11;
    PyObject *tmp_args_element_name_12;
    PyObject *tmp_args_element_name_13;
    PyObject *tmp_args_element_name_14;
    PyObject *tmp_args_element_name_15;
    PyObject *tmp_args_element_name_16;
    PyObject *tmp_args_element_name_17;
    PyObject *tmp_args_element_name_18;
    PyObject *tmp_args_element_name_19;
    PyObject *tmp_args_element_name_20;
    PyObject *tmp_args_element_name_21;
    PyObject *tmp_args_element_name_22;
    PyObject *tmp_args_element_name_23;
    PyObject *tmp_args_element_name_24;
    PyObject *tmp_args_element_name_25;
    PyObject *tmp_args_element_name_26;
    PyObject *tmp_args_element_name_27;
    PyObject *tmp_args_element_name_28;
    PyObject *tmp_args_element_name_29;
    PyObject *tmp_args_element_name_30;
    PyObject *tmp_args_element_name_31;
    PyObject *tmp_args_element_name_32;
    PyObject *tmp_args_element_name_33;
    PyObject *tmp_args_element_name_34;
    PyObject *tmp_args_element_name_35;
    PyObject *tmp_args_element_name_36;
    PyObject *tmp_args_element_name_37;
    PyObject *tmp_args_element_name_38;
    PyObject *tmp_args_element_name_39;
    PyObject *tmp_args_element_name_40;
    PyObject *tmp_args_element_name_41;
    PyObject *tmp_args_element_name_42;
    PyObject *tmp_args_element_name_43;
    PyObject *tmp_args_element_name_44;
    PyObject *tmp_args_element_name_45;
    PyObject *tmp_args_element_name_46;
    PyObject *tmp_args_element_name_47;
    PyObject *tmp_args_element_name_48;
    PyObject *tmp_args_element_name_49;
    PyObject *tmp_args_element_name_50;
    PyObject *tmp_args_element_name_51;
    PyObject *tmp_args_element_name_52;
    PyObject *tmp_args_element_name_53;
    PyObject *tmp_args_element_name_54;
    PyObject *tmp_args_element_name_55;
    PyObject *tmp_args_element_name_56;
    PyObject *tmp_args_element_name_57;
    PyObject *tmp_args_element_name_58;
    PyObject *tmp_args_element_name_59;
    PyObject *tmp_args_element_name_60;
    PyObject *tmp_args_element_name_61;
    PyObject *tmp_args_element_name_62;
    PyObject *tmp_args_element_name_63;
    PyObject *tmp_args_element_name_64;
    PyObject *tmp_args_element_name_65;
    PyObject *tmp_args_element_name_66;
    PyObject *tmp_args_element_name_67;
    PyObject *tmp_args_element_name_68;
    PyObject *tmp_args_element_name_69;
    PyObject *tmp_args_element_name_70;
    PyObject *tmp_args_element_name_71;
    PyObject *tmp_args_element_name_72;
    PyObject *tmp_args_element_name_73;
    PyObject *tmp_args_element_name_74;
    PyObject *tmp_args_element_name_75;
    PyObject *tmp_args_element_name_76;
    PyObject *tmp_args_element_name_77;
    PyObject *tmp_args_element_name_78;
    PyObject *tmp_args_element_name_79;
    PyObject *tmp_args_element_name_80;
    PyObject *tmp_args_element_name_81;
    PyObject *tmp_args_element_name_82;
    PyObject *tmp_args_element_name_83;
    PyObject *tmp_args_element_name_84;
    PyObject *tmp_args_element_name_85;
    PyObject *tmp_args_element_name_86;
    PyObject *tmp_args_element_name_87;
    PyObject *tmp_args_element_name_88;
    PyObject *tmp_args_element_name_89;
    PyObject *tmp_args_element_name_90;
    PyObject *tmp_args_element_name_91;
    PyObject *tmp_args_element_name_92;
    PyObject *tmp_args_element_name_93;
    PyObject *tmp_args_element_name_94;
    PyObject *tmp_args_element_name_95;
    PyObject *tmp_args_element_name_96;
    PyObject *tmp_args_element_name_97;
    PyObject *tmp_args_element_name_98;
    PyObject *tmp_args_element_name_99;
    PyObject *tmp_args_element_name_100;
    PyObject *tmp_args_element_name_101;
    PyObject *tmp_args_element_name_102;
    PyObject *tmp_args_element_name_103;
    PyObject *tmp_args_element_name_104;
    PyObject *tmp_args_element_name_105;
    PyObject *tmp_args_element_name_106;
    PyObject *tmp_args_element_name_107;
    PyObject *tmp_args_element_name_108;
    PyObject *tmp_args_element_name_109;
    PyObject *tmp_args_element_name_110;
    PyObject *tmp_args_element_name_111;
    PyObject *tmp_args_element_name_112;
    PyObject *tmp_args_element_name_113;
    PyObject *tmp_args_element_name_114;
    PyObject *tmp_args_element_name_115;
    PyObject *tmp_args_element_name_116;
    PyObject *tmp_assign_source_1;
    PyObject *tmp_assign_source_2;
    PyObject *tmp_assign_source_3;
    PyObject *tmp_assign_source_4;
    PyObject *tmp_assign_source_5;
    PyObject *tmp_assign_source_6;
    PyObject *tmp_assign_source_7;
    PyObject *tmp_assign_source_8;
    PyObject *tmp_assign_source_9;
    PyObject *tmp_assign_source_10;
    PyObject *tmp_assign_source_11;
    PyObject *tmp_assign_source_12;
    PyObject *tmp_assign_source_13;
    PyObject *tmp_assign_source_14;
    PyObject *tmp_assign_source_15;
    PyObject *tmp_assign_source_16;
    PyObject *tmp_assign_source_17;
    PyObject *tmp_assign_source_18;
    PyObject *tmp_assign_source_19;
    PyObject *tmp_assign_source_20;
    PyObject *tmp_assign_source_21;
    PyObject *tmp_assign_source_22;
    PyObject *tmp_assign_source_23;
    PyObject *tmp_assign_source_24;
    PyObject *tmp_assign_source_25;
    PyObject *tmp_assign_source_26;
    PyObject *tmp_assign_source_27;
    PyObject *tmp_assign_source_28;
    PyObject *tmp_assign_source_29;
    PyObject *tmp_assign_source_30;
    PyObject *tmp_assign_source_31;
    PyObject *tmp_assign_source_32;
    PyObject *tmp_assign_source_33;
    PyObject *tmp_assign_source_34;
    PyObject *tmp_assign_source_35;
    PyObject *tmp_assign_source_36;
    PyObject *tmp_assign_source_37;
    PyObject *tmp_assign_source_38;
    PyObject *tmp_assign_source_39;
    PyObject *tmp_assign_source_40;
    PyObject *tmp_assign_source_41;
    PyObject *tmp_assign_source_42;
    PyObject *tmp_assign_source_43;
    PyObject *tmp_assign_source_44;
    PyObject *tmp_assign_source_45;
    PyObject *tmp_assign_source_46;
    PyObject *tmp_assign_source_47;
    PyObject *tmp_assign_source_48;
    PyObject *tmp_assign_source_49;
    PyObject *tmp_assign_source_50;
    PyObject *tmp_assign_source_51;
    PyObject *tmp_assign_source_52;
    PyObject *tmp_assign_source_53;
    PyObject *tmp_assign_source_54;
    PyObject *tmp_assign_source_55;
    PyObject *tmp_assign_source_56;
    PyObject *tmp_assign_source_57;
    PyObject *tmp_assign_source_58;
    PyObject *tmp_assign_source_59;
    PyObject *tmp_assign_source_60;
    PyObject *tmp_assign_source_61;
    PyObject *tmp_assign_source_62;
    PyObject *tmp_called_name_1;
    PyObject *tmp_called_name_2;
    PyObject *tmp_called_name_3;
    PyObject *tmp_called_name_4;
    PyObject *tmp_called_name_5;
    PyObject *tmp_called_name_6;
    PyObject *tmp_called_name_7;
    PyObject *tmp_called_name_8;
    PyObject *tmp_called_name_9;
    PyObject *tmp_called_name_10;
    PyObject *tmp_called_name_11;
    PyObject *tmp_called_name_12;
    PyObject *tmp_called_name_13;
    PyObject *tmp_called_name_14;
    PyObject *tmp_called_name_15;
    PyObject *tmp_called_name_16;
    PyObject *tmp_called_name_17;
    PyObject *tmp_called_name_18;
    PyObject *tmp_called_name_19;
    PyObject *tmp_called_name_20;
    PyObject *tmp_called_name_21;
    PyObject *tmp_called_name_22;
    PyObject *tmp_called_name_23;
    PyObject *tmp_called_name_24;
    PyObject *tmp_called_name_25;
    PyObject *tmp_called_name_26;
    PyObject *tmp_called_name_27;
    PyObject *tmp_called_name_28;
    PyObject *tmp_called_name_29;
    PyObject *tmp_called_name_30;
    PyObject *tmp_called_name_31;
    PyObject *tmp_called_name_32;
    PyObject *tmp_called_name_33;
    PyObject *tmp_called_name_34;
    PyObject *tmp_called_name_35;
    PyObject *tmp_called_name_36;
    PyObject *tmp_called_name_37;
    PyObject *tmp_called_name_38;
    PyObject *tmp_called_name_39;
    PyObject *tmp_called_name_40;
    PyObject *tmp_called_name_41;
    PyObject *tmp_called_name_42;
    PyObject *tmp_called_name_43;
    PyObject *tmp_called_name_44;
    PyObject *tmp_called_name_45;
    PyObject *tmp_called_name_46;
    PyObject *tmp_called_name_47;
    PyObject *tmp_called_name_48;
    PyObject *tmp_called_name_49;
    PyObject *tmp_called_name_50;
    PyObject *tmp_called_name_51;
    PyObject *tmp_called_name_52;
    PyObject *tmp_called_name_53;
    PyObject *tmp_called_name_54;
    PyObject *tmp_called_name_55;
    PyObject *tmp_called_name_56;
    PyObject *tmp_called_name_57;
    PyObject *tmp_called_name_58;
    PyObject *tmp_defaults_1;
    PyObject *tmp_defaults_2;
    PyObject *tmp_defaults_3;
    PyObject *tmp_defaults_4;
    PyObject *tmp_defaults_5;
    PyObject *tmp_defaults_6;
    PyObject *tmp_defaults_7;
    PyObject *tmp_defaults_8;
    PyObject *tmp_defaults_9;
    PyObject *tmp_defaults_10;
    PyObject *tmp_defaults_11;
    PyObject *tmp_defaults_12;
    PyObject *tmp_defaults_13;
    PyObject *tmp_defaults_14;
    PyObject *tmp_defaults_15;
    PyObject *tmp_defaults_16;
    PyObject *tmp_defaults_17;
    PyObject *tmp_fromlist_name_1;
    PyObject *tmp_fromlist_name_2;
    PyObject *tmp_globals_name_1;
    PyObject *tmp_globals_name_2;
    PyObject *tmp_import_name_from_1;
    PyObject *tmp_import_name_from_2;
    PyObject *tmp_level_name_2;
    PyObject *tmp_locals_name_1;
    PyObject *tmp_locals_name_2;
    PyObject *tmp_name_name_1;
    PyObject *tmp_name_name_2;
    int tmp_res;
    NUITKA_MAY_BE_UNUSED PyObject *tmp_unused;
    struct Nuitka_FrameObject *frame_module;


    // Module code.
    tmp_assign_source_1 = const_str_digest_49ae60eddca40526491e8bdd07022c60;
    UPDATE_STRING_DICT0( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1 );
    tmp_assign_source_2 = module_filename_obj;
    UPDATE_STRING_DICT0( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2 );
    // Frame without reuse.
    frame_module = MAKE_MODULE_FRAME( codeobj_05b3e2c7f4df2ecef731cec0e57dcc27, module_direct$extensions_native$NodePath_extensions );

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack( frame_module );
    assert( Py_REFCNT( frame_module ) == 2 );

    // Framed code:
    tmp_name_name_1 = const_str_digest_4314234708fbc134069947f7a4708b23;
    tmp_globals_name_1 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_1 = Py_None;
    tmp_fromlist_name_1 = const_tuple_str_plain_NodePath_tuple;
    frame_module->m_frame.f_lineno = 11;
    tmp_import_name_from_1 = IMPORT_MODULE4( tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1 );
    if ( tmp_import_name_from_1 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_3 = IMPORT_NAME( tmp_import_name_from_1, const_str_plain_NodePath );
    Py_DECREF( tmp_import_name_from_1 );
    if ( tmp_assign_source_3 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 11;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath, tmp_assign_source_3 );
    tmp_name_name_2 = const_str_plain_extension_native_helpers;
    tmp_globals_name_2 = ((PyModuleObject *)module_direct$extensions_native$NodePath_extensions)->md_dict;
    tmp_locals_name_2 = Py_None;
    tmp_fromlist_name_2 = const_tuple_str_plain_Dtool_funcToMethod_tuple;
    tmp_level_name_2 = const_int_pos_1;
    frame_module->m_frame.f_lineno = 12;
    tmp_import_name_from_2 = IMPORT_MODULE5( tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2 );
    if ( tmp_import_name_from_2 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    tmp_assign_source_4 = IMPORT_NAME( tmp_import_name_from_2, const_str_plain_Dtool_funcToMethod );
    Py_DECREF( tmp_import_name_from_2 );
    if ( tmp_assign_source_4 == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 12;

        goto frame_exception_exit_1;
    }
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod, tmp_assign_source_4 );
    tmp_assign_source_5 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_1_id(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_id, tmp_assign_source_5 );
    tmp_called_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_1 == NULL ))
    {
        tmp_called_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 20;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_1 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_id );

    if (unlikely( tmp_args_element_name_1 == NULL ))
    {
        tmp_args_element_name_1 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_id );
    }

    if ( tmp_args_element_name_1 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "id" );
        exception_tb = NULL;

        exception_lineno = 20;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_2 == NULL ))
    {
        tmp_args_element_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 20;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 20;
    {
        PyObject *call_args[] = { tmp_args_element_name_1, tmp_args_element_name_2 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_1, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 20;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_id );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 238 ], 24, 0 );
        exception_tb = NULL;

        exception_lineno = 21;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_6 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_2_getChildrenAsList(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getChildrenAsList, tmp_assign_source_6 );
    tmp_called_name_2 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_2 == NULL ))
    {
        tmp_called_name_2 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_2 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 28;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getChildrenAsList );

    if (unlikely( tmp_args_element_name_3 == NULL ))
    {
        tmp_args_element_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getChildrenAsList );
    }

    if ( tmp_args_element_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "getChildrenAsList" );
        exception_tb = NULL;

        exception_lineno = 28;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_4 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_4 == NULL ))
    {
        tmp_args_element_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 28;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 28;
    {
        PyObject *call_args[] = { tmp_args_element_name_3, tmp_args_element_name_4 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_2, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 28;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_getChildrenAsList );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 262 ], 39, 0 );
        exception_tb = NULL;

        exception_lineno = 29;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_7 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_3_printChildren(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printChildren, tmp_assign_source_7 );
    tmp_called_name_3 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_3 == NULL ))
    {
        tmp_called_name_3 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_3 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 37;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_5 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printChildren );

    if (unlikely( tmp_args_element_name_5 == NULL ))
    {
        tmp_args_element_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printChildren );
    }

    if ( tmp_args_element_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printChildren" );
        exception_tb = NULL;

        exception_lineno = 37;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_6 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_6 == NULL ))
    {
        tmp_args_element_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 37;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 37;
    {
        PyObject *call_args[] = { tmp_args_element_name_5, tmp_args_element_name_6 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_3, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 37;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printChildren );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 301 ], 35, 0 );
        exception_tb = NULL;

        exception_lineno = 38;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_8 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_4_removeChildren(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_removeChildren, tmp_assign_source_8 );
    tmp_called_name_4 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_4 == NULL ))
    {
        tmp_called_name_4 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_4 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 45;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_7 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_removeChildren );

    if (unlikely( tmp_args_element_name_7 == NULL ))
    {
        tmp_args_element_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_removeChildren );
    }

    if ( tmp_args_element_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "removeChildren" );
        exception_tb = NULL;

        exception_lineno = 45;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_8 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_8 == NULL ))
    {
        tmp_args_element_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 45;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 45;
    {
        PyObject *call_args[] = { tmp_args_element_name_7, tmp_args_element_name_8 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_4, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 45;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_removeChildren );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 336 ], 36, 0 );
        exception_tb = NULL;

        exception_lineno = 46;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_9 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_5_toggleVis(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_toggleVis, tmp_assign_source_9 );
    tmp_called_name_5 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_5 == NULL ))
    {
        tmp_called_name_5 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_5 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 58;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_9 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_toggleVis );

    if (unlikely( tmp_args_element_name_9 == NULL ))
    {
        tmp_args_element_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_toggleVis );
    }

    if ( tmp_args_element_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "toggleVis" );
        exception_tb = NULL;

        exception_lineno = 58;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_10 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_10 == NULL ))
    {
        tmp_args_element_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 58;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 58;
    {
        PyObject *call_args[] = { tmp_args_element_name_9, tmp_args_element_name_10 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_5, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 58;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_toggleVis );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 372 ], 31, 0 );
        exception_tb = NULL;

        exception_lineno = 59;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_10 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_6_showSiblings(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showSiblings, tmp_assign_source_10 );
    tmp_called_name_6 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_6 == NULL ))
    {
        tmp_called_name_6 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_6 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 68;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_11 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showSiblings );

    if (unlikely( tmp_args_element_name_11 == NULL ))
    {
        tmp_args_element_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_showSiblings );
    }

    if ( tmp_args_element_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "showSiblings" );
        exception_tb = NULL;

        exception_lineno = 68;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_12 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_12 == NULL ))
    {
        tmp_args_element_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 68;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 68;
    {
        PyObject *call_args[] = { tmp_args_element_name_11, tmp_args_element_name_12 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_6, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 68;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_showSiblings );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 403 ], 34, 0 );
        exception_tb = NULL;

        exception_lineno = 69;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_11 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_7_hideSiblings(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hideSiblings, tmp_assign_source_11 );
    tmp_called_name_7 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_7 == NULL ))
    {
        tmp_called_name_7 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_7 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 78;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_13 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hideSiblings );

    if (unlikely( tmp_args_element_name_13 == NULL ))
    {
        tmp_args_element_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hideSiblings );
    }

    if ( tmp_args_element_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "hideSiblings" );
        exception_tb = NULL;

        exception_lineno = 78;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_14 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_14 == NULL ))
    {
        tmp_args_element_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 78;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 78;
    {
        PyObject *call_args[] = { tmp_args_element_name_13, tmp_args_element_name_14 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_7, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 78;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_hideSiblings );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 437 ], 34, 0 );
        exception_tb = NULL;

        exception_lineno = 79;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_12 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_8_showAllDescendants(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showAllDescendants, tmp_assign_source_12 );
    tmp_called_name_8 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_8 == NULL ))
    {
        tmp_called_name_8 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_8 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 88;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_15 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showAllDescendants );

    if (unlikely( tmp_args_element_name_15 == NULL ))
    {
        tmp_args_element_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_showAllDescendants );
    }

    if ( tmp_args_element_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "showAllDescendants" );
        exception_tb = NULL;

        exception_lineno = 88;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_16 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_16 == NULL ))
    {
        tmp_args_element_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 88;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 88;
    {
        PyObject *call_args[] = { tmp_args_element_name_15, tmp_args_element_name_16 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_8, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 88;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_showAllDescendants );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 471 ], 40, 0 );
        exception_tb = NULL;

        exception_lineno = 89;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_13 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_9_isolate(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_isolate, tmp_assign_source_13 );
    tmp_called_name_9 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_9 == NULL ))
    {
        tmp_called_name_9 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_9 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 99;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_17 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_isolate );

    if (unlikely( tmp_args_element_name_17 == NULL ))
    {
        tmp_args_element_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_isolate );
    }

    if ( tmp_args_element_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "isolate" );
        exception_tb = NULL;

        exception_lineno = 99;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_18 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_18 == NULL ))
    {
        tmp_args_element_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 99;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 99;
    {
        PyObject *call_args[] = { tmp_args_element_name_17, tmp_args_element_name_18 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_9, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 99;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_isolate );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 511 ], 29, 0 );
        exception_tb = NULL;

        exception_lineno = 100;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_14 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_10_remove(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_remove, tmp_assign_source_14 );
    tmp_called_name_10 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_10 == NULL ))
    {
        tmp_called_name_10 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_10 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 111;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_19 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_remove );

    if (unlikely( tmp_args_element_name_19 == NULL ))
    {
        tmp_args_element_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_remove );
    }

    if ( tmp_args_element_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "remove" );
        exception_tb = NULL;

        exception_lineno = 111;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_20 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_20 == NULL ))
    {
        tmp_args_element_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 111;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 111;
    {
        PyObject *call_args[] = { tmp_args_element_name_19, tmp_args_element_name_20 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_10, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 111;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_remove );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 540 ], 28, 0 );
        exception_tb = NULL;

        exception_lineno = 112;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_15 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_11_lsNames(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_lsNames, tmp_assign_source_15 );
    tmp_called_name_11 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_11 == NULL ))
    {
        tmp_called_name_11 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_11 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 126;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_21 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_lsNames );

    if (unlikely( tmp_args_element_name_21 == NULL ))
    {
        tmp_args_element_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_lsNames );
    }

    if ( tmp_args_element_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "lsNames" );
        exception_tb = NULL;

        exception_lineno = 126;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_22 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_22 == NULL ))
    {
        tmp_args_element_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 126;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 126;
    {
        PyObject *call_args[] = { tmp_args_element_name_21, tmp_args_element_name_22 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_11, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 126;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_lsNames );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 568 ], 29, 0 );
        exception_tb = NULL;

        exception_lineno = 127;

        goto frame_exception_exit_1;
    }

    tmp_defaults_1 = const_tuple_str_space_tuple;
    Py_INCREF( tmp_defaults_1 );
    tmp_assign_source_16 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_12_lsNamesRecurse( tmp_defaults_1 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_lsNamesRecurse, tmp_assign_source_16 );
    tmp_called_name_12 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_12 == NULL ))
    {
        tmp_called_name_12 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_12 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 138;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_23 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_lsNamesRecurse );

    if (unlikely( tmp_args_element_name_23 == NULL ))
    {
        tmp_args_element_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_lsNamesRecurse );
    }

    if ( tmp_args_element_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "lsNamesRecurse" );
        exception_tb = NULL;

        exception_lineno = 138;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_24 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_24 == NULL ))
    {
        tmp_args_element_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 138;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 138;
    {
        PyObject *call_args[] = { tmp_args_element_name_23, tmp_args_element_name_24 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_12, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 138;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_lsNamesRecurse );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 597 ], 36, 0 );
        exception_tb = NULL;

        exception_lineno = 139;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_17 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_13_reverseLsNames(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_reverseLsNames, tmp_assign_source_17 );
    tmp_called_name_13 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_13 == NULL ))
    {
        tmp_called_name_13 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_13 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 153;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_25 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_reverseLsNames );

    if (unlikely( tmp_args_element_name_25 == NULL ))
    {
        tmp_args_element_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_reverseLsNames );
    }

    if ( tmp_args_element_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "reverseLsNames" );
        exception_tb = NULL;

        exception_lineno = 153;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_26 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_26 == NULL ))
    {
        tmp_args_element_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 153;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 153;
    {
        PyObject *call_args[] = { tmp_args_element_name_25, tmp_args_element_name_26 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_13, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 153;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_reverseLsNames );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 633 ], 36, 0 );
        exception_tb = NULL;

        exception_lineno = 154;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_18 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_14_getAncestry(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getAncestry, tmp_assign_source_18 );
    tmp_called_name_14 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_14 == NULL ))
    {
        tmp_called_name_14 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_14 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 163;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_27 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getAncestry );

    if (unlikely( tmp_args_element_name_27 == NULL ))
    {
        tmp_args_element_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getAncestry );
    }

    if ( tmp_args_element_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "getAncestry" );
        exception_tb = NULL;

        exception_lineno = 163;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_28 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_28 == NULL ))
    {
        tmp_args_element_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 163;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 163;
    {
        PyObject *call_args[] = { tmp_args_element_name_27, tmp_args_element_name_28 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_14, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 163;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_getAncestry );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 669 ], 33, 0 );
        exception_tb = NULL;

        exception_lineno = 164;

        goto frame_exception_exit_1;
    }

    tmp_defaults_2 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_2 );
    tmp_assign_source_19 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_15_pPrintString( tmp_defaults_2 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_pPrintString, tmp_assign_source_19 );
    tmp_called_name_15 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_15 == NULL ))
    {
        tmp_called_name_15 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_15 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 197;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_29 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_pPrintString );

    if (unlikely( tmp_args_element_name_29 == NULL ))
    {
        tmp_args_element_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_pPrintString );
    }

    if ( tmp_args_element_name_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "pPrintString" );
        exception_tb = NULL;

        exception_lineno = 197;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_30 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_30 == NULL ))
    {
        tmp_args_element_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 197;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 197;
    {
        PyObject *call_args[] = { tmp_args_element_name_29, tmp_args_element_name_30 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_15, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 197;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_pPrintString );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 702 ], 34, 0 );
        exception_tb = NULL;

        exception_lineno = 198;

        goto frame_exception_exit_1;
    }

    tmp_defaults_3 = const_tuple_none_int_pos_2_tuple;
    Py_INCREF( tmp_defaults_3 );
    tmp_assign_source_20 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_16_printPos( tmp_defaults_3 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPos, tmp_assign_source_20 );
    tmp_called_name_16 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_16 == NULL ))
    {
        tmp_called_name_16 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_16 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 216;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_31 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPos );

    if (unlikely( tmp_args_element_name_31 == NULL ))
    {
        tmp_args_element_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printPos );
    }

    if ( tmp_args_element_name_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printPos" );
        exception_tb = NULL;

        exception_lineno = 216;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_32 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_32 == NULL ))
    {
        tmp_args_element_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 216;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 216;
    {
        PyObject *call_args[] = { tmp_args_element_name_31, tmp_args_element_name_32 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_16, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 216;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printPos );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 736 ], 30, 0 );
        exception_tb = NULL;

        exception_lineno = 217;

        goto frame_exception_exit_1;
    }

    tmp_defaults_4 = const_tuple_none_int_pos_2_tuple;
    Py_INCREF( tmp_defaults_4 );
    tmp_assign_source_21 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_17_printHpr( tmp_defaults_4 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printHpr, tmp_assign_source_21 );
    tmp_called_name_17 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_17 == NULL ))
    {
        tmp_called_name_17 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_17 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 235;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_33 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printHpr );

    if (unlikely( tmp_args_element_name_33 == NULL ))
    {
        tmp_args_element_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printHpr );
    }

    if ( tmp_args_element_name_33 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printHpr" );
        exception_tb = NULL;

        exception_lineno = 235;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_34 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_34 == NULL ))
    {
        tmp_args_element_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 235;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 235;
    {
        PyObject *call_args[] = { tmp_args_element_name_33, tmp_args_element_name_34 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_17, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 235;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printHpr );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 766 ], 30, 0 );
        exception_tb = NULL;

        exception_lineno = 236;

        goto frame_exception_exit_1;
    }

    tmp_defaults_5 = const_tuple_none_int_pos_2_tuple;
    Py_INCREF( tmp_defaults_5 );
    tmp_assign_source_22 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_18_printScale( tmp_defaults_5 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printScale, tmp_assign_source_22 );
    tmp_called_name_18 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_18 == NULL ))
    {
        tmp_called_name_18 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_18 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 255;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_35 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printScale );

    if (unlikely( tmp_args_element_name_35 == NULL ))
    {
        tmp_args_element_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printScale );
    }

    if ( tmp_args_element_name_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printScale" );
        exception_tb = NULL;

        exception_lineno = 255;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_36 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_36 == NULL ))
    {
        tmp_args_element_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_36 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 255;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 255;
    {
        PyObject *call_args[] = { tmp_args_element_name_35, tmp_args_element_name_36 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_18, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 255;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printScale );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 796 ], 32, 0 );
        exception_tb = NULL;

        exception_lineno = 256;

        goto frame_exception_exit_1;
    }

    tmp_defaults_6 = const_tuple_none_int_pos_2_tuple;
    Py_INCREF( tmp_defaults_6 );
    tmp_assign_source_23 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_19_printPosHpr( tmp_defaults_6 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPosHpr, tmp_assign_source_23 );
    tmp_called_name_19 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_19 == NULL ))
    {
        tmp_called_name_19 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_19 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 279;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_37 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPosHpr );

    if (unlikely( tmp_args_element_name_37 == NULL ))
    {
        tmp_args_element_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printPosHpr );
    }

    if ( tmp_args_element_name_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printPosHpr" );
        exception_tb = NULL;

        exception_lineno = 279;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_38 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_38 == NULL ))
    {
        tmp_args_element_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 279;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 279;
    {
        PyObject *call_args[] = { tmp_args_element_name_37, tmp_args_element_name_38 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_19, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 279;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printPosHpr );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 828 ], 33, 0 );
        exception_tb = NULL;

        exception_lineno = 280;

        goto frame_exception_exit_1;
    }

    tmp_defaults_7 = const_tuple_none_int_pos_2_tuple;
    Py_INCREF( tmp_defaults_7 );
    tmp_assign_source_24 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_20_printPosHprScale( tmp_defaults_7 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPosHprScale, tmp_assign_source_24 );
    tmp_called_name_20 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_20 == NULL ))
    {
        tmp_called_name_20 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_20 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 308;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_39 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printPosHprScale );

    if (unlikely( tmp_args_element_name_39 == NULL ))
    {
        tmp_args_element_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printPosHprScale );
    }

    if ( tmp_args_element_name_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printPosHprScale" );
        exception_tb = NULL;

        exception_lineno = 308;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_40 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_40 == NULL ))
    {
        tmp_args_element_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 308;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 308;
    {
        PyObject *call_args[] = { tmp_args_element_name_39, tmp_args_element_name_40 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_20, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 308;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printPosHprScale );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 861 ], 38, 0 );
        exception_tb = NULL;

        exception_lineno = 309;

        goto frame_exception_exit_1;
    }

    tmp_defaults_8 = const_tuple_none_int_pos_2_int_0_tuple;
    Py_INCREF( tmp_defaults_8 );
    tmp_assign_source_25 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_21_printTransform( tmp_defaults_8 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printTransform, tmp_assign_source_25 );
    tmp_called_name_21 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_21 == NULL ))
    {
        tmp_called_name_21 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_21 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 347;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_41 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_printTransform );

    if (unlikely( tmp_args_element_name_41 == NULL ))
    {
        tmp_args_element_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_printTransform );
    }

    if ( tmp_args_element_name_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "printTransform" );
        exception_tb = NULL;

        exception_lineno = 347;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_42 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_42 == NULL ))
    {
        tmp_args_element_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 347;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 347;
    {
        PyObject *call_args[] = { tmp_args_element_name_41, tmp_args_element_name_42 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_21, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 347;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_printTransform );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 899 ], 36, 0 );
        exception_tb = NULL;

        exception_lineno = 348;

        goto frame_exception_exit_1;
    }

    tmp_defaults_9 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_9 );
    tmp_assign_source_26 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_22_iPos( tmp_defaults_9 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPos, tmp_assign_source_26 );
    tmp_called_name_22 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_22 == NULL ))
    {
        tmp_called_name_22 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_22 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 359;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_43 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPos );

    if (unlikely( tmp_args_element_name_43 == NULL ))
    {
        tmp_args_element_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iPos );
    }

    if ( tmp_args_element_name_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "iPos" );
        exception_tb = NULL;

        exception_lineno = 359;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_44 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_44 == NULL ))
    {
        tmp_args_element_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 359;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 359;
    {
        PyObject *call_args[] = { tmp_args_element_name_43, tmp_args_element_name_44 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_22, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 359;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_iPos );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 935 ], 26, 0 );
        exception_tb = NULL;

        exception_lineno = 360;

        goto frame_exception_exit_1;
    }

    tmp_defaults_10 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_10 );
    tmp_assign_source_27 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_23_iHpr( tmp_defaults_10 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iHpr, tmp_assign_source_27 );
    tmp_called_name_23 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_23 == NULL ))
    {
        tmp_called_name_23 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_23 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 371;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_45 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iHpr );

    if (unlikely( tmp_args_element_name_45 == NULL ))
    {
        tmp_args_element_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iHpr );
    }

    if ( tmp_args_element_name_45 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "iHpr" );
        exception_tb = NULL;

        exception_lineno = 371;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_46 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_46 == NULL ))
    {
        tmp_args_element_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 371;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 371;
    {
        PyObject *call_args[] = { tmp_args_element_name_45, tmp_args_element_name_46 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_23, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 371;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_iHpr );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 961 ], 26, 0 );
        exception_tb = NULL;

        exception_lineno = 372;

        goto frame_exception_exit_1;
    }

    tmp_defaults_11 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_11 );
    tmp_assign_source_28 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_24_iScale( tmp_defaults_11 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iScale, tmp_assign_source_28 );
    tmp_called_name_24 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_24 == NULL ))
    {
        tmp_called_name_24 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_24 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 382;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_47 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iScale );

    if (unlikely( tmp_args_element_name_47 == NULL ))
    {
        tmp_args_element_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iScale );
    }

    if ( tmp_args_element_name_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "iScale" );
        exception_tb = NULL;

        exception_lineno = 382;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_48 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_48 == NULL ))
    {
        tmp_args_element_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 382;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 382;
    {
        PyObject *call_args[] = { tmp_args_element_name_47, tmp_args_element_name_48 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_24, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 382;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_iScale );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 987 ], 28, 0 );
        exception_tb = NULL;

        exception_lineno = 383;

        goto frame_exception_exit_1;
    }

    tmp_defaults_12 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_12 );
    tmp_assign_source_29 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_25_iPosHpr( tmp_defaults_12 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPosHpr, tmp_assign_source_29 );
    tmp_called_name_25 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_25 == NULL ))
    {
        tmp_called_name_25 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_25 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 393;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_49 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPosHpr );

    if (unlikely( tmp_args_element_name_49 == NULL ))
    {
        tmp_args_element_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iPosHpr );
    }

    if ( tmp_args_element_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "iPosHpr" );
        exception_tb = NULL;

        exception_lineno = 393;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_50 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_50 == NULL ))
    {
        tmp_args_element_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 393;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 393;
    {
        PyObject *call_args[] = { tmp_args_element_name_49, tmp_args_element_name_50 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_25, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 393;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_iPosHpr );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1015 ], 29, 0 );
        exception_tb = NULL;

        exception_lineno = 394;

        goto frame_exception_exit_1;
    }

    tmp_defaults_13 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_13 );
    tmp_assign_source_30 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_26_iPosHprScale( tmp_defaults_13 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPosHprScale, tmp_assign_source_30 );
    tmp_called_name_26 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_26 == NULL ))
    {
        tmp_called_name_26 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_26 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 405;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_51 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_iPosHprScale );

    if (unlikely( tmp_args_element_name_51 == NULL ))
    {
        tmp_args_element_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_iPosHprScale );
    }

    if ( tmp_args_element_name_51 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "iPosHprScale" );
        exception_tb = NULL;

        exception_lineno = 405;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_52 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_52 == NULL ))
    {
        tmp_args_element_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_52 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 405;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 405;
    {
        PyObject *call_args[] = { tmp_args_element_name_51, tmp_args_element_name_52 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_26, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 405;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_iPosHprScale );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1044 ], 34, 0 );
        exception_tb = NULL;

        exception_lineno = 406;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_31 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_27_place(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_place, tmp_assign_source_31 );
    tmp_called_name_27 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_27 == NULL ))
    {
        tmp_called_name_27 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_27 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 416;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_53 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_place );

    if (unlikely( tmp_args_element_name_53 == NULL ))
    {
        tmp_args_element_name_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_place );
    }

    if ( tmp_args_element_name_53 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "place" );
        exception_tb = NULL;

        exception_lineno = 416;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_54 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_54 == NULL ))
    {
        tmp_args_element_name_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_54 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 416;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 416;
    {
        PyObject *call_args[] = { tmp_args_element_name_53, tmp_args_element_name_54 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_27, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 416;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_place );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1078 ], 27, 0 );
        exception_tb = NULL;

        exception_lineno = 417;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_32 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_28_explore(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_explore, tmp_assign_source_32 );
    tmp_called_name_28 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_28 == NULL ))
    {
        tmp_called_name_28 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_28 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 427;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_55 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_explore );

    if (unlikely( tmp_args_element_name_55 == NULL ))
    {
        tmp_args_element_name_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_explore );
    }

    if ( tmp_args_element_name_55 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "explore" );
        exception_tb = NULL;

        exception_lineno = 427;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_56 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_56 == NULL ))
    {
        tmp_args_element_name_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_56 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 427;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 427;
    {
        PyObject *call_args[] = { tmp_args_element_name_55, tmp_args_element_name_56 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_28, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 427;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_explore );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1105 ], 29, 0 );
        exception_tb = NULL;

        exception_lineno = 428;

        goto frame_exception_exit_1;
    }

    tmp_defaults_14 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_14 );
    tmp_assign_source_33 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_29_rgbPanel( tmp_defaults_14 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_rgbPanel, tmp_assign_source_33 );
    tmp_called_name_29 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_29 == NULL ))
    {
        tmp_called_name_29 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_29 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 438;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_57 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_rgbPanel );

    if (unlikely( tmp_args_element_name_57 == NULL ))
    {
        tmp_args_element_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_rgbPanel );
    }

    if ( tmp_args_element_name_57 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "rgbPanel" );
        exception_tb = NULL;

        exception_lineno = 438;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_58 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_58 == NULL ))
    {
        tmp_args_element_name_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_58 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 438;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 438;
    {
        PyObject *call_args[] = { tmp_args_element_name_57, tmp_args_element_name_58 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_29, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 438;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_rgbPanel );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1134 ], 30, 0 );
        exception_tb = NULL;

        exception_lineno = 439;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_34 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_30_select(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_select, tmp_assign_source_34 );
    tmp_called_name_30 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_30 == NULL ))
    {
        tmp_called_name_30 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_30 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 445;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_59 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_select );

    if (unlikely( tmp_args_element_name_59 == NULL ))
    {
        tmp_args_element_name_59 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_select );
    }

    if ( tmp_args_element_name_59 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "select" );
        exception_tb = NULL;

        exception_lineno = 445;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_60 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_60 == NULL ))
    {
        tmp_args_element_name_60 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_60 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 445;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 445;
    {
        PyObject *call_args[] = { tmp_args_element_name_59, tmp_args_element_name_60 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_30, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 445;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_select );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1164 ], 28, 0 );
        exception_tb = NULL;

        exception_lineno = 446;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_35 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_31_deselect(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_deselect, tmp_assign_source_35 );
    tmp_called_name_31 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_31 == NULL ))
    {
        tmp_called_name_31 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_31 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 452;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_61 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_deselect );

    if (unlikely( tmp_args_element_name_61 == NULL ))
    {
        tmp_args_element_name_61 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_deselect );
    }

    if ( tmp_args_element_name_61 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "deselect" );
        exception_tb = NULL;

        exception_lineno = 452;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_62 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_62 == NULL ))
    {
        tmp_args_element_name_62 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_62 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 452;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 452;
    {
        PyObject *call_args[] = { tmp_args_element_name_61, tmp_args_element_name_62 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_31, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 452;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_deselect );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1192 ], 30, 0 );
        exception_tb = NULL;

        exception_lineno = 453;

        goto frame_exception_exit_1;
    }

    tmp_defaults_15 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_15 );
    tmp_assign_source_36 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_32_showCS( tmp_defaults_15 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showCS, tmp_assign_source_36 );
    tmp_called_name_32 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_32 == NULL ))
    {
        tmp_called_name_32 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_32 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 470;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_63 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_showCS );

    if (unlikely( tmp_args_element_name_63 == NULL ))
    {
        tmp_args_element_name_63 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_showCS );
    }

    if ( tmp_args_element_name_63 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "showCS" );
        exception_tb = NULL;

        exception_lineno = 470;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_64 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_64 == NULL ))
    {
        tmp_args_element_name_64 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_64 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 470;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 470;
    {
        PyObject *call_args[] = { tmp_args_element_name_63, tmp_args_element_name_64 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_32, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 470;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_showCS );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1222 ], 28, 0 );
        exception_tb = NULL;

        exception_lineno = 471;

        goto frame_exception_exit_1;
    }

    tmp_defaults_16 = const_tuple_none_tuple;
    Py_INCREF( tmp_defaults_16 );
    tmp_assign_source_37 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_33_hideCS( tmp_defaults_16 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hideCS, tmp_assign_source_37 );
    tmp_called_name_33 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_33 == NULL ))
    {
        tmp_called_name_33 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_33 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 488;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_65 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hideCS );

    if (unlikely( tmp_args_element_name_65 == NULL ))
    {
        tmp_args_element_name_65 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hideCS );
    }

    if ( tmp_args_element_name_65 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "hideCS" );
        exception_tb = NULL;

        exception_lineno = 488;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_66 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_66 == NULL ))
    {
        tmp_args_element_name_66 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_66 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 488;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 488;
    {
        PyObject *call_args[] = { tmp_args_element_name_65, tmp_args_element_name_66 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_33, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 488;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_hideCS );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1250 ], 28, 0 );
        exception_tb = NULL;

        exception_lineno = 489;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_38 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_34_posInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posInterval, tmp_assign_source_38 );
    tmp_called_name_34 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_34 == NULL ))
    {
        tmp_called_name_34 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_34 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 495;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_67 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posInterval );

    if (unlikely( tmp_args_element_name_67 == NULL ))
    {
        tmp_args_element_name_67 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posInterval );
    }

    if ( tmp_args_element_name_67 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posInterval" );
        exception_tb = NULL;

        exception_lineno = 495;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_68 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_68 == NULL ))
    {
        tmp_args_element_name_68 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_68 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 495;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 495;
    {
        PyObject *call_args[] = { tmp_args_element_name_67, tmp_args_element_name_68 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_34, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 495;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1278 ], 33, 0 );
        exception_tb = NULL;

        exception_lineno = 496;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_39 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_35_hprInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hprInterval, tmp_assign_source_39 );
    tmp_called_name_35 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_35 == NULL ))
    {
        tmp_called_name_35 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_35 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 502;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_69 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hprInterval );

    if (unlikely( tmp_args_element_name_69 == NULL ))
    {
        tmp_args_element_name_69 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hprInterval );
    }

    if ( tmp_args_element_name_69 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "hprInterval" );
        exception_tb = NULL;

        exception_lineno = 502;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_70 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_70 == NULL ))
    {
        tmp_args_element_name_70 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_70 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 502;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 502;
    {
        PyObject *call_args[] = { tmp_args_element_name_69, tmp_args_element_name_70 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_35, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 502;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_hprInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1311 ], 33, 0 );
        exception_tb = NULL;

        exception_lineno = 503;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_40 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_36_quatInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_quatInterval, tmp_assign_source_40 );
    tmp_called_name_36 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_36 == NULL ))
    {
        tmp_called_name_36 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_36 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 509;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_71 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_quatInterval );

    if (unlikely( tmp_args_element_name_71 == NULL ))
    {
        tmp_args_element_name_71 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_quatInterval );
    }

    if ( tmp_args_element_name_71 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "quatInterval" );
        exception_tb = NULL;

        exception_lineno = 509;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_72 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_72 == NULL ))
    {
        tmp_args_element_name_72 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_72 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 509;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 509;
    {
        PyObject *call_args[] = { tmp_args_element_name_71, tmp_args_element_name_72 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_36, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 509;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_quatInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1344 ], 34, 0 );
        exception_tb = NULL;

        exception_lineno = 510;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_41 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_37_scaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_scaleInterval, tmp_assign_source_41 );
    tmp_called_name_37 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_37 == NULL ))
    {
        tmp_called_name_37 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_37 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 516;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_73 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_scaleInterval );

    if (unlikely( tmp_args_element_name_73 == NULL ))
    {
        tmp_args_element_name_73 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_scaleInterval );
    }

    if ( tmp_args_element_name_73 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "scaleInterval" );
        exception_tb = NULL;

        exception_lineno = 516;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_74 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_74 == NULL ))
    {
        tmp_args_element_name_74 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_74 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 516;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 516;
    {
        PyObject *call_args[] = { tmp_args_element_name_73, tmp_args_element_name_74 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_37, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 516;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_scaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1378 ], 35, 0 );
        exception_tb = NULL;

        exception_lineno = 517;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_42 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_38_shearInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_shearInterval, tmp_assign_source_42 );
    tmp_called_name_38 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_38 == NULL ))
    {
        tmp_called_name_38 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_38 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 523;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_75 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_shearInterval );

    if (unlikely( tmp_args_element_name_75 == NULL ))
    {
        tmp_args_element_name_75 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_shearInterval );
    }

    if ( tmp_args_element_name_75 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "shearInterval" );
        exception_tb = NULL;

        exception_lineno = 523;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_76 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_76 == NULL ))
    {
        tmp_args_element_name_76 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_76 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 523;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 523;
    {
        PyObject *call_args[] = { tmp_args_element_name_75, tmp_args_element_name_76 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_38, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 523;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_shearInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1413 ], 35, 0 );
        exception_tb = NULL;

        exception_lineno = 524;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_43 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_39_posHprInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprInterval, tmp_assign_source_43 );
    tmp_called_name_39 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_39 == NULL ))
    {
        tmp_called_name_39 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_39 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 530;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_77 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprInterval );

    if (unlikely( tmp_args_element_name_77 == NULL ))
    {
        tmp_args_element_name_77 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posHprInterval );
    }

    if ( tmp_args_element_name_77 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posHprInterval" );
        exception_tb = NULL;

        exception_lineno = 530;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_78 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_78 == NULL ))
    {
        tmp_args_element_name_78 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_78 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 530;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 530;
    {
        PyObject *call_args[] = { tmp_args_element_name_77, tmp_args_element_name_78 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_39, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 530;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posHprInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1448 ], 36, 0 );
        exception_tb = NULL;

        exception_lineno = 531;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_44 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_40_posQuatInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatInterval, tmp_assign_source_44 );
    tmp_called_name_40 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_40 == NULL ))
    {
        tmp_called_name_40 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_40 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 537;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_79 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatInterval );

    if (unlikely( tmp_args_element_name_79 == NULL ))
    {
        tmp_args_element_name_79 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posQuatInterval );
    }

    if ( tmp_args_element_name_79 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posQuatInterval" );
        exception_tb = NULL;

        exception_lineno = 537;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_80 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_80 == NULL ))
    {
        tmp_args_element_name_80 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_80 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 537;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 537;
    {
        PyObject *call_args[] = { tmp_args_element_name_79, tmp_args_element_name_80 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_40, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 537;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posQuatInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1484 ], 37, 0 );
        exception_tb = NULL;

        exception_lineno = 538;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_45 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_41_hprScaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hprScaleInterval, tmp_assign_source_45 );
    tmp_called_name_41 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_41 == NULL ))
    {
        tmp_called_name_41 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_41 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 544;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_81 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_hprScaleInterval );

    if (unlikely( tmp_args_element_name_81 == NULL ))
    {
        tmp_args_element_name_81 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_hprScaleInterval );
    }

    if ( tmp_args_element_name_81 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "hprScaleInterval" );
        exception_tb = NULL;

        exception_lineno = 544;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_82 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_82 == NULL ))
    {
        tmp_args_element_name_82 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_82 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 544;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 544;
    {
        PyObject *call_args[] = { tmp_args_element_name_81, tmp_args_element_name_82 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_41, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 544;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_hprScaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1521 ], 38, 0 );
        exception_tb = NULL;

        exception_lineno = 545;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_46 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_42_quatScaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_quatScaleInterval, tmp_assign_source_46 );
    tmp_called_name_42 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_42 == NULL ))
    {
        tmp_called_name_42 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_42 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 551;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_83 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_quatScaleInterval );

    if (unlikely( tmp_args_element_name_83 == NULL ))
    {
        tmp_args_element_name_83 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_quatScaleInterval );
    }

    if ( tmp_args_element_name_83 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "quatScaleInterval" );
        exception_tb = NULL;

        exception_lineno = 551;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_84 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_84 == NULL ))
    {
        tmp_args_element_name_84 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_84 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 551;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 551;
    {
        PyObject *call_args[] = { tmp_args_element_name_83, tmp_args_element_name_84 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_42, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 551;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_quatScaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1559 ], 39, 0 );
        exception_tb = NULL;

        exception_lineno = 552;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_47 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_43_posHprScaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprScaleInterval, tmp_assign_source_47 );
    tmp_called_name_43 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_43 == NULL ))
    {
        tmp_called_name_43 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_43 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 558;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_85 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprScaleInterval );

    if (unlikely( tmp_args_element_name_85 == NULL ))
    {
        tmp_args_element_name_85 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posHprScaleInterval );
    }

    if ( tmp_args_element_name_85 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posHprScaleInterval" );
        exception_tb = NULL;

        exception_lineno = 558;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_86 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_86 == NULL ))
    {
        tmp_args_element_name_86 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_86 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 558;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 558;
    {
        PyObject *call_args[] = { tmp_args_element_name_85, tmp_args_element_name_86 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_43, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 558;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posHprScaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1598 ], 41, 0 );
        exception_tb = NULL;

        exception_lineno = 559;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_48 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_44_posQuatScaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatScaleInterval, tmp_assign_source_48 );
    tmp_called_name_44 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_44 == NULL ))
    {
        tmp_called_name_44 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_44 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 565;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_87 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatScaleInterval );

    if (unlikely( tmp_args_element_name_87 == NULL ))
    {
        tmp_args_element_name_87 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posQuatScaleInterval );
    }

    if ( tmp_args_element_name_87 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posQuatScaleInterval" );
        exception_tb = NULL;

        exception_lineno = 565;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_88 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_88 == NULL ))
    {
        tmp_args_element_name_88 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_88 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 565;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 565;
    {
        PyObject *call_args[] = { tmp_args_element_name_87, tmp_args_element_name_88 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_44, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 565;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posQuatScaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1639 ], 42, 0 );
        exception_tb = NULL;

        exception_lineno = 566;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_49 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_45_posHprScaleShearInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprScaleShearInterval, tmp_assign_source_49 );
    tmp_called_name_45 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_45 == NULL ))
    {
        tmp_called_name_45 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_45 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 572;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_89 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posHprScaleShearInterval );

    if (unlikely( tmp_args_element_name_89 == NULL ))
    {
        tmp_args_element_name_89 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posHprScaleShearInterval );
    }

    if ( tmp_args_element_name_89 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posHprScaleShearInterval" );
        exception_tb = NULL;

        exception_lineno = 572;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_90 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_90 == NULL ))
    {
        tmp_args_element_name_90 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_90 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 572;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 572;
    {
        PyObject *call_args[] = { tmp_args_element_name_89, tmp_args_element_name_90 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_45, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 572;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posHprScaleShearInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1681 ], 46, 0 );
        exception_tb = NULL;

        exception_lineno = 573;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_50 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_46_posQuatScaleShearInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatScaleShearInterval, tmp_assign_source_50 );
    tmp_called_name_46 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_46 == NULL ))
    {
        tmp_called_name_46 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_46 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 579;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_91 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_posQuatScaleShearInterval );

    if (unlikely( tmp_args_element_name_91 == NULL ))
    {
        tmp_args_element_name_91 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_posQuatScaleShearInterval );
    }

    if ( tmp_args_element_name_91 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "posQuatScaleShearInterval" );
        exception_tb = NULL;

        exception_lineno = 579;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_92 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_92 == NULL ))
    {
        tmp_args_element_name_92 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_92 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 579;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 579;
    {
        PyObject *call_args[] = { tmp_args_element_name_91, tmp_args_element_name_92 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_46, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 579;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_posQuatScaleShearInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1727 ], 47, 0 );
        exception_tb = NULL;

        exception_lineno = 580;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_51 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_47_colorInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_colorInterval, tmp_assign_source_51 );
    tmp_called_name_47 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_47 == NULL ))
    {
        tmp_called_name_47 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_47 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 586;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_93 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_colorInterval );

    if (unlikely( tmp_args_element_name_93 == NULL ))
    {
        tmp_args_element_name_93 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_colorInterval );
    }

    if ( tmp_args_element_name_93 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "colorInterval" );
        exception_tb = NULL;

        exception_lineno = 586;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_94 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_94 == NULL ))
    {
        tmp_args_element_name_94 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_94 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 586;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 586;
    {
        PyObject *call_args[] = { tmp_args_element_name_93, tmp_args_element_name_94 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_47, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 586;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_colorInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1774 ], 35, 0 );
        exception_tb = NULL;

        exception_lineno = 587;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_52 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_48_colorScaleInterval(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_colorScaleInterval, tmp_assign_source_52 );
    tmp_called_name_48 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_48 == NULL ))
    {
        tmp_called_name_48 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_48 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 593;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_95 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_colorScaleInterval );

    if (unlikely( tmp_args_element_name_95 == NULL ))
    {
        tmp_args_element_name_95 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_colorScaleInterval );
    }

    if ( tmp_args_element_name_95 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "colorScaleInterval" );
        exception_tb = NULL;

        exception_lineno = 593;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_96 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_96 == NULL ))
    {
        tmp_args_element_name_96 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_96 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 593;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 593;
    {
        PyObject *call_args[] = { tmp_args_element_name_95, tmp_args_element_name_96 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_48, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 593;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_colorScaleInterval );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1809 ], 40, 0 );
        exception_tb = NULL;

        exception_lineno = 594;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_53 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_49_attachCollisionSphere(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionSphere, tmp_assign_source_53 );
    tmp_called_name_49 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_49 == NULL ))
    {
        tmp_called_name_49 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_49 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 607;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_97 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionSphere );

    if (unlikely( tmp_args_element_name_97 == NULL ))
    {
        tmp_args_element_name_97 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_attachCollisionSphere );
    }

    if ( tmp_args_element_name_97 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "attachCollisionSphere" );
        exception_tb = NULL;

        exception_lineno = 607;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_98 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_98 == NULL ))
    {
        tmp_args_element_name_98 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_98 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 607;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 607;
    {
        PyObject *call_args[] = { tmp_args_element_name_97, tmp_args_element_name_98 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_49, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 607;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_attachCollisionSphere );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1849 ], 43, 0 );
        exception_tb = NULL;

        exception_lineno = 608;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_54 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_50_attachCollisionSegment(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionSegment, tmp_assign_source_54 );
    tmp_called_name_50 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_50 == NULL ))
    {
        tmp_called_name_50 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_50 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 621;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_99 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionSegment );

    if (unlikely( tmp_args_element_name_99 == NULL ))
    {
        tmp_args_element_name_99 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_attachCollisionSegment );
    }

    if ( tmp_args_element_name_99 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "attachCollisionSegment" );
        exception_tb = NULL;

        exception_lineno = 621;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_100 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_100 == NULL ))
    {
        tmp_args_element_name_100 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_100 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 621;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 621;
    {
        PyObject *call_args[] = { tmp_args_element_name_99, tmp_args_element_name_100 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_50, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 621;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_attachCollisionSegment );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1892 ], 44, 0 );
        exception_tb = NULL;

        exception_lineno = 622;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_55 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_51_attachCollisionRay(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionRay, tmp_assign_source_55 );
    tmp_called_name_51 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_51 == NULL ))
    {
        tmp_called_name_51 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_51 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 635;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_101 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_attachCollisionRay );

    if (unlikely( tmp_args_element_name_101 == NULL ))
    {
        tmp_args_element_name_101 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_attachCollisionRay );
    }

    if ( tmp_args_element_name_101 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "attachCollisionRay" );
        exception_tb = NULL;

        exception_lineno = 635;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_102 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_102 == NULL ))
    {
        tmp_args_element_name_102 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_102 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 635;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 635;
    {
        PyObject *call_args[] = { tmp_args_element_name_101, tmp_args_element_name_102 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_51, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 635;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_attachCollisionRay );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1936 ], 40, 0 );
        exception_tb = NULL;

        exception_lineno = 636;

        goto frame_exception_exit_1;
    }

    tmp_defaults_17 = const_tuple_none_none_int_0_int_0_none_tuple;
    Py_INCREF( tmp_defaults_17 );
    tmp_assign_source_56 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_52_flattenMultitex( tmp_defaults_17 );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_flattenMultitex, tmp_assign_source_56 );
    tmp_called_name_52 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_52 == NULL ))
    {
        tmp_called_name_52 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_52 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 655;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_103 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_flattenMultitex );

    if (unlikely( tmp_args_element_name_103 == NULL ))
    {
        tmp_args_element_name_103 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_flattenMultitex );
    }

    if ( tmp_args_element_name_103 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "flattenMultitex" );
        exception_tb = NULL;

        exception_lineno = 655;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_104 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_104 == NULL ))
    {
        tmp_args_element_name_104 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_104 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 655;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 655;
    {
        PyObject *call_args[] = { tmp_args_element_name_103, tmp_args_element_name_104 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_52, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 655;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_flattenMultitex );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 1976 ], 37, 0 );
        exception_tb = NULL;

        exception_lineno = 656;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_57 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_53_getNumDescendants(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getNumDescendants, tmp_assign_source_57 );
    tmp_called_name_53 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_53 == NULL ))
    {
        tmp_called_name_53 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_53 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 660;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_105 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_getNumDescendants );

    if (unlikely( tmp_args_element_name_105 == NULL ))
    {
        tmp_args_element_name_105 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_getNumDescendants );
    }

    if ( tmp_args_element_name_105 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "getNumDescendants" );
        exception_tb = NULL;

        exception_lineno = 660;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_106 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_106 == NULL ))
    {
        tmp_args_element_name_106 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_106 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 660;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 660;
    {
        PyObject *call_args[] = { tmp_args_element_name_105, tmp_args_element_name_106 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_53, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 660;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_getNumDescendants );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2013 ], 39, 0 );
        exception_tb = NULL;

        exception_lineno = 661;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_58 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_54_removeNonCollisions(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_removeNonCollisions, tmp_assign_source_58 );
    tmp_called_name_54 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_54 == NULL ))
    {
        tmp_called_name_54 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_54 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 674;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_107 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_removeNonCollisions );

    if (unlikely( tmp_args_element_name_107 == NULL ))
    {
        tmp_args_element_name_107 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_removeNonCollisions );
    }

    if ( tmp_args_element_name_107 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "removeNonCollisions" );
        exception_tb = NULL;

        exception_lineno = 674;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_108 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_108 == NULL ))
    {
        tmp_args_element_name_108 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_108 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 674;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 674;
    {
        PyObject *call_args[] = { tmp_args_element_name_107, tmp_args_element_name_108 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_54, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 674;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_removeNonCollisions );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2052 ], 41, 0 );
        exception_tb = NULL;

        exception_lineno = 675;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_59 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_55_subdivideCollisions(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_subdivideCollisions, tmp_assign_source_59 );
    tmp_assign_source_60 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_56_r_subdivideCollisions(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_r_subdivideCollisions, tmp_assign_source_60 );
    tmp_assign_source_61 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_57_r_constructCollisionTree(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_r_constructCollisionTree, tmp_assign_source_61 );
    tmp_called_name_55 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_55 == NULL ))
    {
        tmp_called_name_55 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_55 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 802;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_109 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_subdivideCollisions );

    if (unlikely( tmp_args_element_name_109 == NULL ))
    {
        tmp_args_element_name_109 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_subdivideCollisions );
    }

    if ( tmp_args_element_name_109 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "subdivideCollisions" );
        exception_tb = NULL;

        exception_lineno = 802;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_110 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_110 == NULL ))
    {
        tmp_args_element_name_110 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_110 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 802;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 802;
    {
        PyObject *call_args[] = { tmp_args_element_name_109, tmp_args_element_name_110 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_55, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 802;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_56 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_56 == NULL ))
    {
        tmp_called_name_56 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_56 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 803;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_111 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_r_subdivideCollisions );

    if (unlikely( tmp_args_element_name_111 == NULL ))
    {
        tmp_args_element_name_111 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_r_subdivideCollisions );
    }

    if ( tmp_args_element_name_111 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "r_subdivideCollisions" );
        exception_tb = NULL;

        exception_lineno = 803;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_112 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_112 == NULL ))
    {
        tmp_args_element_name_112 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_112 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 803;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 803;
    {
        PyObject *call_args[] = { tmp_args_element_name_111, tmp_args_element_name_112 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_56, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 803;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_called_name_57 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_57 == NULL ))
    {
        tmp_called_name_57 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_57 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 804;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_113 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_r_constructCollisionTree );

    if (unlikely( tmp_args_element_name_113 == NULL ))
    {
        tmp_args_element_name_113 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_r_constructCollisionTree );
    }

    if ( tmp_args_element_name_113 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "r_constructCollisionTree" );
        exception_tb = NULL;

        exception_lineno = 804;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_114 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_114 == NULL ))
    {
        tmp_args_element_name_114 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_114 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 804;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 804;
    {
        PyObject *call_args[] = { tmp_args_element_name_113, tmp_args_element_name_114 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_57, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 804;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_subdivideCollisions );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2093 ], 41, 0 );
        exception_tb = NULL;

        exception_lineno = 805;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_r_subdivideCollisions );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2134 ], 43, 0 );
        exception_tb = NULL;

        exception_lineno = 806;

        goto frame_exception_exit_1;
    }

    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_r_constructCollisionTree );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2177 ], 46, 0 );
        exception_tb = NULL;

        exception_lineno = 807;

        goto frame_exception_exit_1;
    }

    tmp_assign_source_62 = MAKE_FUNCTION_direct$extensions_native$NodePath_extensions$$$function_58_analyze(  );
    UPDATE_STRING_DICT1( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_analyze, tmp_assign_source_62 );
    tmp_called_name_58 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );

    if (unlikely( tmp_called_name_58 == NULL ))
    {
        tmp_called_name_58 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_Dtool_funcToMethod );
    }

    if ( tmp_called_name_58 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "Dtool_funcToMethod" );
        exception_tb = NULL;

        exception_lineno = 837;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_115 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_analyze );

    if (unlikely( tmp_args_element_name_115 == NULL ))
    {
        tmp_args_element_name_115 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_analyze );
    }

    if ( tmp_args_element_name_115 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "analyze" );
        exception_tb = NULL;

        exception_lineno = 837;

        goto frame_exception_exit_1;
    }

    tmp_args_element_name_116 = GET_STRING_DICT_VALUE( moduledict_direct$extensions_native$NodePath_extensions, (Nuitka_StringObject *)const_str_plain_NodePath );

    if (unlikely( tmp_args_element_name_116 == NULL ))
    {
        tmp_args_element_name_116 = GET_STRING_DICT_VALUE( dict_builtin, (Nuitka_StringObject *)const_str_plain_NodePath );
    }

    if ( tmp_args_element_name_116 == NULL )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = PyString_FromFormat( "name '%s' is not defined", "NodePath" );
        exception_tb = NULL;

        exception_lineno = 837;

        goto frame_exception_exit_1;
    }

    frame_module->m_frame.f_lineno = 837;
    {
        PyObject *call_args[] = { tmp_args_element_name_115, tmp_args_element_name_116 };
        tmp_unused = CALL_FUNCTION_WITH_ARGS2( tmp_called_name_58, call_args );
    }

    if ( tmp_unused == NULL )
    {
        assert( ERROR_OCCURRED() );

        FETCH_ERROR_OCCURRED( &exception_type, &exception_value, &exception_tb );


        exception_lineno = 837;

        goto frame_exception_exit_1;
    }
    Py_DECREF( tmp_unused );
    tmp_res = PyDict_DelItem( (PyObject *)moduledict_direct$extensions_native$NodePath_extensions, const_str_plain_analyze );
    if ( tmp_res == -1 ) CLEAR_ERROR_OCCURRED();

    if ( tmp_res == -1 )
    {

        exception_type = PyExc_NameError;
        Py_INCREF( exception_type );
        exception_value = UNSTREAM_STRING( &constant_bin[ 2223 ], 29, 0 );
        exception_tb = NULL;

        exception_lineno = 838;

        goto frame_exception_exit_1;
    }


    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif
    popFrameStack();

    assertFrameObject( frame_module );

    goto frame_no_exception_1;
    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION( frame_module );
#endif

    if ( exception_tb == NULL )
    {
        exception_tb = MAKE_TRACEBACK( frame_module, exception_lineno );
    }
    else if ( exception_tb->tb_frame != &frame_module->m_frame )
    {
        exception_tb = ADD_TRACEBACK( exception_tb, frame_module, exception_lineno );
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;
    frame_no_exception_1:;

    return MOD_RETURN_VALUE( module_direct$extensions_native$NodePath_extensions );
    module_exception_exit:
    RESTORE_ERROR_OCCURRED( exception_type, exception_value, exception_tb );
    return MOD_RETURN_VALUE( NULL );
}
